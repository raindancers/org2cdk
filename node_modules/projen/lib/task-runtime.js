"use strict";
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.TaskRuntime = void 0;
const JSII_RTTI_SYMBOL_1 = Symbol.for("jsii.rtti");
const child_process_1 = require("child_process");
const fs_1 = require("fs");
const os_1 = require("os");
const path_1 = require("path");
const path = require("path");
const util_1 = require("util");
const chalk_1 = require("chalk");
const common_1 = require("./common");
const logging = require("./logging");
const ENV_TRIM_LEN = 20;
const ARGS_MARKER = "$@";
/**
 * The runtime component of the tasks engine.
 */
class TaskRuntime {
    constructor(workdir) {
        this.workdir = (0, path_1.resolve)(workdir);
        const manifestPath = (0, path_1.join)(this.workdir, TaskRuntime.MANIFEST_FILE);
        this.manifest = (0, fs_1.existsSync)(manifestPath)
            ? JSON.parse((0, fs_1.readFileSync)(manifestPath, "utf-8"))
            : { tasks: {} };
    }
    /**
     * The tasks in this project.
     */
    get tasks() {
        return Object.values(this.manifest.tasks ?? {});
    }
    /**
     * Find a task by name, or `undefined` if not found.
     */
    tryFindTask(name) {
        if (!this.manifest.tasks) {
            return undefined;
        }
        return this.manifest.tasks[name];
    }
    /**
     * Runs the task.
     * @param name The task name.
     */
    runTask(name, parents = [], args = []) {
        const task = this.tryFindTask(name);
        if (!task) {
            throw new Error(`cannot find command ${task}`);
        }
        new RunTask(this, task, parents, args);
    }
}
_a = JSII_RTTI_SYMBOL_1;
TaskRuntime[_a] = { fqn: "projen.TaskRuntime", version: "0.71.82" };
/**
 * The project-relative path of the tasks manifest file.
 */
TaskRuntime.MANIFEST_FILE = path.posix.join(common_1.PROJEN_DIR, "tasks.json");
exports.TaskRuntime = TaskRuntime;
class RunTask {
    constructor(runtime, task, parents = [], args = []) {
        this.runtime = runtime;
        this.task = task;
        this.env = {};
        this.workdir = task.cwd ?? this.runtime.workdir;
        this.parents = parents;
        if (!task.steps || task.steps.length === 0) {
            this.logDebug((0, chalk_1.gray)("No actions have been specified for this task."));
            return;
        }
        this.env = this.resolveEnvironment(parents);
        const envlogs = [];
        for (const [k, v] of Object.entries(this.env)) {
            const vv = v ?? "";
            const trimmed = vv.length > ENV_TRIM_LEN ? vv.substr(0, ENV_TRIM_LEN) + "..." : vv;
            envlogs.push(`${k}=${trimmed}`);
        }
        if (envlogs.length) {
            this.logDebug((0, chalk_1.gray)(`${(0, chalk_1.underline)("env")}: ${envlogs.join(" ")}`));
        }
        // evaluate condition
        if (!this.evalCondition(task)) {
            this.log("condition exited with non-zero - skipping");
            return;
        }
        // verify we required environment variables are defined
        const merged = { ...process.env, ...this.env };
        const missing = new Array();
        for (const name of task.requiredEnv ?? []) {
            if (!(name in merged)) {
                missing.push(name);
            }
        }
        if (missing.length > 0) {
            throw new Error(`missing required environment variables: ${missing.join(",")}`);
        }
        for (const step of task.steps) {
            // evaluate step condition
            if (!this.evalCondition(step)) {
                this.log("condition exited with non-zero - skipping");
                continue;
            }
            const argsList = [
                ...(step.args || []),
                ...(step.receiveArgs ? args : []),
            ].map((a) => a.toString());
            if (step.say) {
                logging.info(this.fmtLog(step.say));
            }
            if (step.spawn) {
                this.runtime.runTask(step.spawn, [...this.parents, this.task.name], argsList);
            }
            const execs = step.exec ? [step.exec] : [];
            // Parse step-specific environment variables
            const env = this.evalEnvironment(step.env ?? {});
            if (step.builtin) {
                execs.push(this.renderBuiltin(step.builtin));
            }
            for (const exec of execs) {
                let command = "";
                let hasError = false;
                const cmd = exec.split(" ")[0];
                if ((0, os_1.platform)() == "win32" &&
                    ["mkdir", "mv", "rm", "cp"].includes(cmd)) {
                    command = `shx ${exec}`;
                }
                else {
                    command = exec;
                }
                if (command.includes(ARGS_MARKER)) {
                    command = command.replace(ARGS_MARKER, argsList.join(" "));
                }
                else {
                    command = [command, ...argsList].join(" ");
                }
                const cwd = step.cwd;
                try {
                    const result = this.shell({
                        command,
                        cwd,
                        extraEnv: env,
                    });
                    hasError = result.status !== 0;
                }
                catch (e) {
                    // This is the error 'shx' will throw
                    if (e?.message?.startsWith("non-zero exit code:")) {
                        hasError = true;
                    }
                    throw e;
                }
                if (hasError) {
                    throw new Error(`Task "${this.fullname}" failed when executing "${command}" (cwd: ${(0, path_1.resolve)(cwd ?? this.workdir)})`);
                }
            }
        }
    }
    /**
     * Determines if a task should be executed based on "condition".
     *
     * @returns true if the task should be executed or false if the condition
     * evaluates to false (exits with non-zero), indicating that the task should
     * be skipped.
     */
    evalCondition(taskOrStep) {
        // no condition, carry on
        if (!taskOrStep.condition) {
            return true;
        }
        this.log((0, chalk_1.gray)(`${(0, chalk_1.underline)("condition")}: ${taskOrStep.condition}`));
        const result = this.shell({
            command: taskOrStep.condition,
            logprefix: "condition: ",
            quiet: true,
        });
        if (result.status === 0) {
            return true;
        }
        else {
            return false;
        }
    }
    /**
     * Evaluates environment variables from shell commands (e.g. `$(xx)`)
     */
    evalEnvironment(env) {
        const output = {};
        for (const [key, value] of Object.entries(env ?? {})) {
            if (String(value).startsWith("$(") && String(value).endsWith(")")) {
                const query = value.substring(2, value.length - 1);
                const result = this.shellEval({ command: query });
                if (result.status !== 0) {
                    const error = result.error
                        ? result.error.stack
                        : result.stderr?.toString() ?? "unknown error";
                    throw new Error(`unable to evaluate environment variable ${key}=${value}: ${error}`);
                }
                output[key] = result.stdout.toString("utf-8").trim();
            }
            else {
                output[key] = value;
            }
        }
        return output;
    }
    /**
     * Renders the runtime environment for a task. Namely, it supports this syntax
     * `$(xx)` for allowing environment to be evaluated by executing a shell
     * command and obtaining its result.
     */
    resolveEnvironment(parents) {
        let env = this.runtime.manifest.env ?? {};
        // add env from all parent tasks one by one
        for (const parent of parents) {
            env = {
                ...env,
                ...(this.runtime.tryFindTask(parent)?.env ?? {}),
            };
        }
        // apply the task environment last
        env = {
            ...env,
            ...(this.task.env ?? {}),
        };
        return this.evalEnvironment(env ?? {});
    }
    /**
     * Returns the "full name" of the task which includes all it's parent task names concatenated by chevrons.
     */
    get fullname() {
        return [...this.parents, this.task.name].join(" Â» ");
    }
    log(...args) {
        logging.verbose(this.fmtLog(...args));
    }
    logDebug(...args) {
        logging.debug(this.fmtLog(...args));
    }
    fmtLog(...args) {
        return (0, util_1.format)(`${(0, chalk_1.underline)(this.fullname)} |`, ...args);
    }
    shell(options) {
        const quiet = options.quiet ?? false;
        if (!quiet) {
            const log = new Array();
            if (options.logprefix) {
                log.push(options.logprefix);
            }
            log.push(options.command);
            if (options.cwd) {
                log.push(`(cwd: ${options.cwd})`);
            }
            this.log(log.join(" "));
        }
        const cwd = options.cwd ?? this.workdir;
        if (!(0, fs_1.existsSync)(cwd) || !(0, fs_1.statSync)(cwd).isDirectory()) {
            throw new Error(`invalid workdir (cwd): ${cwd} must be an existing directory`);
        }
        return (0, child_process_1.spawnSync)(options.command, {
            ...options,
            cwd,
            shell: true,
            stdio: "inherit",
            env: {
                ...process.env,
                ...this.env,
                ...options.extraEnv,
            },
            ...options.spawnOptions,
        });
    }
    shellEval(options) {
        return this.shell({
            quiet: true,
            ...options,
            spawnOptions: {
                stdio: ["inherit", "pipe", "inherit"],
            },
        });
    }
    renderBuiltin(builtin) {
        const moduleRoot = (0, path_1.dirname)(require.resolve("../package.json"));
        const program = require.resolve((0, path_1.join)(moduleRoot, "lib", `${builtin}.task.js`));
        return `${process.execPath} ${program}`;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFzay1ydW50aW1lLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vc3JjL3Rhc2stcnVudGltZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLGlEQUF3RDtBQUN4RCwyQkFBd0Q7QUFDeEQsMkJBQThCO0FBQzlCLCtCQUE4QztBQUM5Qyw2QkFBNkI7QUFDN0IsK0JBQThCO0FBQzlCLGlDQUF3QztBQUN4QyxxQ0FBc0M7QUFDdEMscUNBQXFDO0FBR3JDLE1BQU0sWUFBWSxHQUFHLEVBQUUsQ0FBQztBQUN4QixNQUFNLFdBQVcsR0FBRyxJQUFJLENBQUM7QUFFekI7O0dBRUc7QUFDSCxNQUFhLFdBQVc7SUFtQnRCLFlBQVksT0FBZTtRQUN6QixJQUFJLENBQUMsT0FBTyxHQUFHLElBQUEsY0FBTyxFQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2hDLE1BQU0sWUFBWSxHQUFHLElBQUEsV0FBSSxFQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO1FBQ25FLElBQUksQ0FBQyxRQUFRLEdBQUcsSUFBQSxlQUFVLEVBQUMsWUFBWSxDQUFDO1lBQ3RDLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUEsaUJBQVksRUFBQyxZQUFZLEVBQUUsT0FBTyxDQUFDLENBQUM7WUFDakQsQ0FBQyxDQUFDLEVBQUUsS0FBSyxFQUFFLEVBQUUsRUFBRSxDQUFDO0lBQ3BCLENBQUM7SUFFRDs7T0FFRztJQUNILElBQVcsS0FBSztRQUNkLE9BQU8sTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLEtBQUssSUFBSSxFQUFFLENBQUMsQ0FBQztJQUNsRCxDQUFDO0lBRUQ7O09BRUc7SUFDSSxXQUFXLENBQUMsSUFBWTtRQUM3QixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUU7WUFDeEIsT0FBTyxTQUFTLENBQUM7U0FDbEI7UUFDRCxPQUFPLElBQUksQ0FBQyxR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LElBQUksQ0FBQyxHQUFHO2dCQUNYLEdBQUcsT0FBTyxDQUFDLFFBQVE7YUFDcEI7WUFDRCxHQUFHLE9BQU8sQ0FBQyxZQUFZO1NBQ3hCLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFTyxTQUFTLENBQUMsT0FBcUI7UUFDckMsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDO1lBQ2hCLEtBQUssRUFBRSxJQUFJO1lBQ1gsR0FBRyxPQUFPO1lBQ1YsWUFBWSxFQUFFO2dCQUNaLEtBQUssRUFBRSxDQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsU0FBUyxDQUFDO2FBQ3RDO1NBQ0YsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVPLGFBQWEsQ0FBQyxPQUFlO1FBQ25DLE1BQU0sVUFBVSxHQUFHLElBQUEsY0FBTyxFQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsaUJBQWlCLENBQUMsQ0FBQyxDQUFDO1FBQy9ELE1BQU0sT0FBTyxHQUFHLE9BQU8sQ0FBQyxPQUFPLENBQzdCLElBQUEsV0FBSSxFQUFDLFVBQVUsRUFBRSxLQUFLLEVBQUUsR0FBRyxPQUFPLFVBQVUsQ0FBQyxDQUM5QyxDQUFDO1FBQ0YsT0FBTyxHQUFHLE9BQU8sQ0FBQyxRQUFRLElBQUksT0FBTyxFQUFFLENBQUM7SUFDMUMsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgU3Bhd25PcHRpb25zLCBzcGF3blN5bmMgfSBmcm9tIFwiY2hpbGRfcHJvY2Vzc1wiO1xuaW1wb3J0IHsgZXhpc3RzU3luYywgcmVhZEZpbGVTeW5jLCBzdGF0U3luYyB9IGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgcGxhdGZvcm0gfSBmcm9tIFwib3NcIjtcbmltcG9ydCB7IGRpcm5hbWUsIGpvaW4sIHJlc29sdmUgfSBmcm9tIFwicGF0aFwiO1xuaW1wb3J0ICogYXMgcGF0aCBmcm9tIFwicGF0aFwiO1xuaW1wb3J0IHsgZm9ybWF0IH0gZnJvbSBcInV0aWxcIjtcbmltcG9ydCB7IGdyYXksIHVuZGVybGluZSB9IGZyb20gXCJjaGFsa1wiO1xuaW1wb3J0IHsgUFJPSkVOX0RJUiB9IGZyb20gXCIuL2NvbW1vblwiO1xuaW1wb3J0ICogYXMgbG9nZ2luZyBmcm9tIFwiLi9sb2dnaW5nXCI7XG5pbXBvcnQgeyBUYXNrc01hbmlmZXN0LCBUYXNrU3BlYywgVGFza1N0ZXAgfSBmcm9tIFwiLi90YXNrLW1vZGVsXCI7XG5cbmNvbnN0IEVOVl9UUklNX0xFTiA9IDIwO1xuY29uc3QgQVJHU19NQVJLRVIgPSBcIiRAXCI7XG5cbi8qKlxuICogVGhlIHJ1bnRpbWUgY29tcG9uZW50IG9mIHRoZSB0YXNrcyBlbmdpbmUuXG4gKi9cbmV4cG9ydCBjbGFzcyBUYXNrUnVudGltZSB7XG4gIC8qKlxuICAgKiBUaGUgcHJvamVjdC1yZWxhdGl2ZSBwYXRoIG9mIHRoZSB0YXNrcyBtYW5pZmVzdCBmaWxlLlxuICAgKi9cbiAgcHVibGljIHN0YXRpYyByZWFkb25seSBNQU5JRkVTVF9GSUxFID0gcGF0aC5wb3NpeC5qb2luKFxuICAgIFBST0pFTl9ESVIsXG4gICAgXCJ0YXNrcy5qc29uXCJcbiAgKTtcblxuICAvKipcbiAgICogVGhlIGNvbnRlbnRzIG9mIHRhc2tzLmpzb25cbiAgICovXG4gIHB1YmxpYyByZWFkb25seSBtYW5pZmVzdDogVGFza3NNYW5pZmVzdDtcblxuICAvKipcbiAgICogVGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoZSBwcm9qZWN0IGFuZCB0aGUgY3dkIGZvciBleGVjdXRpbmcgdGFza3MuXG4gICAqL1xuICBwdWJsaWMgcmVhZG9ubHkgd29ya2Rpcjogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHdvcmtkaXI6IHN0cmluZykge1xuICAgIHRoaXMud29ya2RpciA9IHJlc29sdmUod29ya2Rpcik7XG4gICAgY29uc3QgbWFuaWZlc3RQYXRoID0gam9pbih0aGlzLndvcmtkaXIsIFRhc2tSdW50aW1lLk1BTklGRVNUX0ZJTEUpO1xuICAgIHRoaXMubWFuaWZlc3QgPSBleGlzdHNTeW5jKG1hbmlmZXN0UGF0aClcbiAgICAgID8gSlNPTi5wYXJzZShyZWFkRmlsZVN5bmMobWFuaWZlc3RQYXRoLCBcInV0Zi04XCIpKVxuICAgICAgOiB7IHRhc2tzOiB7fSB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSB0YXNrcyBpbiB0aGlzIHByb2plY3QuXG4gICAqL1xuICBwdWJsaWMgZ2V0IHRhc2tzKCk6IFRhc2tTcGVjW10ge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMubWFuaWZlc3QudGFza3MgPz8ge30pO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmQgYSB0YXNrIGJ5IG5hbWUsIG9yIGB1bmRlZmluZWRgIGlmIG5vdCBmb3VuZC5cbiAgICovXG4gIHB1YmxpYyB0cnlGaW5kVGFzayhuYW1lOiBzdHJpbmcpOiBUYXNrU3BlYyB8IHVuZGVmaW5lZCB7XG4gICAgaWYgKCF0aGlzLm1hbmlmZXN0LnRhc2tzKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tYW5pZmVzdC50YXNrc1tuYW1lXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIHRoZSB0YXNrLlxuICAgKiBAcGFyYW0gbmFtZSBUaGUgdGFzayBuYW1lLlxuICAgKi9cbiAgcHVibGljIHJ1blRhc2soXG4gICAgbmFtZTogc3RyaW5nLFxuICAgIHBhcmVudHM6IHN0cmluZ1tdID0gW10sXG4gICAgYXJnczogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiA9IFtdXG4gICkge1xuICAgIGNvbnN0IHRhc2sgPSB0aGlzLnRyeUZpbmRUYXNrKG5hbWUpO1xuICAgIGlmICghdGFzaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW5ub3QgZmluZCBjb21tYW5kICR7dGFza31gKTtcbiAgICB9XG5cbiAgICBuZXcgUnVuVGFzayh0aGlzLCB0YXNrLCBwYXJlbnRzLCBhcmdzKTtcbiAgfVxufVxuXG5jbGFzcyBSdW5UYXNrIHtcbiAgcHJpdmF0ZSByZWFkb25seSBlbnY6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB8IHVuZGVmaW5lZCB9ID0ge307XG4gIHByaXZhdGUgcmVhZG9ubHkgcGFyZW50czogc3RyaW5nW107XG5cbiAgcHJpdmF0ZSByZWFkb25seSB3b3JrZGlyOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBydW50aW1lOiBUYXNrUnVudGltZSxcbiAgICBwcml2YXRlIHJlYWRvbmx5IHRhc2s6IFRhc2tTcGVjLFxuICAgIHBhcmVudHM6IHN0cmluZ1tdID0gW10sXG4gICAgYXJnczogQXJyYXk8c3RyaW5nIHwgbnVtYmVyPiA9IFtdXG4gICkge1xuICAgIHRoaXMud29ya2RpciA9IHRhc2suY3dkID8/IHRoaXMucnVudGltZS53b3JrZGlyO1xuXG4gICAgdGhpcy5wYXJlbnRzID0gcGFyZW50cztcblxuICAgIGlmICghdGFzay5zdGVwcyB8fCB0YXNrLnN0ZXBzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5sb2dEZWJ1ZyhncmF5KFwiTm8gYWN0aW9ucyBoYXZlIGJlZW4gc3BlY2lmaWVkIGZvciB0aGlzIHRhc2suXCIpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLmVudiA9IHRoaXMucmVzb2x2ZUVudmlyb25tZW50KHBhcmVudHMpO1xuXG4gICAgY29uc3QgZW52bG9ncyA9IFtdO1xuICAgIGZvciAoY29uc3QgW2ssIHZdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZW52KSkge1xuICAgICAgY29uc3QgdnYgPSB2ID8/IFwiXCI7XG4gICAgICBjb25zdCB0cmltbWVkID1cbiAgICAgICAgdnYubGVuZ3RoID4gRU5WX1RSSU1fTEVOID8gdnYuc3Vic3RyKDAsIEVOVl9UUklNX0xFTikgKyBcIi4uLlwiIDogdnY7XG4gICAgICBlbnZsb2dzLnB1c2goYCR7a309JHt0cmltbWVkfWApO1xuICAgIH1cblxuICAgIGlmIChlbnZsb2dzLmxlbmd0aCkge1xuICAgICAgdGhpcy5sb2dEZWJ1ZyhncmF5KGAke3VuZGVybGluZShcImVudlwiKX06ICR7ZW52bG9ncy5qb2luKFwiIFwiKX1gKSk7XG4gICAgfVxuXG4gICAgLy8gZXZhbHVhdGUgY29uZGl0aW9uXG4gICAgaWYgKCF0aGlzLmV2YWxDb25kaXRpb24odGFzaykpIHtcbiAgICAgIHRoaXMubG9nKFwiY29uZGl0aW9uIGV4aXRlZCB3aXRoIG5vbi16ZXJvIC0gc2tpcHBpbmdcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdmVyaWZ5IHdlIHJlcXVpcmVkIGVudmlyb25tZW50IHZhcmlhYmxlcyBhcmUgZGVmaW5lZFxuICAgIGNvbnN0IG1lcmdlZCA9IHsgLi4ucHJvY2Vzcy5lbnYsIC4uLnRoaXMuZW52IH07XG4gICAgY29uc3QgbWlzc2luZyA9IG5ldyBBcnJheTxzdHJpbmc+KCk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIHRhc2sucmVxdWlyZWRFbnYgPz8gW10pIHtcbiAgICAgIGlmICghKG5hbWUgaW4gbWVyZ2VkKSkge1xuICAgICAgICBtaXNzaW5nLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1pc3NpbmcubGVuZ3RoID4gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgbWlzc2luZyByZXF1aXJlZCBlbnZpcm9ubWVudCB2YXJpYWJsZXM6ICR7bWlzc2luZy5qb2luKFwiLFwiKX1gXG4gICAgICApO1xuICAgIH1cblxuICAgIGZvciAoY29uc3Qgc3RlcCBvZiB0YXNrLnN0ZXBzKSB7XG4gICAgICAvLyBldmFsdWF0ZSBzdGVwIGNvbmRpdGlvblxuICAgICAgaWYgKCF0aGlzLmV2YWxDb25kaXRpb24oc3RlcCkpIHtcbiAgICAgICAgdGhpcy5sb2coXCJjb25kaXRpb24gZXhpdGVkIHdpdGggbm9uLXplcm8gLSBza2lwcGluZ1wiKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGFyZ3NMaXN0OiBzdHJpbmdbXSA9IFtcbiAgICAgICAgLi4uKHN0ZXAuYXJncyB8fCBbXSksXG4gICAgICAgIC4uLihzdGVwLnJlY2VpdmVBcmdzID8gYXJncyA6IFtdKSxcbiAgICAgIF0ubWFwKChhKSA9PiBhLnRvU3RyaW5nKCkpO1xuXG4gICAgICBpZiAoc3RlcC5zYXkpIHtcbiAgICAgICAgbG9nZ2luZy5pbmZvKHRoaXMuZm10TG9nKHN0ZXAuc2F5KSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGVwLnNwYXduKSB7XG4gICAgICAgIHRoaXMucnVudGltZS5ydW5UYXNrKFxuICAgICAgICAgIHN0ZXAuc3Bhd24sXG4gICAgICAgICAgWy4uLnRoaXMucGFyZW50cywgdGhpcy50YXNrLm5hbWVdLFxuICAgICAgICAgIGFyZ3NMaXN0XG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGV4ZWNzID0gc3RlcC5leGVjID8gW3N0ZXAuZXhlY10gOiBbXTtcblxuICAgICAgLy8gUGFyc2Ugc3RlcC1zcGVjaWZpYyBlbnZpcm9ubWVudCB2YXJpYWJsZXNcbiAgICAgIGNvbnN0IGVudiA9IHRoaXMuZXZhbEVudmlyb25tZW50KHN0ZXAuZW52ID8/IHt9KTtcblxuICAgICAgaWYgKHN0ZXAuYnVpbHRpbikge1xuICAgICAgICBleGVjcy5wdXNoKHRoaXMucmVuZGVyQnVpbHRpbihzdGVwLmJ1aWx0aW4pKTtcbiAgICAgIH1cblxuICAgICAgZm9yIChjb25zdCBleGVjIG9mIGV4ZWNzKSB7XG4gICAgICAgIGxldCBjb21tYW5kID0gXCJcIjtcbiAgICAgICAgbGV0IGhhc0Vycm9yID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGNtZCA9IGV4ZWMuc3BsaXQoXCIgXCIpWzBdO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgcGxhdGZvcm0oKSA9PSBcIndpbjMyXCIgJiZcbiAgICAgICAgICBbXCJta2RpclwiLCBcIm12XCIsIFwicm1cIiwgXCJjcFwiXS5pbmNsdWRlcyhjbWQpXG4gICAgICAgICkge1xuICAgICAgICAgIGNvbW1hbmQgPSBgc2h4ICR7ZXhlY31gO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1hbmQgPSBleGVjO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbW1hbmQuaW5jbHVkZXMoQVJHU19NQVJLRVIpKSB7XG4gICAgICAgICAgY29tbWFuZCA9IGNvbW1hbmQucmVwbGFjZShBUkdTX01BUktFUiwgYXJnc0xpc3Quam9pbihcIiBcIikpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbW1hbmQgPSBbY29tbWFuZCwgLi4uYXJnc0xpc3RdLmpvaW4oXCIgXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3dkID0gc3RlcC5jd2Q7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5zaGVsbCh7XG4gICAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgICAgY3dkLFxuICAgICAgICAgICAgZXh0cmFFbnY6IGVudixcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBoYXNFcnJvciA9IHJlc3VsdC5zdGF0dXMgIT09IDA7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIHRoZSBlcnJvciAnc2h4JyB3aWxsIHRocm93XG4gICAgICAgICAgaWYgKChlIGFzIGFueSk/Lm1lc3NhZ2U/LnN0YXJ0c1dpdGgoXCJub24temVybyBleGl0IGNvZGU6XCIpKSB7XG4gICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhhc0Vycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFRhc2sgXCIke1xuICAgICAgICAgICAgICB0aGlzLmZ1bGxuYW1lXG4gICAgICAgICAgICB9XCIgZmFpbGVkIHdoZW4gZXhlY3V0aW5nIFwiJHtjb21tYW5kfVwiIChjd2Q6ICR7cmVzb2x2ZShcbiAgICAgICAgICAgICAgY3dkID8/IHRoaXMud29ya2RpclxuICAgICAgICAgICAgKX0pYFxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lcyBpZiBhIHRhc2sgc2hvdWxkIGJlIGV4ZWN1dGVkIGJhc2VkIG9uIFwiY29uZGl0aW9uXCIuXG4gICAqXG4gICAqIEByZXR1cm5zIHRydWUgaWYgdGhlIHRhc2sgc2hvdWxkIGJlIGV4ZWN1dGVkIG9yIGZhbHNlIGlmIHRoZSBjb25kaXRpb25cbiAgICogZXZhbHVhdGVzIHRvIGZhbHNlIChleGl0cyB3aXRoIG5vbi16ZXJvKSwgaW5kaWNhdGluZyB0aGF0IHRoZSB0YXNrIHNob3VsZFxuICAgKiBiZSBza2lwcGVkLlxuICAgKi9cbiAgcHJpdmF0ZSBldmFsQ29uZGl0aW9uKHRhc2tPclN0ZXA6IFRhc2tTcGVjIHwgVGFza1N0ZXApIHtcbiAgICAvLyBubyBjb25kaXRpb24sIGNhcnJ5IG9uXG4gICAgaWYgKCF0YXNrT3JTdGVwLmNvbmRpdGlvbikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgdGhpcy5sb2coZ3JheShgJHt1bmRlcmxpbmUoXCJjb25kaXRpb25cIil9OiAke3Rhc2tPclN0ZXAuY29uZGl0aW9ufWApKTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNoZWxsKHtcbiAgICAgIGNvbW1hbmQ6IHRhc2tPclN0ZXAuY29uZGl0aW9uLFxuICAgICAgbG9ncHJlZml4OiBcImNvbmRpdGlvbjogXCIsXG4gICAgICBxdWlldDogdHJ1ZSxcbiAgICB9KTtcbiAgICBpZiAocmVzdWx0LnN0YXR1cyA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXZhbHVhdGVzIGVudmlyb25tZW50IHZhcmlhYmxlcyBmcm9tIHNoZWxsIGNvbW1hbmRzIChlLmcuIGAkKHh4KWApXG4gICAqL1xuICBwcml2YXRlIGV2YWxFbnZpcm9ubWVudChlbnY6IHsgW25hbWU6IHN0cmluZ106IHN0cmluZyB9KSB7XG4gICAgY29uc3Qgb3V0cHV0OiB7IFtuYW1lOiBzdHJpbmddOiBzdHJpbmcgfCB1bmRlZmluZWQgfSA9IHt9O1xuXG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoZW52ID8/IHt9KSkge1xuICAgICAgaWYgKFN0cmluZyh2YWx1ZSkuc3RhcnRzV2l0aChcIiQoXCIpICYmIFN0cmluZyh2YWx1ZSkuZW5kc1dpdGgoXCIpXCIpKSB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gdmFsdWUuc3Vic3RyaW5nKDIsIHZhbHVlLmxlbmd0aCAtIDEpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNoZWxsRXZhbCh7IGNvbW1hbmQ6IHF1ZXJ5IH0pO1xuICAgICAgICBpZiAocmVzdWx0LnN0YXR1cyAhPT0gMCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gcmVzdWx0LmVycm9yXG4gICAgICAgICAgICA/IHJlc3VsdC5lcnJvci5zdGFja1xuICAgICAgICAgICAgOiByZXN1bHQuc3RkZXJyPy50b1N0cmluZygpID8/IFwidW5rbm93biBlcnJvclwiO1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGB1bmFibGUgdG8gZXZhbHVhdGUgZW52aXJvbm1lbnQgdmFyaWFibGUgJHtrZXl9PSR7dmFsdWV9OiAke2Vycm9yfWBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dFtrZXldID0gcmVzdWx0LnN0ZG91dC50b1N0cmluZyhcInV0Zi04XCIpLnRyaW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG4gIH1cblxuICAvKipcbiAgICogUmVuZGVycyB0aGUgcnVudGltZSBlbnZpcm9ubWVudCBmb3IgYSB0YXNrLiBOYW1lbHksIGl0IHN1cHBvcnRzIHRoaXMgc3ludGF4XG4gICAqIGAkKHh4KWAgZm9yIGFsbG93aW5nIGVudmlyb25tZW50IHRvIGJlIGV2YWx1YXRlZCBieSBleGVjdXRpbmcgYSBzaGVsbFxuICAgKiBjb21tYW5kIGFuZCBvYnRhaW5pbmcgaXRzIHJlc3VsdC5cbiAgICovXG4gIHByaXZhdGUgcmVzb2x2ZUVudmlyb25tZW50KHBhcmVudHM6IHN0cmluZ1tdKSB7XG4gICAgbGV0IGVudiA9IHRoaXMucnVudGltZS5tYW5pZmVzdC5lbnYgPz8ge307XG5cbiAgICAvLyBhZGQgZW52IGZyb20gYWxsIHBhcmVudCB0YXNrcyBvbmUgYnkgb25lXG4gICAgZm9yIChjb25zdCBwYXJlbnQgb2YgcGFyZW50cykge1xuICAgICAgZW52ID0ge1xuICAgICAgICAuLi5lbnYsXG4gICAgICAgIC4uLih0aGlzLnJ1bnRpbWUudHJ5RmluZFRhc2socGFyZW50KT8uZW52ID8/IHt9KSxcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gYXBwbHkgdGhlIHRhc2sgZW52aXJvbm1lbnQgbGFzdFxuICAgIGVudiA9IHtcbiAgICAgIC4uLmVudixcbiAgICAgIC4uLih0aGlzLnRhc2suZW52ID8/IHt9KSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHRoaXMuZXZhbEVudmlyb25tZW50KGVudiA/PyB7fSk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgXCJmdWxsIG5hbWVcIiBvZiB0aGUgdGFzayB3aGljaCBpbmNsdWRlcyBhbGwgaXQncyBwYXJlbnQgdGFzayBuYW1lcyBjb25jYXRlbmF0ZWQgYnkgY2hldnJvbnMuXG4gICAqL1xuICBwcml2YXRlIGdldCBmdWxsbmFtZSgpIHtcbiAgICByZXR1cm4gWy4uLnRoaXMucGFyZW50cywgdGhpcy50YXNrLm5hbWVdLmpvaW4oXCIgwrsgXCIpO1xuICB9XG5cbiAgcHJpdmF0ZSBsb2coLi4uYXJnczogYW55W10pIHtcbiAgICBsb2dnaW5nLnZlcmJvc2UodGhpcy5mbXRMb2coLi4uYXJncykpO1xuICB9XG5cbiAgcHJpdmF0ZSBsb2dEZWJ1ZyguLi5hcmdzOiBhbnlbXSkge1xuICAgIGxvZ2dpbmcuZGVidWcodGhpcy5mbXRMb2coLi4uYXJncykpO1xuICB9XG5cbiAgcHJpdmF0ZSBmbXRMb2coLi4uYXJnczogYW55W10pIHtcbiAgICByZXR1cm4gZm9ybWF0KGAke3VuZGVybGluZSh0aGlzLmZ1bGxuYW1lKX0gfGAsIC4uLmFyZ3MpO1xuICB9XG5cbiAgcHJpdmF0ZSBzaGVsbChvcHRpb25zOiBTaGVsbE9wdGlvbnMpIHtcbiAgICBjb25zdCBxdWlldCA9IG9wdGlvbnMucXVpZXQgPz8gZmFsc2U7XG4gICAgaWYgKCFxdWlldCkge1xuICAgICAgY29uc3QgbG9nID0gbmV3IEFycmF5PHN0cmluZz4oKTtcblxuICAgICAgaWYgKG9wdGlvbnMubG9ncHJlZml4KSB7XG4gICAgICAgIGxvZy5wdXNoKG9wdGlvbnMubG9ncHJlZml4KTtcbiAgICAgIH1cblxuICAgICAgbG9nLnB1c2gob3B0aW9ucy5jb21tYW5kKTtcblxuICAgICAgaWYgKG9wdGlvbnMuY3dkKSB7XG4gICAgICAgIGxvZy5wdXNoKGAoY3dkOiAke29wdGlvbnMuY3dkfSlgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2cobG9nLmpvaW4oXCIgXCIpKTtcbiAgICB9XG5cbiAgICBjb25zdCBjd2QgPSBvcHRpb25zLmN3ZCA/PyB0aGlzLndvcmtkaXI7XG4gICAgaWYgKCFleGlzdHNTeW5jKGN3ZCkgfHwgIXN0YXRTeW5jKGN3ZCkuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgaW52YWxpZCB3b3JrZGlyIChjd2QpOiAke2N3ZH0gbXVzdCBiZSBhbiBleGlzdGluZyBkaXJlY3RvcnlgXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBzcGF3blN5bmMob3B0aW9ucy5jb21tYW5kLCB7XG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgY3dkLFxuICAgICAgc2hlbGw6IHRydWUsXG4gICAgICBzdGRpbzogXCJpbmhlcml0XCIsXG4gICAgICBlbnY6IHtcbiAgICAgICAgLi4ucHJvY2Vzcy5lbnYsXG4gICAgICAgIC4uLnRoaXMuZW52LFxuICAgICAgICAuLi5vcHRpb25zLmV4dHJhRW52LFxuICAgICAgfSxcbiAgICAgIC4uLm9wdGlvbnMuc3Bhd25PcHRpb25zLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzaGVsbEV2YWwob3B0aW9uczogU2hlbGxPcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuc2hlbGwoe1xuICAgICAgcXVpZXQ6IHRydWUsXG4gICAgICAuLi5vcHRpb25zLFxuICAgICAgc3Bhd25PcHRpb25zOiB7XG4gICAgICAgIHN0ZGlvOiBbXCJpbmhlcml0XCIsIFwicGlwZVwiLCBcImluaGVyaXRcIl0sXG4gICAgICB9LFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSByZW5kZXJCdWlsdGluKGJ1aWx0aW46IHN0cmluZykge1xuICAgIGNvbnN0IG1vZHVsZVJvb3QgPSBkaXJuYW1lKHJlcXVpcmUucmVzb2x2ZShcIi4uL3BhY2thZ2UuanNvblwiKSk7XG4gICAgY29uc3QgcHJvZ3JhbSA9IHJlcXVpcmUucmVzb2x2ZShcbiAgICAgIGpvaW4obW9kdWxlUm9vdCwgXCJsaWJcIiwgYCR7YnVpbHRpbn0udGFzay5qc2ApXG4gICAgKTtcbiAgICByZXR1cm4gYCR7cHJvY2Vzcy5leGVjUGF0aH0gJHtwcm9ncmFtfWA7XG4gIH1cbn1cblxuaW50ZXJmYWNlIFNoZWxsT3B0aW9ucyB7XG4gIHJlYWRvbmx5IGNvbW1hbmQ6IHN0cmluZztcbiAgLyoqXG4gICAqIEBkZWZhdWx0IC0gcHJvamVjdCBkaXJcbiAgICovXG4gIHJlYWRvbmx5IGN3ZD86IHN0cmluZztcbiAgcmVhZG9ubHkgbG9ncHJlZml4Pzogc3RyaW5nO1xuICByZWFkb25seSBzcGF3bk9wdGlvbnM/OiBTcGF3bk9wdGlvbnM7XG4gIC8qKiBAZGVmYXVsdCBmYWxzZSAqL1xuICByZWFkb25seSBxdWlldD86IGJvb2xlYW47XG4gIHJlYWRvbmx5IGV4dHJhRW52PzogeyBbbmFtZTogc3RyaW5nXTogc3RyaW5nIHwgdW5kZWZpbmVkIH07XG59XG4iXX0=