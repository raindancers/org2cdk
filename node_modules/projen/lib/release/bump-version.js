"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.bump = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const semver_1 = require("semver");
const logging = require("../logging");
const util_1 = require("../util");
/**
 * Resolves the latest version from git tags and uses `standard-version` to bump
 * to the next version based on commits.
 *
 * This expects `standard-version` to be installed in the path.
 *
 * @param cwd working directory (git repository)
 * @param options options
 */
async function bump(cwd, options) {
    const versionFile = (0, path_1.join)(cwd, options.versionFile);
    const prerelease = options.prerelease;
    const major = options.majorVersion;
    const minMajorVersion = options.minMajorVersion;
    const prefix = options.tagPrefix ?? "";
    const bumpFile = (0, path_1.join)(cwd, options.bumpFile);
    const changelogFile = (0, path_1.join)(cwd, options.changelog);
    const releaseTagFile = (0, path_1.join)(cwd, options.releaseTagFile);
    if (major && minMajorVersion) {
        throw new Error(`minMajorVersion and majorVersion cannot be used together.`);
    }
    await fs_1.promises.mkdir((0, path_1.dirname)(bumpFile), { recursive: true });
    await fs_1.promises.mkdir((0, path_1.dirname)(changelogFile), { recursive: true });
    await fs_1.promises.mkdir((0, path_1.dirname)(releaseTagFile), { recursive: true });
    const { latestVersion, latestTag, isFirstRelease } = determineLatestTag({
        cwd,
        major,
        prerelease,
        prefix,
    });
    const content = await tryReadVersionFile(versionFile);
    // update version
    content.version = latestVersion;
    logging.info(`Update ${versionFile} to latest resolved version: ${latestVersion}`);
    await fs_1.promises.writeFile(versionFile, JSON.stringify(content, undefined, 2));
    // check if the latest commit already has a version tag
    const currentTags = (0, util_1.execCapture)("git tag --points-at HEAD", { cwd })
        .toString("utf8")
        .split("\n");
    logging.info(`Tags listed on current commit: ${currentTags}`);
    let skipBump = false;
    if (currentTags.includes(latestTag)) {
        logging.info("Skipping bump...");
        skipBump = true;
        // delete the existing tag (locally)
        // if we don't do this, standard-version generates an empty changelog
        (0, util_1.exec)(`git tag --delete ${latestTag}`, { cwd });
    }
    // create a standard-version configuration file
    const rcfile = (0, path_1.join)(cwd, ".versionrc.json");
    await generateVersionrcFile(rcfile, versionFile, changelogFile, skipBump, prerelease, options.versionrcOptions);
    const cmd = ["npx", "standard-version@^9"];
    if (isFirstRelease) {
        cmd.push("--first-release");
    }
    if (prefix) {
        cmd.push(`--tag-prefix ${prefix}v`);
    }
    if (minMajorVersion) {
        const [majorVersion] = latestVersion.split(".");
        const majorVersionNumber = parseInt(majorVersion, 10);
        if (majorVersionNumber < minMajorVersion) {
            cmd.push(`--release-as ${minMajorVersion}.0.0`);
        }
    }
    (0, util_1.exec)(cmd.join(" "), { cwd });
    // add the tag back if it was previously removed
    if (currentTags.includes(latestTag)) {
        (0, util_1.exec)(`git tag ${latestTag}`, { cwd });
    }
    await fs_1.promises.rm(rcfile, { force: true, recursive: true });
    const newVersion = (await tryReadVersionFile(versionFile)).version;
    if (!newVersion) {
        throw new Error(`bump failed: ${versionFile} does not have a version set`);
    }
    // if MAJOR is defined, ensure that the new version is within the same major version
    if (major) {
        if (!newVersion.startsWith(`${major}.`)) {
            throw new Error(`bump failed: this branch is configured to only publish v${major} releases - bump resulted in ${newVersion}`);
        }
    }
    await fs_1.promises.writeFile(bumpFile, newVersion);
    const newTag = `${prefix}v${newVersion}`;
    await fs_1.promises.writeFile(releaseTagFile, newTag);
}
exports.bump = bump;
async function tryReadVersionFile(versionFile) {
    if (!(0, fs_1.existsSync)(versionFile)) {
        return {};
    }
    return JSON.parse(await fs_1.promises.readFile(versionFile, "utf-8"));
}
function generateVersionrcFile(rcfile, versionFile, changelogFile, skipBump, prerelease, configOptions) {
    return fs_1.promises.writeFile(rcfile, JSON.stringify({
        ...{
            packageFiles: [
                {
                    filename: versionFile,
                    type: "json",
                },
            ],
            bumpFiles: [
                {
                    filename: versionFile,
                    type: "json",
                },
            ],
            commitAll: false,
            infile: changelogFile,
            prerelease: prerelease,
            header: "",
            skip: {
                commit: true,
                tag: true,
                bump: skipBump,
            },
            ...configOptions,
        },
    }, undefined, 2));
}
/**
 * Determines the latest release tag.
 * @param major (optional) A major version line to select from
 * @param prerelease (optional) A pre-release suffix.
 * @returns the latest tag, and whether it is the first release or not
 */
function determineLatestTag(options) {
    const { cwd, major, prerelease, prefix } = options;
    // filter only tags for this prefix and major version if specified (start with "vNN.").
    const prefixFilter = major !== undefined ? `${prefix}v${major}.*` : `${prefix}v*`;
    const listGitTags = [
        "git",
        '-c "versionsort.suffix=-"',
        "tag",
        '--sort="-version:refname"',
        "--list",
        `"${prefixFilter}"`,
    ].join(" ");
    const stdout = (0, util_1.execCapture)(listGitTags, { cwd }).toString("utf8");
    let tags = stdout?.split("\n");
    // if prerelease is set and there are existing prerelease tags, filter versions that end with "-PRE.ddd".
    const prereleaseTags = tags.filter((x) => new RegExp(`-${prerelease}\.[0-9]+$`).test(x));
    if (prerelease && prereleaseTags.length > 0) {
        /**
         * Cover the following case specifically
         * 1 - v1.0.0
         * 2 - v1.0.1-beta.0
         * 3 - v1.0.1-beta.1
         * 4 - v1.0.1
         * 5 - now publish a new release on the prerelease branch
         *    by setting the latestTag as v1.0.1 instead of v1.0.1-beta.1
         */
        const releaseTags = tags.filter((x) => new RegExp(`^v([0-9]+)\.([0-9]+)\.([0-9]+)$`).test(x));
        if (releaseTags && (0, semver_1.compare)(releaseTags[0], prereleaseTags[0]) === 1) {
            tags = releaseTags;
        }
        else {
            tags = prereleaseTags;
        }
    }
    tags = tags.filter((x) => x);
    // if a pre-release tag is used, then add it to the initial version
    let isFirstRelease = false;
    let latestTag;
    if (tags.length > 0) {
        latestTag = tags[0];
    }
    else {
        const initial = `${prefix}v${major ?? 0}.0.0`;
        latestTag = prerelease ? `${initial}-${prerelease}.0` : initial;
        isFirstRelease = true;
    }
    // remove tag prefix (if exists)
    let latestVersion = latestTag;
    if (prefix && latestVersion.startsWith(prefix)) {
        latestVersion = latestVersion.substr(prefix.length);
    }
    // remove "v" prefix (if exists)
    if (latestVersion.startsWith("v")) {
        latestVersion = latestVersion.substr(1);
    }
    return { latestVersion, latestTag, isFirstRelease };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVtcC12ZXJzaW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3JlbGVhc2UvYnVtcC12ZXJzaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLDJCQUFnRDtBQUNoRCwrQkFBcUM7QUFFckMsbUNBQWlDO0FBQ2pDLHNDQUFzQztBQUN0QyxrQ0FBNEM7QUF3RTVDOzs7Ozs7OztHQVFHO0FBQ0ksS0FBSyxVQUFVLElBQUksQ0FBQyxHQUFXLEVBQUUsT0FBb0I7SUFDMUQsTUFBTSxXQUFXLEdBQUcsSUFBQSxXQUFJLEVBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNuRCxNQUFNLFVBQVUsR0FBRyxPQUFPLENBQUMsVUFBVSxDQUFDO0lBQ3RDLE1BQU0sS0FBSyxHQUFHLE9BQU8sQ0FBQyxZQUFZLENBQUM7SUFDbkMsTUFBTSxlQUFlLEdBQUcsT0FBTyxDQUFDLGVBQWUsQ0FBQztJQUNoRCxNQUFNLE1BQU0sR0FBRyxPQUFPLENBQUMsU0FBUyxJQUFJLEVBQUUsQ0FBQztJQUN2QyxNQUFNLFFBQVEsR0FBRyxJQUFBLFdBQUksRUFBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDO0lBQzdDLE1BQU0sYUFBYSxHQUFHLElBQUEsV0FBSSxFQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDbkQsTUFBTSxjQUFjLEdBQUcsSUFBQSxXQUFJLEVBQUMsR0FBRyxFQUFFLE9BQU8sQ0FBQyxjQUFjLENBQUMsQ0FBQztJQUN6RCxJQUFJLEtBQUssSUFBSSxlQUFlLEVBQUU7UUFDNUIsTUFBTSxJQUFJLEtBQUssQ0FDYiwyREFBMkQsQ0FDNUQsQ0FBQztLQUNIO0lBRUQsTUFBTSxhQUFFLENBQUMsS0FBSyxDQUFDLElBQUEsY0FBTyxFQUFDLFFBQVEsQ0FBQyxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7SUFDdkQsTUFBTSxhQUFF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SyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBQzlDLFNBQVMsR0FBRyxVQUFVLENBQUMsQ0FBQyxDQUFDLEdBQUcsT0FBTyxJQUFJLFVBQVUsSUFBSSxDQUFDLENBQUMsQ0FBQyxPQUFPLENBQUM7UUFDaEUsY0FBYyxHQUFHLElBQUksQ0FBQztLQUN2QjtJQUVELGdDQUFnQztJQUNoQyxJQUFJLGFBQWEsR0FBRyxTQUFTLENBQUM7SUFDOUIsSUFBSSxNQUFNLElBQUksYUFBYSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUM5QyxhQUFhLEdBQUcsYUFBYSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDckQ7SUFFRCxnQ0FBZ0M7SUFDaEMsSUFBSSxhQUFhLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFFO1FBQ2pDLGFBQWEsR0FBRyxhQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3pDO0lBRUQsT0FBTyxFQUFFLGFBQWEsRUFBRSxTQUFTLEVBQUUsY0FBYyxFQUFFLENBQUM7QUFDdEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHByb21pc2VzIGFzIGZzLCBleGlzdHNTeW5jIH0gZnJvbSBcImZzXCI7XG5pbXBvcnQgeyBkaXJuYW1lLCBqb2luIH0gZnJvbSBcInBhdGhcIjtcbmltcG9ydCB7IENvbmZpZyB9IGZyb20gXCJjb252ZW50aW9uYWwtY2hhbmdlbG9nLWNvbmZpZy1zcGVjXCI7XG5pbXBvcnQgeyBjb21wYXJlIH0gZnJvbSBcInNlbXZlclwiO1xuaW1wb3J0ICogYXMgbG9nZ2luZyBmcm9tIFwiLi4vbG9nZ2luZ1wiO1xuaW1wb3J0IHsgZXhlYywgZXhlY0NhcHR1cmUgfSBmcm9tIFwiLi4vdXRpbFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIEJ1bXBPcHRpb25zIHtcbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIGEgLmpzb24gZmlsZSB0byBzZXQgYHZlcnNpb25gLlxuICAgKi9cbiAgcmVhZG9ubHkgdmVyc2lvbkZpbGU6IHN0cmluZztcblxuICAvKipcbiAgICogVGhlIG5hbWUgb2YgdGhlIGNoYW5nZWxvZyBmaWxlIHRvIGdlbmVyYXRlLlxuICAgKi9cbiAgcmVhZG9ubHkgY2hhbmdlbG9nOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFVzZSBhIHByZS1yZWxlYXNlIHN1ZmZpeC5cbiAgICogQGRlZmF1bHQgLSBub3JtYWwgdmVyc2lvbmluZ1xuICAgKi9cbiAgcmVhZG9ubHkgcHJlcmVsZWFzZT86IHN0cmluZztcblxuICAvKipcbiAgICogRGVmaW5lcyB0aGUgbWFqb3IgdmVyc2lvbiBsaW5lLiBUaGlzIGlzIHVzZWQgdG8gc2VsZWN0IHRoZSBsYXRlc3QgdmVyc2lvblxuICAgKiBhbmQgYWxzbyBlbmZvcmNlIHRoYXQgbmV3IG1ham9yIHZlcnNpb25zIGFyZSBub3QgcmVsZWFzZWQgYWNjaWRlbnRhbGx5LlxuICAgKlxuICAgKiBDYW4gbm90IGJlIHNldCB0b2dldGhlciB3aXRoIGBtaW5NYWpvclZlcnNpb25gLlxuICAgKlxuICAgKiBAZGVmYXVsdCAtIGFueSB2ZXJzaW9uIGlzIHN1cHBvcnRlZFxuICAgKi9cbiAgcmVhZG9ubHkgbWFqb3JWZXJzaW9uPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBEZWZpbmVzIHRoZSBtaW5pbWFsIG1ham9yIHZlcnNpb24uIFRoaXMgaXMgdXNlZCBpZiB5b3Ugd2FudCB0byBzdGFydCB3aXRoXG4gICAqIGEgc3BlY2lmaWMgbWFqb3IgdmVyc2lvbiwgYW5kIGluY3JlbWVudCBmcm9tIHRoZXJlIG9uLlxuICAgKiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gc2V0IHRvIDEsIGFzIGJyZWFraW5nIGNoYW5nZXMgYmVmb3JlIHRoZSAxLnggbWFqb3JcbiAgICogcmVsZWFzZSBhcmUgbm90IGluY3JlbWVudGluZyB0aGUgbWFqb3IgdmVyc2lvbiBudW1iZXIuXG4gICAqXG4gICAqIENhbiBub3QgYmUgc2V0IHRvZ2V0aGVyIHdpdGggYG1ham9yVmVyc2lvbmAuXG4gICAqXG4gICAqIEBkZWZhdWx0IC0gTm8gbWluaW11bSB2ZXJzaW9uIGlzIGJlaW5nIGVuZm9yY2VkXG4gICAqL1xuICByZWFkb25seSBtaW5NYWpvclZlcnNpb24/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIGEgZmlsZSB3aGljaCB3aWxsIGluY2x1ZGUgdGhlIG91dHB1dCB2ZXJzaW9uIG51bWJlciAoYSB0ZXh0IGZpbGUpLlxuICAgKlxuICAgKiBSZWxhdGl2ZSB0byBjd2QuXG4gICAqXG4gICAqIEBleGFtcGxlIFwiLnZlcnNpb24udHh0XCJcbiAgICovXG4gIHJlYWRvbmx5IGJ1bXBGaWxlOiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIFRoZSBuYW1lIG9mIHRoZSBmaWxlIHdoaWNoIHdpbGwgaW5jbHVkZSB0aGUgcmVsZWFzZSB0YWcgKGEgdGV4dCBmaWxlKS5cbiAgICpcbiAgICogUmVsYXRpdmUgdG8gY3dkLlxuICAgKlxuICAgKiBAZXhhbXBsZSBcIi5yZWxlYXNldGFnLnR4dFwiXG4gICAqL1xuICByZWFkb25seSByZWxlYXNlVGFnRmlsZTogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgcHJlZml4IGFwcGxpZWQgdG8gcmVsZWFzZSB0YWdzLiBCdW1wcyB3aWxsIGJlIG1hZGUgYmFzZWQgb24gdGhlIGxhdGVzdFxuICAgKiB2ZXJzaW9uIGZvdW5kIHdpdGggdGhpcyBwcmVmaXguXG4gICAqL1xuICByZWFkb25seSB0YWdQcmVmaXg/OiBzdHJpbmc7XG5cbiAgLyoqXG4gICAqIENvbmd1cmF0aW9uIHZhbHVlcyB0aGF0IHdvdWxkIGFwcGVuZCB0byB2ZXJzaW9ucmMgZmlsZSBvciBvdmVyd3JpdGUgdmFsdWVzXG4gICAqIGNvbWluZyB0byB0aGF0IGZyb20gZGVmYXVsdCBvbmUuXG4gICAqL1xuICByZWFkb25seSB2ZXJzaW9ucmNPcHRpb25zPzogQ29uZmlnO1xufVxuXG4vKipcbiAqIFJlc29sdmVzIHRoZSBsYXRlc3QgdmVyc2lvbiBmcm9tIGdpdCB0YWdzIGFuZCB1c2VzIGBzdGFuZGFyZC12ZXJzaW9uYCB0byBidW1wXG4gKiB0byB0aGUgbmV4dCB2ZXJzaW9uIGJhc2VkIG9uIGNvbW1pdHMuXG4gKlxuICogVGhpcyBleHBlY3RzIGBzdGFuZGFyZC12ZXJzaW9uYCB0byBiZSBpbnN0YWxsZWQgaW4gdGhlIHBhdGguXG4gKlxuICogQHBhcmFtIGN3ZCB3b3JraW5nIGRpcmVjdG9yeSAoZ2l0IHJlcG9zaXRvcnkpXG4gKiBAcGFyYW0gb3B0aW9ucyBvcHRpb25zXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBidW1wKGN3ZDogc3RyaW5nLCBvcHRpb25zOiBCdW1wT3B0aW9ucykge1xuICBjb25zdCB2ZXJzaW9uRmlsZSA9IGpvaW4oY3dkLCBvcHRpb25zLnZlcnNpb25GaWxlKTtcbiAgY29uc3QgcHJlcmVsZWFzZSA9IG9wdGlvbnMucHJlcmVsZWFzZTtcbiAgY29uc3QgbWFqb3IgPSBvcHRpb25zLm1ham9yVmVyc2lvbjtcbiAgY29uc3QgbWluTWFqb3JWZXJzaW9uID0gb3B0aW9ucy5taW5NYWpvclZlcnNpb247XG4gIGNvbnN0IHByZWZpeCA9IG9wdGlvbnMudGFnUHJlZml4ID8/IFwiXCI7XG4gIGNvbnN0IGJ1bXBGaWxlID0gam9pbihjd2QsIG9wdGlvbnMuYnVtcEZpbGUpO1xuICBjb25zdCBjaGFuZ2Vsb2dGaWxlID0gam9pbihjd2QsIG9wdGlvbnMuY2hhbmdlbG9nKTtcbiAgY29uc3QgcmVsZWFzZVRhZ0ZpbGUgPSBqb2luKGN3ZCwgb3B0aW9ucy5yZWxlYXNlVGFnRmlsZSk7XG4gIGlmIChtYWpvciAmJiBtaW5NYWpvclZlcnNpb24pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgbWluTWFqb3JWZXJzaW9uIGFuZCBtYWpvclZlcnNpb24gY2Fubm90IGJlIHVzZWQgdG9nZXRoZXIuYFxuICAgICk7XG4gIH1cblxuICBhd2FpdCBmcy5ta2RpcihkaXJuYW1lKGJ1bXBGaWxlKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gIGF3YWl0IGZzLm1rZGlyKGRpcm5hbWUoY2hhbmdlbG9nRmlsZSksIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICBhd2FpdCBmcy5ta2RpcihkaXJuYW1lKHJlbGVhc2VUYWdGaWxlKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG5cbiAgY29uc3QgeyBsYXRlc3RWZXJzaW9uLCBsYXRlc3RUYWcsIGlzRmlyc3RSZWxlYXNlIH0gPSBkZXRlcm1pbmVMYXRlc3RUYWcoe1xuICAgIGN3ZCxcbiAgICBtYWpvcixcbiAgICBwcmVyZWxlYXNlLFxuICAgIHByZWZpeCxcbiAgfSk7XG5cbiAgY29uc3QgY29udGVudCA9IGF3YWl0IHRyeVJlYWRWZXJzaW9uRmlsZSh2ZXJzaW9uRmlsZSk7XG5cbiAgLy8gdXBkYXRlIHZlcnNpb25cbiAgY29udGVudC52ZXJzaW9uID0gbGF0ZXN0VmVyc2lvbjtcblxuICBsb2dnaW5nLmluZm8oXG4gICAgYFVwZGF0ZSAke3ZlcnNpb25GaWxlfSB0byBsYXRlc3QgcmVzb2x2ZWQgdmVyc2lvbjogJHtsYXRlc3RWZXJzaW9ufWBcbiAgKTtcbiAgYXdhaXQgZnMud3JpdGVGaWxlKHZlcnNpb25GaWxlLCBKU09OLnN0cmluZ2lmeShjb250ZW50LCB1bmRlZmluZWQsIDIpKTtcblxuICAvLyBjaGVjayBpZiB0aGUgbGF0ZXN0IGNvbW1pdCBhbHJlYWR5IGhhcyBhIHZlcnNpb24gdGFnXG4gIGNvbnN0IGN1cnJlbnRUYWdzID0gZXhlY0NhcHR1cmUoXCJnaXQgdGFnIC0tcG9pbnRzLWF0IEhFQURcIiwgeyBjd2QgfSlcbiAgICAudG9TdHJpbmcoXCJ1dGY4XCIpXG4gICAgLnNwbGl0KFwiXFxuXCIpO1xuICBsb2dnaW5nLmluZm8oYFRhZ3MgbGlzdGVkIG9uIGN1cnJlbnQgY29tbWl0OiAke2N1cnJlbnRUYWdzfWApO1xuXG4gIGxldCBza2lwQnVtcCA9IGZhbHNlO1xuXG4gIGlmIChjdXJyZW50VGFncy5pbmNsdWRlcyhsYXRlc3RUYWcpKSB7XG4gICAgbG9nZ2luZy5pbmZvKFwiU2tpcHBpbmcgYnVtcC4uLlwiKTtcbiAgICBza2lwQnVtcCA9IHRydWU7XG5cbiAgICAvLyBkZWxldGUgdGhlIGV4aXN0aW5nIHRhZyAobG9jYWxseSlcbiAgICAvLyBpZiB3ZSBkb24ndCBkbyB0aGlzLCBzdGFuZGFyZC12ZXJzaW9uIGdlbmVyYXRlcyBhbiBlbXB0eSBjaGFuZ2Vsb2dcbiAgICBleGVjKGBnaXQgdGFnIC0tZGVsZXRlICR7bGF0ZXN0VGFnfWAsIHsgY3dkIH0pO1xuICB9XG5cbiAgLy8gY3JlYXRlIGEgc3RhbmRhcmQtdmVyc2lvbiBjb25maWd1cmF0aW9uIGZpbGVcbiAgY29uc3QgcmNmaWxlID0gam9pbihjd2QsIFwiLnZlcnNpb25yYy5qc29uXCIpO1xuICBhd2FpdCBnZW5lcmF0ZVZlcnNpb25yY0ZpbGUoXG4gICAgcmNmaWxlLFxuICAgIHZlcnNpb25GaWxlLFxuICAgIGNoYW5nZWxvZ0ZpbGUsXG4gICAgc2tpcEJ1bXAsXG4gICAgcHJlcmVsZWFzZSxcbiAgICBvcHRpb25zLnZlcnNpb25yY09wdGlvbnNcbiAgKTtcblxuICBjb25zdCBjbWQgPSBbXCJucHhcIiwgXCJzdGFuZGFyZC12ZXJzaW9uQF45XCJdO1xuICBpZiAoaXNGaXJzdFJlbGVhc2UpIHtcbiAgICBjbWQucHVzaChcIi0tZmlyc3QtcmVsZWFzZVwiKTtcbiAgfVxuICBpZiAocHJlZml4KSB7XG4gICAgY21kLnB1c2goYC0tdGFnLXByZWZpeCAke3ByZWZpeH12YCk7XG4gIH1cbiAgaWYgKG1pbk1ham9yVmVyc2lvbikge1xuICAgIGNvbnN0IFttYWpvclZlcnNpb25dID0gbGF0ZXN0VmVyc2lvbi5zcGxpdChcIi5cIik7XG4gICAgY29uc3QgbWFqb3JWZXJzaW9uTnVtYmVyID0gcGFyc2VJbnQobWFqb3JWZXJzaW9uLCAxMCk7XG4gICAgaWYgKG1ham9yVmVyc2lvbk51bWJlciA8IG1pbk1ham9yVmVyc2lvbikge1xuICAgICAgY21kLnB1c2goYC0tcmVsZWFzZS1hcyAke21pbk1ham9yVmVyc2lvbn0uMC4wYCk7XG4gICAgfVxuICB9XG5cbiAgZXhlYyhjbWQuam9pbihcIiBcIiksIHsgY3dkIH0pO1xuXG4gIC8vIGFkZCB0aGUgdGFnIGJhY2sgaWYgaXQgd2FzIHByZXZpb3VzbHkgcmVtb3ZlZFxuICBpZiAoY3VycmVudFRhZ3MuaW5jbHVkZXMobGF0ZXN0VGFnKSkge1xuICAgIGV4ZWMoYGdpdCB0YWcgJHtsYXRlc3RUYWd9YCwgeyBjd2QgfSk7XG4gIH1cblxuICBhd2FpdCBmcy5ybShyY2ZpbGUsIHsgZm9yY2U6IHRydWUsIHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcblxuICBjb25zdCBuZXdWZXJzaW9uID0gKGF3YWl0IHRyeVJlYWRWZXJzaW9uRmlsZSh2ZXJzaW9uRmlsZSkpLnZlcnNpb247XG4gIGlmICghbmV3VmVyc2lvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihgYnVtcCBmYWlsZWQ6ICR7dmVyc2lvbkZpbGV9IGRvZXMgbm90IGhhdmUgYSB2ZXJzaW9uIHNldGApO1xuICB9XG5cbiAgLy8gaWYgTUFKT1IgaXMgZGVmaW5lZCwgZW5zdXJlIHRoYXQgdGhlIG5ldyB2ZXJzaW9uIGlzIHdpdGhpbiB0aGUgc2FtZSBtYWpvciB2ZXJzaW9uXG4gIGlmIChtYWpvcikge1xuICAgIGlmICghbmV3VmVyc2lvbi5zdGFydHNXaXRoKGAke21ham9yfS5gKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgYnVtcCBmYWlsZWQ6IHRoaXMgYnJhbmNoIGlzIGNvbmZpZ3VyZWQgdG8gb25seSBwdWJsaXNoIHYke21ham9yfSByZWxlYXNlcyAtIGJ1bXAgcmVzdWx0ZWQgaW4gJHtuZXdWZXJzaW9ufWBcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgYXdhaXQgZnMud3JpdGVGaWxlKGJ1bXBGaWxlLCBuZXdWZXJzaW9uKTtcblxuICBjb25zdCBuZXdUYWcgPSBgJHtwcmVmaXh9diR7bmV3VmVyc2lvbn1gO1xuICBhd2FpdCBmcy53cml0ZUZpbGUocmVsZWFzZVRhZ0ZpbGUsIG5ld1RhZyk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHRyeVJlYWRWZXJzaW9uRmlsZSh2ZXJzaW9uRmlsZTogc3RyaW5nKSB7XG4gIGlmICghZXhpc3RzU3luYyh2ZXJzaW9uRmlsZSkpIHtcbiAgICByZXR1cm4ge307XG4gIH1cblxuICByZXR1cm4gSlNPTi5wYXJzZShhd2FpdCBmcy5yZWFkRmlsZSh2ZXJzaW9uRmlsZSwgXCJ1dGYtOFwiKSk7XG59XG5cbmludGVyZmFjZSBMYXRlc3RUYWdPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdvcmtpbmcgZGlyZWN0b3J5IG9mIHRoZSBnaXQgcmVwb3NpdG9yeS5cbiAgICovXG4gIHJlYWRvbmx5IGN3ZDogc3RyaW5nO1xuICAvKipcbiAgICogTWFqb3IgdmVyc2lvbiB0byBzZWxlY3QgZnJvbS5cbiAgICovXG4gIHJlYWRvbmx5IG1ham9yPzogbnVtYmVyO1xuICAvKipcbiAgICogQSBwcmUtcmVsZWFzZSBzdWZmaXguXG4gICAqL1xuICByZWFkb25seSBwcmVyZWxlYXNlPzogc3RyaW5nO1xuICAvKipcbiAgICogQSBwcmVmaXggYXBwbGllZCB0byBhbGwgdGFncy5cbiAgICovXG4gIHJlYWRvbmx5IHByZWZpeDogc3RyaW5nO1xufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVZlcnNpb25yY0ZpbGUoXG4gIHJjZmlsZTogc3RyaW5nLFxuICB2ZXJzaW9uRmlsZTogc3RyaW5nLFxuICBjaGFuZ2Vsb2dGaWxlOiBzdHJpbmcsXG4gIHNraXBCdW1wOiBib29sZWFuLFxuICBwcmVyZWxlYXNlPzogc3RyaW5nLFxuICBjb25maWdPcHRpb25zPzogQ29uZmlnXG4pIHtcbiAgcmV0dXJuIGZzLndyaXRlRmlsZShcbiAgICByY2ZpbGUsXG4gICAgSlNPTi5zdHJpbmdpZnkoXG4gICAgICB7XG4gICAgICAgIC4uLntcbiAgICAgICAgICBwYWNrYWdlRmlsZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IHZlcnNpb25GaWxlLFxuICAgICAgICAgICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBidW1wRmlsZXM6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgZmlsZW5hbWU6IHZlcnNpb25GaWxlLFxuICAgICAgICAgICAgICB0eXBlOiBcImpzb25cIixcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgXSxcbiAgICAgICAgICBjb21taXRBbGw6IGZhbHNlLFxuICAgICAgICAgIGluZmlsZTogY2hhbmdlbG9nRmlsZSxcbiAgICAgICAgICBwcmVyZWxlYXNlOiBwcmVyZWxlYXNlLFxuICAgICAgICAgIGhlYWRlcjogXCJcIixcbiAgICAgICAgICBza2lwOiB7XG4gICAgICAgICAgICBjb21taXQ6IHRydWUsXG4gICAgICAgICAgICB0YWc6IHRydWUsXG4gICAgICAgICAgICBidW1wOiBza2lwQnVtcCxcbiAgICAgICAgICB9LFxuICAgICAgICAgIC4uLmNvbmZpZ09wdGlvbnMsXG4gICAgICAgIH0sXG4gICAgICB9LFxuICAgICAgdW5kZWZpbmVkLFxuICAgICAgMlxuICAgIClcbiAgKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHRoZSBsYXRlc3QgcmVsZWFzZSB0YWcuXG4gKiBAcGFyYW0gbWFqb3IgKG9wdGlvbmFsKSBBIG1ham9yIHZlcnNpb24gbGluZSB0byBzZWxlY3QgZnJvbVxuICogQHBhcmFtIHByZXJlbGVhc2UgKG9wdGlvbmFsKSBBIHByZS1yZWxlYXNlIHN1ZmZpeC5cbiAqIEByZXR1cm5zIHRoZSBsYXRlc3QgdGFnLCBhbmQgd2hldGhlciBpdCBpcyB0aGUgZmlyc3QgcmVsZWFzZSBvciBub3RcbiAqL1xuZnVuY3Rpb24gZGV0ZXJtaW5lTGF0ZXN0VGFnKG9wdGlvbnM6IExhdGVzdFRhZ09wdGlvbnMpOiB7XG4gIGxhdGVzdFZlcnNpb246IHN0cmluZztcbiAgbGF0ZXN0VGFnOiBzdHJpbmc7XG4gIGlzRmlyc3RSZWxlYXNlOiBib29sZWFuO1xufSB7XG4gIGNvbnN0IHsgY3dkLCBtYWpvciwgcHJlcmVsZWFzZSwgcHJlZml4IH0gPSBvcHRpb25zO1xuXG4gIC8vIGZpbHRlciBvbmx5IHRhZ3MgZm9yIHRoaXMgcHJlZml4IGFuZCBtYWpvciB2ZXJzaW9uIGlmIHNwZWNpZmllZCAoc3RhcnQgd2l0aCBcInZOTi5cIikuXG4gIGNvbnN0IHByZWZpeEZpbHRlciA9XG4gICAgbWFqb3IgIT09IHVuZGVmaW5lZCA/IGAke3ByZWZpeH12JHttYWpvcn0uKmAgOiBgJHtwcmVmaXh9dipgO1xuXG4gIGNvbnN0IGxpc3RHaXRUYWdzID0gW1xuICAgIFwiZ2l0XCIsXG4gICAgJy1jIFwidmVyc2lvbnNvcnQuc3VmZml4PS1cIicsIC8vIG1ha2VzIHN1cmUgcHJlLXJlbGVhc2UgdmVyc2lvbnMgYXJlIGxpc3RlZCBhZnRlciB0aGUgcHJpbWFyeSB2ZXJzaW9uXG4gICAgXCJ0YWdcIixcbiAgICAnLS1zb3J0PVwiLXZlcnNpb246cmVmbmFtZVwiJywgLy8gc29ydCBhcyB2ZXJzaW9ucyBhbmQgbm90IGxleGljb2dyYXBoaWNhbGx5XG4gICAgXCItLWxpc3RcIixcbiAgICBgXCIke3ByZWZpeEZpbHRlcn1cImAsXG4gIF0uam9pbihcIiBcIik7XG5cbiAgY29uc3Qgc3Rkb3V0ID0gZXhlY0NhcHR1cmUobGlzdEdpdFRhZ3MsIHsgY3dkIH0pLnRvU3RyaW5nKFwidXRmOFwiKTtcblxuICBsZXQgdGFncyA9IHN0ZG91dD8uc3BsaXQoXCJcXG5cIik7XG5cbiAgLy8gaWYgcHJlcmVsZWFzZSBpcyBzZXQgYW5kIHRoZXJlIGFyZSBleGlzdGluZyBwcmVyZWxlYXNlIHRhZ3MsIGZpbHRlciB2ZXJzaW9ucyB0aGF0IGVuZCB3aXRoIFwiLVBSRS5kZGRcIi5cbiAgY29uc3QgcHJlcmVsZWFzZVRhZ3MgPSB0YWdzLmZpbHRlcigoeCkgPT5cbiAgICBuZXcgUmVnRXhwKGAtJHtwcmVyZWxlYXNlfVxcLlswLTldKyRgKS50ZXN0KHgpXG4gICk7XG4gIGlmIChwcmVyZWxlYXNlICYmIHByZXJlbGVhc2VUYWdzLmxlbmd0aCA+IDApIHtcbiAgICAvKipcbiAgICAgKiBDb3ZlciB0aGUgZm9sbG93aW5nIGNhc2Ugc3BlY2lmaWNhbGx5XG4gICAgICogMSAtIHYxLjAuMFxuICAgICAqIDIgLSB2MS4wLjEtYmV0YS4wXG4gICAgICogMyAtIHYxLjAuMS1iZXRhLjFcbiAgICAgKiA0IC0gdjEuMC4xXG4gICAgICogNSAtIG5vdyBwdWJsaXNoIGEgbmV3IHJlbGVhc2Ugb24gdGhlIHByZXJlbGVhc2UgYnJhbmNoXG4gICAgICogICAgYnkgc2V0dGluZyB0aGUgbGF0ZXN0VGFnIGFzIHYxLjAuMSBpbnN0ZWFkIG9mIHYxLjAuMS1iZXRhLjFcbiAgICAgKi9cbiAgICBjb25zdCByZWxlYXNlVGFncyA9IHRhZ3MuZmlsdGVyKCh4KSA9PlxuICAgICAgbmV3IFJlZ0V4cChgXnYoWzAtOV0rKVxcLihbMC05XSspXFwuKFswLTldKykkYCkudGVzdCh4KVxuICAgICk7XG4gICAgaWYgKHJlbGVhc2VUYWdzICYmIGNvbXBhcmUocmVsZWFzZVRhZ3NbMF0sIHByZXJlbGVhc2VUYWdzWzBdKSA9PT0gMSkge1xuICAgICAgdGFncyA9IHJlbGVhc2VUYWdzO1xuICAgIH0gZWxzZSB7XG4gICAgICB0YWdzID0gcHJlcmVsZWFzZVRhZ3M7XG4gICAgfVxuICB9XG5cbiAgdGFncyA9IHRhZ3MuZmlsdGVyKCh4KSA9PiB4KTtcblxuICAvLyBpZiBhIHByZS1yZWxlYXNlIHRhZyBpcyB1c2VkLCB0aGVuIGFkZCBpdCB0byB0aGUgaW5pdGlhbCB2ZXJzaW9uXG4gIGxldCBpc0ZpcnN0UmVsZWFzZSA9IGZhbHNlO1xuICBsZXQgbGF0ZXN0VGFnO1xuXG4gIGlmICh0YWdzLmxlbmd0aCA+IDApIHtcbiAgICBsYXRlc3RUYWcgPSB0YWdzWzBdO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGluaXRpYWwgPSBgJHtwcmVmaXh9diR7bWFqb3IgPz8gMH0uMC4wYDtcbiAgICBsYXRlc3RUYWcgPSBwcmVyZWxlYXNlID8gYCR7aW5pdGlhbH0tJHtwcmVyZWxlYXNlfS4wYCA6IGluaXRpYWw7XG4gICAgaXNGaXJzdFJlbGVhc2UgPSB0cnVlO1xuICB9XG5cbiAgLy8gcmVtb3ZlIHRhZyBwcmVmaXggKGlmIGV4aXN0cylcbiAgbGV0IGxhdGVzdFZlcnNpb24gPSBsYXRlc3RUYWc7XG4gIGlmIChwcmVmaXggJiYgbGF0ZXN0VmVyc2lvbi5zdGFydHNXaXRoKHByZWZpeCkpIHtcbiAgICBsYXRlc3RWZXJzaW9uID0gbGF0ZXN0VmVyc2lvbi5zdWJzdHIocHJlZml4Lmxlbmd0aCk7XG4gIH1cblxuICAvLyByZW1vdmUgXCJ2XCIgcHJlZml4IChpZiBleGlzdHMpXG4gIGlmIChsYXRlc3RWZXJzaW9uLnN0YXJ0c1dpdGgoXCJ2XCIpKSB7XG4gICAgbGF0ZXN0VmVyc2lvbiA9IGxhdGVzdFZlcnNpb24uc3Vic3RyKDEpO1xuICB9XG5cbiAgcmV0dXJuIHsgbGF0ZXN0VmVyc2lvbiwgbGF0ZXN0VGFnLCBpc0ZpcnN0UmVsZWFzZSB9O1xufVxuIl19