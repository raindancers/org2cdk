"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderDockerComposeFile = void 0;
const util_1 = require("../util");
function renderDockerComposeFile(serviceDescriptions, version) {
    // Record volume configuration
    const volumeConfig = {};
    const volumeInfo = {
        addVolumeConfiguration(volumeName, configuration) {
            if (!volumeConfig[volumeName]) {
                // First volume configuration takes precedence.
                volumeConfig[volumeName] = configuration;
            }
        },
    };
    // Record network configuration
    const networkConfig = {};
    const networkInfo = {
        addNetworkConfiguration(networkName, configuration) {
            if (!networkConfig[networkName]) {
                // First network configuration takes precedence.
                networkConfig[networkName] = configuration;
            }
        },
    };
    // Render service configuration
    const services = {};
    for (const [serviceName, serviceDescription] of Object.entries(serviceDescriptions ?? {})) {
        // Resolve the names of each dependency and check that they exist.
        // Note: They may not exist if the user made a mistake when referencing a
        // service by name via `DockerCompose.serviceName()`.
        // @see DockerCompose.serviceName
        const dependsOn = Array();
        for (const dependsOnServiceName of serviceDescription.dependsOn ?? []) {
            const resolvedServiceName = dependsOnServiceName.serviceName;
            if (resolvedServiceName === serviceName) {
                throw new Error(`Service ${serviceName} cannot depend on itself`);
            }
            if (!serviceDescriptions[resolvedServiceName]) {
                throw new Error(`Unable to resolve service named ${resolvedServiceName} for ${serviceName}`);
            }
            dependsOn.push(resolvedServiceName);
        }
        // Give each volume binding a chance to bind any necessary volume
        // configuration and provide volume mount information for the service.
        const volumes = [];
        for (const volumeBinding of serviceDescription.volumes ?? []) {
            volumes.push(volumeBinding.bind(volumeInfo));
        }
        // Give each network binding a chance to bind any necessary network
        // configuration and provide network mount information for the service.
        const networks = [];
        for (const networkBinding of serviceDescription.networks ?? []) {
            networks.push(networkBinding.bind(networkInfo));
        }
        // Create and store the service configuration, taking care not to create
        // object members with undefined values.
        services[serviceName] = {
            ...getObjectWithKeyAndValueIfValueIsDefined("image", serviceDescription.image),
            ...getObjectWithKeyAndValueIfValueIsDefined("build", serviceDescription.imageBuild),
            ...getObjectWithKeyAndValueIfValueIsDefined("entrypoint", serviceDescription.entrypoint),
            ...getObjectWithKeyAndValueIfValueIsDefined("command", serviceDescription.command),
            ...(Object.keys(serviceDescription.environment).length > 0
                ? { environment: serviceDescription.environment }
                : {}),
            ...(serviceDescription.ports.length > 0
                ? { ports: serviceDescription.ports }
                : {}),
            ...(Object.keys(serviceDescription.labels).length > 0
                ? { labels: serviceDescription.labels }
                : {}),
            ...(dependsOn.length > 0 ? { dependsOn } : {}),
            ...(volumes.length > 0 ? { volumes } : {}),
            ...(networks.length > 0 ? { networks } : {}),
        };
    }
    // Explicit with the type here because the decamelize step after this wipes
    // out types.
    const input = {
        version,
        services,
        ...(Object.keys(volumeConfig).length > 0 ? { volumes: volumeConfig } : {}),
        ...(Object.keys(networkConfig).length > 0
            ? { networks: networkConfig }
            : {}),
    };
    // Change most keys to snake case.
    return (0, util_1.decamelizeKeysRecursively)(input, {
        shouldDecamelize: shouldDecamelizeDockerComposeKey,
        separator: "_",
    });
}
exports.renderDockerComposeFile = renderDockerComposeFile;
/**
 * Returns `{ [key]: value }` if `value` is defined, otherwise returns `{}` so
 * that object spreading can be used to generate a peculiar interface.
 * @param key
 * @param value
 */
function getObjectWithKeyAndValueIfValueIsDefined(key, value) {
    return value !== undefined ? { [key]: value } : {};
}
/**
 * Determines whether the key at the given path should be decamelized.
 * Largely, all keys should be snake cased. But, there are some
 * exceptions for user-provided names for services, volumes, and
 * environment variables.
 *
 * @param path
 */
function shouldDecamelizeDockerComposeKey(path) {
    const poundPath = path.join("#");
    // Does not decamelize user's names.
    // services.namehere:
    // volumes.namehere:
    // networks.namehere:
    if (/^(services|volumes|networks)#[^#]+$/.test(poundPath)) {
        return false;
    }
    // Does not decamelize environment variables and labels
    // services.namehere.environment.*
    // services.namehere.labels.*
    if (/^services#[^#]+#(environment|labels)#/.test(poundPath)) {
        return false;
    }
    // Does not decamelize build arguments
    // services.namehere.build.args.*
    if (/^services#[^#]+#build#args#/.test(poundPath)) {
        return false;
    }
    // Otherwise, let it all decamelize.
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZG9ja2VyLWNvbXBvc2UtcmVuZGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2RvY2tlci1jb21wb3NlL2RvY2tlci1jb21wb3NlLXJlbmRlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7QUFZQSxrQ0FBb0Q7QUE2QnBELFNBQWdCLHVCQUF1QixDQUNyQyxtQkFBeUQsRUFDekQsT0FBZTtJQUVmLDhCQUE4QjtJQUM5QixNQUFNLFlBQVksR0FBOEMsRUFBRSxDQUFDO0lBQ25FLE1BQU0sVUFBVSxHQUErQjtRQUM3QyxzQkFBc0IsQ0FDcEIsVUFBa0IsRUFDbEIsYUFBd0M7WUFFeEMsSUFBSSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsRUFBRTtnQkFDN0IsK0NBQStDO2dCQUMvQyxZQUFZLENBQUMsVUFBVSxDQUFDLEdBQUcsYUFBYSxDQUFDO2FBQzFDO1FBQ0gsQ0FBQztLQUNGLENBQUM7SUFDRiwrQkFBK0I7SUFDL0IsTUFBTSxhQUFhLEdBQStDLEVBQUUsQ0FBQztJQUNyRSxNQUFNLFdBQVcsR0FBZ0M7UUFDL0MsdUJBQXVCLENBQ3JCLFdBQW1CLEVBQ25CLGFBQXlDO1lBRXpDLElBQUksQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLEVBQUU7Z0JBQy9CLGdEQUFnRDtnQkFDaEQsYUFBYSxDQUFDLFdBQVcsQ0FBQyxHQUFHLGFBQWEsQ0FBQzthQUM1QztRQUNILENBQUM7S0FDRixDQUFDO0lBRUYsK0JBQStCO0lBQy9CLE1BQU0sUUFBUSxHQUFtRCxFQUFFLENBQUM7SUFDcEUsS0FBSyxNQUFNLENBQUMsV0FBVyxFQUFFLGtCQUFrQixDQUFDLElBQUksTUFBTSxDQUFDLE9BQU8sQ0FDNUQsbUJBQW1CLElBQUksRUFBRSxDQUMxQixFQUFFO1FBQ0Qsa0VBQWtFO1FBQ2xFLHlFQUF5RTtRQUN6RSxxREFBcUQ7UUFDckQsaUNBQWlDO1FBQ2pDLE1BQU0sU0FBUyxHQUFHLEtBQUssRUFBVSxDQUFDO1FBQ2xDLEtBQUss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QUU7UUFDM0QsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELHNDQUFzQztJQUN0QyxpQ0FBaUM7SUFDakMsSUFBSSw2QkFBNkIsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUU7UUFDakQsT0FBTyxLQUFLLENBQUM7S0FDZDtJQUVELG9DQUFvQztJQUNwQyxPQUFPLElBQUksQ0FBQztBQUNkLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBEb2NrZXJDb21wb3NlQnVpbGQgfSBmcm9tIFwiLi9kb2NrZXItY29tcG9zZVwiO1xuaW1wb3J0IHtcbiAgRG9ja2VyQ29tcG9zZU5ldHdvcmtDb25maWcsXG4gIElEb2NrZXJDb21wb3NlTmV0d29ya0NvbmZpZyxcbn0gZnJvbSBcIi4vZG9ja2VyLWNvbXBvc2UtbmV0d29ya1wiO1xuaW1wb3J0IHsgRG9ja2VyQ29tcG9zZVNlcnZpY2VQb3J0IH0gZnJvbSBcIi4vZG9ja2VyLWNvbXBvc2UtcG9ydFwiO1xuaW1wb3J0IHsgRG9ja2VyQ29tcG9zZVNlcnZpY2UgfSBmcm9tIFwiLi9kb2NrZXItY29tcG9zZS1zZXJ2aWNlXCI7XG5pbXBvcnQge1xuICBEb2NrZXJDb21wb3NlVm9sdW1lQ29uZmlnLFxuICBEb2NrZXJDb21wb3NlVm9sdW1lTW91bnQsXG4gIElEb2NrZXJDb21wb3NlVm9sdW1lQ29uZmlnLFxufSBmcm9tIFwiLi9kb2NrZXItY29tcG9zZS12b2x1bWVcIjtcbmltcG9ydCB7IGRlY2FtZWxpemVLZXlzUmVjdXJzaXZlbHkgfSBmcm9tIFwiLi4vdXRpbFwiO1xuXG4vKipcbiAqIFN0cnVjdHVyZSBvZiBhIGRvY2tlciBjb21wb3NlIGZpbGUncyBzZXJ2aWNlIGJlZm9yZSB3ZSBkZWNhbWVsaXplLlxuICogQGludGVybmFsXG4gKi9cbmludGVyZmFjZSBEb2NrZXJDb21wb3NlRmlsZVNlcnZpY2VTY2hlbWEge1xuICByZWFkb25seSBkZXBlbmRzT24/OiBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgYnVpbGQ/OiBEb2NrZXJDb21wb3NlQnVpbGQ7XG4gIHJlYWRvbmx5IGltYWdlPzogc3RyaW5nO1xuICByZWFkb25seSBjb21tYW5kPzogc3RyaW5nW107XG4gIHJlYWRvbmx5IHZvbHVtZXM/OiBEb2NrZXJDb21wb3NlVm9sdW1lTW91bnRbXTtcbiAgcmVhZG9ubHkgbmV0d29ya3M/OiBzdHJpbmdbXTtcbiAgcmVhZG9ubHkgcG9ydHM/OiBEb2NrZXJDb21wb3NlU2VydmljZVBvcnRbXTtcbiAgcmVhZG9ubHkgZW52aXJvbm1lbnQ/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICByZWFkb25seSBsYWJlbHM/OiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+O1xuICByZWFkb25seSBlbnRyeXBvaW50Pzogc3RyaW5nW107XG59XG5cbi8qKlxuICogU3RydWN0dXJlIG9mIGEgZG9ja2VyIGNvbXBvc2UgZmlsZSBiZWZvcmUgd2UgZGVjYW1lbGl6ZS5cbiAqIEBpbnRlcm5hbFxuICovXG5pbnRlcmZhY2UgRG9ja2VyQ29tcG9zZUZpbGVTY2hlbWEge1xuICB2ZXJzaW9uOiBzdHJpbmc7XG4gIHNlcnZpY2VzOiBSZWNvcmQ8c3RyaW5nLCBEb2NrZXJDb21wb3NlRmlsZVNlcnZpY2VTY2hlbWE+O1xuICB2b2x1bWVzPzogUmVjb3JkPHN0cmluZywgRG9ja2VyQ29tcG9zZVZvbHVtZUNvbmZpZz47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJEb2NrZXJDb21wb3NlRmlsZShcbiAgc2VydmljZURlc2NyaXB0aW9uczogUmVjb3JkPHN0cmluZywgRG9ja2VyQ29tcG9zZVNlcnZpY2U+LFxuICB2ZXJzaW9uOiBzdHJpbmdcbik6IG9iamVjdCB7XG4gIC8vIFJlY29yZCB2b2x1bWUgY29uZmlndXJhdGlvblxuICBjb25zdCB2b2x1bWVDb25maWc6IFJlY29yZDxzdHJpbmcsIERvY2tlckNvbXBvc2VWb2x1bWVDb25maWc+ID0ge307XG4gIGNvbnN0IHZvbHVtZUluZm86IElEb2NrZXJDb21wb3NlVm9sdW1lQ29uZmlnID0ge1xuICAgIGFkZFZvbHVtZUNvbmZpZ3VyYXRpb24oXG4gICAgICB2b2x1bWVOYW1lOiBzdHJpbmcsXG4gICAgICBjb25maWd1cmF0aW9uOiBEb2NrZXJDb21wb3NlVm9sdW1lQ29uZmlnXG4gICAgKSB7XG4gICAgICBpZiAoIXZvbHVtZUNvbmZpZ1t2b2x1bWVOYW1lXSkge1xuICAgICAgICAvLyBGaXJzdCB2b2x1bWUgY29uZmlndXJhdGlvbiB0YWtlcyBwcmVjZWRlbmNlLlxuICAgICAgICB2b2x1bWVDb25maWdbdm9sdW1lTmFtZV0gPSBjb25maWd1cmF0aW9uO1xuICAgICAgfVxuICAgIH0sXG4gIH07XG4gIC8vIFJlY29yZCBuZXR3b3JrIGNvbmZpZ3VyYXRpb25cbiAgY29uc3QgbmV0d29ya0NvbmZpZzogUmVjb3JkPHN0cmluZywgRG9ja2VyQ29tcG9zZU5ldHdvcmtDb25maWc+ID0ge307XG4gIGNvbnN0IG5ldHdvcmtJbmZvOiBJRG9ja2VyQ29tcG9zZU5ldHdvcmtDb25maWcgPSB7XG4gICAgYWRkTmV0d29ya0NvbmZpZ3VyYXRpb24oXG4gICAgICBuZXR3b3JrTmFtZTogc3RyaW5nLFxuICAgICAgY29uZmlndXJhdGlvbjogRG9ja2VyQ29tcG9zZU5ldHdvcmtDb25maWdcbiAgICApIHtcbiAgICAgIGlmICghbmV0d29ya0NvbmZpZ1tuZXR3b3JrTmFtZV0pIHtcbiAgICAgICAgLy8gRmlyc3QgbmV0d29yayBjb25maWd1cmF0aW9uIHRha2VzIHByZWNlZGVuY2UuXG4gICAgICAgIG5ldHdvcmtDb25maWdbbmV0d29ya05hbWVdID0gY29uZmlndXJhdGlvbjtcbiAgICAgIH1cbiAgICB9LFxuICB9O1xuXG4gIC8vIFJlbmRlciBzZXJ2aWNlIGNvbmZpZ3VyYXRpb25cbiAgY29uc3Qgc2VydmljZXM6IFJlY29yZDxzdHJpbmcsIERvY2tlckNvbXBvc2VGaWxlU2VydmljZVNjaGVtYT4gPSB7fTtcbiAgZm9yIChjb25zdCBbc2VydmljZU5hbWUsIHNlcnZpY2VEZXNjcmlwdGlvbl0gb2YgT2JqZWN0LmVudHJpZXMoXG4gICAgc2VydmljZURlc2NyaXB0aW9ucyA/PyB7fVxuICApKSB7XG4gICAgLy8gUmVzb2x2ZSB0aGUgbmFtZXMgb2YgZWFjaCBkZXBlbmRlbmN5IGFuZCBjaGVjayB0aGF0IHRoZXkgZXhpc3QuXG4gICAgLy8gTm90ZTogVGhleSBtYXkgbm90IGV4aXN0IGlmIHRoZSB1c2VyIG1hZGUgYSBtaXN0YWtlIHdoZW4gcmVmZXJlbmNpbmcgYVxuICAgIC8vIHNlcnZpY2UgYnkgbmFtZSB2aWEgYERvY2tlckNvbXBvc2Uuc2VydmljZU5hbWUoKWAuXG4gICAgLy8gQHNlZSBEb2NrZXJDb21wb3NlLnNlcnZpY2VOYW1lXG4gICAgY29uc3QgZGVwZW5kc09uID0gQXJyYXk8c3RyaW5nPigpO1xuICAgIGZvciAoY29uc3QgZGVwZW5kc09uU2VydmljZU5hbWUgb2Ygc2VydmljZURlc2NyaXB0aW9uLmRlcGVuZHNPbiA/PyBbXSkge1xuICAgICAgY29uc3QgcmVzb2x2ZWRTZXJ2aWNlTmFtZSA9IGRlcGVuZHNPblNlcnZpY2VOYW1lLnNlcnZpY2VOYW1lO1xuICAgICAgaWYgKHJlc29sdmVkU2VydmljZU5hbWUgPT09IHNlcnZpY2VOYW1lKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgU2VydmljZSAke3NlcnZpY2VOYW1lfSBjYW5ub3QgZGVwZW5kIG9uIGl0c2VsZmApO1xuICAgICAgfVxuICAgICAgaWYgKCFzZXJ2aWNlRGVzY3JpcHRpb25zW3Jlc29sdmVkU2VydmljZU5hbWVdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVW5hYmxlIHRvIHJlc29sdmUgc2VydmljZSBuYW1lZCAke3Jlc29sdmVkU2VydmljZU5hbWV9IGZvciAke3NlcnZpY2VOYW1lfWBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgZGVwZW5kc09uLnB1c2gocmVzb2x2ZWRTZXJ2aWNlTmFtZSk7XG4gICAgfVxuXG4gICAgLy8gR2l2ZSBlYWNoIHZvbHVtZSBiaW5kaW5nIGEgY2hhbmNlIHRvIGJpbmQgYW55IG5lY2Vzc2FyeSB2b2x1bWVcbiAgICAvLyBjb25maWd1cmF0aW9uIGFuZCBwcm92aWRlIHZvbHVtZSBtb3VudCBpbmZvcm1hdGlvbiBmb3IgdGhlIHNlcnZpY2UuXG4gICAgY29uc3Qgdm9sdW1lczogRG9ja2VyQ29tcG9zZVZvbHVtZU1vdW50W10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHZvbHVtZUJpbmRpbmcgb2Ygc2VydmljZURlc2NyaXB0aW9uLnZvbHVtZXMgPz8gW10pIHtcbiAgICAgIHZvbHVtZXMucHVzaCh2b2x1bWVCaW5kaW5nLmJpbmQodm9sdW1lSW5mbykpO1xuICAgIH1cblxuICAgIC8vIEdpdmUgZWFjaCBuZXR3b3JrIGJpbmRpbmcgYSBjaGFuY2UgdG8gYmluZCBhbnkgbmVjZXNzYXJ5IG5ldHdvcmtcbiAgICAvLyBjb25maWd1cmF0aW9uIGFuZCBwcm92aWRlIG5ldHdvcmsgbW91bnQgaW5mb3JtYXRpb24gZm9yIHRoZSBzZXJ2aWNlLlxuICAgIGNvbnN0IG5ldHdvcmtzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgbmV0d29ya0JpbmRpbmcgb2Ygc2VydmljZURlc2NyaXB0aW9uLm5ldHdvcmtzID8/IFtdKSB7XG4gICAgICBuZXR3b3Jrcy5wdXNoKG5ldHdvcmtCaW5kaW5nLmJpbmQobmV0d29ya0luZm8pKTtcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYW5kIHN0b3JlIHRoZSBzZXJ2aWNlIGNvbmZpZ3VyYXRpb24sIHRha2luZyBjYXJlIG5vdCB0byBjcmVhdGVcbiAgICAvLyBvYmplY3QgbWVtYmVycyB3aXRoIHVuZGVmaW5lZCB2YWx1ZXMuXG4gICAgc2VydmljZXNbc2VydmljZU5hbWVdID0ge1xuICAgICAgLi4uZ2V0T2JqZWN0V2l0aEtleUFuZFZhbHVlSWZWYWx1ZUlzRGVmaW5lZChcbiAgICAgICAgXCJpbWFnZVwiLFxuICAgICAgICBzZXJ2aWNlRGVzY3JpcHRpb24uaW1hZ2VcbiAgICAgICksXG4gICAgICAuLi5nZXRPYmplY3RXaXRoS2V5QW5kVmFsdWVJZlZhbHVlSXNEZWZpbmVkKFxuICAgICAgICBcImJ1aWxkXCIsXG4gICAgICAgIHNlcnZpY2VEZXNjcmlwdGlvbi5pbWFnZUJ1aWxkXG4gICAgICApLFxuICAgICAgLi4uZ2V0T2JqZWN0V2l0aEtleUFuZFZhbHVlSWZWYWx1ZUlzRGVmaW5lZChcbiAgICAgICAgXCJlbnRyeXBvaW50XCIsXG4gICAgICAgIHNlcnZpY2VEZXNjcmlwdGlvbi5lbnRyeXBvaW50XG4gICAgICApLFxuICAgICAgLi4uZ2V0T2JqZWN0V2l0aEtleUFuZFZhbHVlSWZWYWx1ZUlzRGVmaW5lZChcbiAgICAgICAgXCJjb21tYW5kXCIsXG4gICAgICAgIHNlcnZpY2VEZXNjcmlwdGlvbi5jb21tYW5kXG4gICAgICApLFxuICAgICAgLi4uKE9iamVjdC5rZXlzKHNlcnZpY2VEZXNjcmlwdGlvbi5lbnZpcm9ubWVudCkubGVuZ3RoID4gMFxuICAgICAgICA/IHsgZW52aXJvbm1lbnQ6IHNlcnZpY2VEZXNjcmlwdGlvbi5lbnZpcm9ubWVudCB9XG4gICAgICAgIDoge30pLFxuICAgICAgLi4uKHNlcnZpY2VEZXNjcmlwdGlvbi5wb3J0cy5sZW5ndGggPiAwXG4gICAgICAgID8geyBwb3J0czogc2VydmljZURlc2NyaXB0aW9uLnBvcnRzIH1cbiAgICAgICAgOiB7fSksXG4gICAgICAuLi4oT2JqZWN0LmtleXMoc2VydmljZURlc2NyaXB0aW9uLmxhYmVscykubGVuZ3RoID4gMFxuICAgICAgICA/IHsgbGFiZWxzOiBzZXJ2aWNlRGVzY3JpcHRpb24ubGFiZWxzIH1cbiAgICAgICAgOiB7fSksXG4gICAgICAuLi4oZGVwZW5kc09uLmxlbmd0aCA+IDAgPyB7IGRlcGVuZHNPbiB9IDoge30pLFxuICAgICAgLi4uKHZvbHVtZXMubGVuZ3RoID4gMCA/IHsgdm9sdW1lcyB9IDoge30pLFxuICAgICAgLi4uKG5ldHdvcmtzLmxlbmd0aCA+IDAgPyB7IG5ldHdvcmtzIH0gOiB7fSksXG4gICAgfTtcbiAgfVxuXG4gIC8vIEV4cGxpY2l0IHdpdGggdGhlIHR5cGUgaGVyZSBiZWNhdXNlIHRoZSBkZWNhbWVsaXplIHN0ZXAgYWZ0ZXIgdGhpcyB3aXBlc1xuICAvLyBvdXQgdHlwZXMuXG4gIGNvbnN0IGlucHV0OiBEb2NrZXJDb21wb3NlRmlsZVNjaGVtYSA9IHtcbiAgICB2ZXJzaW9uLFxuICAgIHNlcnZpY2VzLFxuICAgIC4uLihPYmplY3Qua2V5cyh2b2x1bWVDb25maWcpLmxlbmd0aCA+IDAgPyB7IHZvbHVtZXM6IHZvbHVtZUNvbmZpZyB9IDoge30pLFxuICAgIC4uLihPYmplY3Qua2V5cyhuZXR3b3JrQ29uZmlnKS5sZW5ndGggPiAwXG4gICAgICA/IHsgbmV0d29ya3M6IG5ldHdvcmtDb25maWcgfVxuICAgICAgOiB7fSksXG4gIH07XG5cbiAgLy8gQ2hhbmdlIG1vc3Qga2V5cyB0byBzbmFrZSBjYXNlLlxuICByZXR1cm4gZGVjYW1lbGl6ZUtleXNSZWN1cnNpdmVseShpbnB1dCwge1xuICAgIHNob3VsZERlY2FtZWxpemU6IHNob3VsZERlY2FtZWxpemVEb2NrZXJDb21wb3NlS2V5LFxuICAgIHNlcGFyYXRvcjogXCJfXCIsXG4gIH0pO1xufVxuXG4vKipcbiAqIFJldHVybnMgYHsgW2tleV06IHZhbHVlIH1gIGlmIGB2YWx1ZWAgaXMgZGVmaW5lZCwgb3RoZXJ3aXNlIHJldHVybnMgYHt9YCBzb1xuICogdGhhdCBvYmplY3Qgc3ByZWFkaW5nIGNhbiBiZSB1c2VkIHRvIGdlbmVyYXRlIGEgcGVjdWxpYXIgaW50ZXJmYWNlLlxuICogQHBhcmFtIGtleVxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIGdldE9iamVjdFdpdGhLZXlBbmRWYWx1ZUlmVmFsdWVJc0RlZmluZWQ8SyBleHRlbmRzIHN0cmluZywgVD4oXG4gIGtleTogSyxcbiAgdmFsdWU6IFRcbik6IHsgSzogVCB9IHwge30ge1xuICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/IHsgW2tleV06IHZhbHVlIH0gOiB7fTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIGtleSBhdCB0aGUgZ2l2ZW4gcGF0aCBzaG91bGQgYmUgZGVjYW1lbGl6ZWQuXG4gKiBMYXJnZWx5LCBhbGwga2V5cyBzaG91bGQgYmUgc25ha2UgY2FzZWQuIEJ1dCwgdGhlcmUgYXJlIHNvbWVcbiAqIGV4Y2VwdGlvbnMgZm9yIHVzZXItcHJvdmlkZWQgbmFtZXMgZm9yIHNlcnZpY2VzLCB2b2x1bWVzLCBhbmRcbiAqIGVudmlyb25tZW50IHZhcmlhYmxlcy5cbiAqXG4gKiBAcGFyYW0gcGF0aFxuICovXG5mdW5jdGlvbiBzaG91bGREZWNhbWVsaXplRG9ja2VyQ29tcG9zZUtleShwYXRoOiBzdHJpbmdbXSkge1xuICBjb25zdCBwb3VuZFBhdGggPSBwYXRoLmpvaW4oXCIjXCIpO1xuXG4gIC8vIERvZXMgbm90IGRlY2FtZWxpemUgdXNlcidzIG5hbWVzLlxuICAvLyBzZXJ2aWNlcy5uYW1laGVyZTpcbiAgLy8gdm9sdW1lcy5uYW1laGVyZTpcbiAgLy8gbmV0d29ya3MubmFtZWhlcmU6XG4gIGlmICgvXihzZXJ2aWNlc3x2b2x1bWVzfG5ldHdvcmtzKSNbXiNdKyQvLnRlc3QocG91bmRQYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIERvZXMgbm90IGRlY2FtZWxpemUgZW52aXJvbm1lbnQgdmFyaWFibGVzIGFuZCBsYWJlbHNcbiAgLy8gc2VydmljZXMubmFtZWhlcmUuZW52aXJvbm1lbnQuKlxuICAvLyBzZXJ2aWNlcy5uYW1laGVyZS5sYWJlbHMuKlxuICBpZiAoL15zZXJ2aWNlcyNbXiNdKyMoZW52aXJvbm1lbnR8bGFiZWxzKSMvLnRlc3QocG91bmRQYXRoKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIC8vIERvZXMgbm90IGRlY2FtZWxpemUgYnVpbGQgYXJndW1lbnRzXG4gIC8vIHNlcnZpY2VzLm5hbWVoZXJlLmJ1aWxkLmFyZ3MuKlxuICBpZiAoL15zZXJ2aWNlcyNbXiNdKyNidWlsZCNhcmdzIy8udGVzdChwb3VuZFBhdGgpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gT3RoZXJ3aXNlLCBsZXQgaXQgYWxsIGRlY2FtZWxpemUuXG4gIHJldHVybiB0cnVlO1xufVxuIl19