"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.tryResolveDependencyVersion = exports.tryResolveModuleManifest = exports.tryResolveManifestPathFromSearch = exports.tryResolveManifestPathFromPath = exports.tryResolveManifestPathFromDefaultExport = exports.tryResolveModuleManifestPath = exports.tryResolveModule = exports.minVersion = exports.extractCodeArtifactDetails = exports.codeArtifactRegex = exports.renderBundleName = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const semver = require("semver");
const util_1 = require("../util");
function renderBundleName(entrypoint) {
    const parts = (0, path_1.join)(entrypoint).split(path_1.sep);
    if (parts[0] === "src") {
        parts.shift(); // just remove 'src' if its the first element for ergonomics
    }
    const p = parts.join(path_1.sep);
    const dir = (0, path_1.dirname)(p);
    const base = (0, path_1.basename)(p, (0, path_1.extname)(p));
    return (0, path_1.join)(dir, base);
}
exports.renderBundleName = renderBundleName;
/**
 * Regex for AWS CodeArtifact registry
 */
exports.codeArtifactRegex = /^https:\/\/(?<registry>(?<domain>[^\.]+)-(?<accountId>\d{12})\.d\.codeartifact\.(?<region>[^\.]+).*\.amazonaws\.com\/.*\/(?<repository>[^\/.]+)\/)/;
/**
 * gets AWS details from the Code Artifact registry URL
 * throws exception if not matching expected pattern
 * @param registryUrl Code Artifact registry URL
 * @returns object containing the (domain, accountId, region, repository)
 */
function extractCodeArtifactDetails(registryUrl) {
    const match = registryUrl.match(exports.codeArtifactRegex);
    if (match?.groups) {
        const { domain, accountId, region, repository, registry } = match.groups;
        return { domain, accountId, region, repository, registry };
    }
    throw new Error("Could not get CodeArtifact details from npm Registry");
}
exports.extractCodeArtifactDetails = extractCodeArtifactDetails;
function minVersion(version) {
    if (semver.validRange(version)) {
        return semver.minVersion(version)?.version;
    }
    else {
        return version;
    }
}
exports.minVersion = minVersion;
/**
 * Attempt to resolve location of the given `moduleId`.
 * @param moduleId Module ID to lookup.
 * @param options Passed through to `require.resolve`.
 */
function tryResolveModule(moduleId, options) {
    try {
        return require.resolve(moduleId, options);
    }
    catch {
        return undefined;
    }
}
exports.tryResolveModule = tryResolveModule;
/**
 * Attempt to resolve a module's manifest (package.json) path via `require.resolve` lookup.
 *
 * @remarks
 * If the target package has `exports` that differ from the default
 * (i.e, it defines the `exports` field in its manifest) and does not
 * explicitly include an entry for `package.json`, this strategy will fail.
 * See {@link tryResolveManifestPathFromDefaultExport} as an alternative.
 *
 * @param moduleId Module ID to lookup.
 * @param options Passed through to `require.resolve`.
 */
function tryResolveModuleManifestPath(moduleId, options) {
    // cannot just `require('dependency/package.json')` here because
    // `options.paths` may not overlap with this node proc's resolution paths.
    const manifestId = `${moduleId}/package.json`;
    return tryResolveModule(manifestId, options);
}
exports.tryResolveModuleManifestPath = tryResolveModuleManifestPath;
/**
 * Attempt to resolve a module's manifest (package.json) path by looking for the nearest
 * `package.json` file that is an ancestor to the module's default export location.
 *
 * @param moduleId Module ID to lookup.
 * @param options Passed through to `require.resolve`.
 */
function tryResolveManifestPathFromDefaultExport(moduleId, options) {
    const defaultExportPath = tryResolveModule(moduleId, options);
    if (!defaultExportPath) {
        return undefined;
    }
    const moduleDir = (0, util_1.findUp)("package.json", defaultExportPath);
    if (!moduleDir) {
        return undefined;
    }
    return (0, path_1.join)(moduleDir, "package.json");
}
exports.tryResolveManifestPathFromDefaultExport = tryResolveManifestPathFromDefaultExport;
/**
 * Attempt to resolve a module's manifest (package.json) path by checking for its existence under `node_modules` relative to `basePath`.
 *
 * @remarks
 * This strategy can be helpful in the scenario that a module defines
 * custom exports without `package.json` and no default export (i.e, some type definition packages).
 *
 * @param moduleId Module ID to lookup.
 * @param basePath Root path to search from.
 */
function tryResolveManifestPathFromPath(moduleId, basePath) {
    const base = basePath.includes("node_modules")
        ? basePath
        : (0, path_1.join)(basePath, "node_modules");
    const filePath = (0, path_1.resolve)(base, ...moduleId.split("/"), "package.json");
    if ((0, fs_1.existsSync)(filePath)) {
        return filePath;
    }
    return undefined;
}
exports.tryResolveManifestPathFromPath = tryResolveManifestPathFromPath;
/**
 * Attempt to resolve a module's manifest (package.json) path by searching for it in the optionally provided paths array
 * as well as the current node processes' default resolution paths.
 * @param moduleId Module ID to search for.
 * @param options Search options.
 */
function tryResolveManifestPathFromSearch(moduleId, options) {
    const searchPaths = [
        ...(options?.paths ?? []),
        ...(require.resolve.paths(moduleId) ?? []),
    ];
    for (const path of searchPaths) {
        const result = tryResolveManifestPathFromPath(moduleId, path);
        // early return on first result.
        if (result) {
            return result;
        }
    }
    return undefined;
}
exports.tryResolveManifestPathFromSearch = tryResolveManifestPathFromSearch;
/**
 * Attempt to resolve a module's manifest (package.json) using multiple strategies.
 * @param moduleId Module to resolve manifest path for.
 * @param options Resolution options.
 */
function tryResolveModuleManifest(moduleId, options) {
    const strategies = [
        tryResolveModuleManifestPath,
        tryResolveManifestPathFromDefaultExport,
        tryResolveManifestPathFromSearch,
    ];
    for (const strategy of strategies) {
        const result = strategy(moduleId, options);
        // early return on first result.
        if (result) {
            try {
                const manifest = JSON.parse((0, fs_1.readFileSync)(result, "utf8"));
                // verify name matches target module.
                if (manifest.name === moduleId) {
                    return manifest;
                }
            }
            catch {
                // continue to next strategy.
            }
        }
    }
    return undefined;
}
exports.tryResolveModuleManifest = tryResolveModuleManifest;
/**
 * Attempt to resolve the installed version of a given dependency.
 * @param dependencyName Name of dependency.
 * @param options Optional options passed through to `require.resolve`.
 */
function tryResolveDependencyVersion(dependencyName, options) {
    const manifest = tryResolveModuleManifest(dependencyName, options);
    if (!manifest) {
        return undefined;
    }
    return manifest?.version;
}
exports.tryResolveDependencyVersion = tryResolveDependencyVersion;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9qYXZhc2NyaXB0L3V0aWwudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7O0FBQUEsMkJBQThDO0FBQzlDLCtCQUFzRTtBQUN0RSxpQ0FBaUM7QUFDakMsa0NBQWlDO0FBa0JqQyxTQUFnQixnQkFBZ0IsQ0FBQyxVQUFrQjtJQUNqRCxNQUFNLEtBQUssR0FBRyxJQUFBLFdBQUksRUFBQyxVQUFVLENBQUMsQ0FBQyxLQUFLLENBQUMsVUFBRyxDQUFDLENBQUM7SUFDMUMsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLEtBQUssS0FBSyxFQUFFO1FBQ3RCLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLDREQUE0RDtLQUM1RTtJQUVELE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBRyxDQUFDLENBQUM7SUFDMUIsTUFBTSxHQUFHLEdBQUcsSUFBQSxjQUFPLEVBQUMsQ0FBQyxDQUFDLENBQUM7SUFDdkIsTUFBTSxJQUFJLEdBQUcsSUFBQSxlQUFRLEVBQUMsQ0FBQyxFQUFFLElBQUEsY0FBTyxFQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckMsT0FBTyxJQUFBLFdBQUksRUFBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLENBQUM7QUFDekIsQ0FBQztBQVZELDRDQVVDO0FBRUQ7O0dBRUc7QUFDVSxRQUFBLGlCQUFpQixHQUM1QixvSkFBb0osQ0FBQztBQUV2Sjs7Ozs7R0FLRztBQUNILFNBQWdCLDBCQUEwQixDQUFDLFdBQW1CO0lBQzVELE1BQU0sS0FBSyxHQUFHLFdBQVcsQ0FBQyxLQUFLLENBQUMseUJBQWlCLENBQUMsQ0FBQztJQUNuRCxJQUFJLEtBQUssRUFBRSxNQUFNLEVBQUU7UUFDakIsTUFBTSxFQUFFLE1BQU0sRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxRQUFRLEVBQUUsR0FBRyxLQUFLLENBQUMsTUFBTSxDQUFDO1FB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LE9BQU8sTUFBTSxDQUFDO1NBQ2Y7S0FDRjtJQUNELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUFoQkQsNEVBZ0JDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLHdCQUF3QixDQUN0QyxRQUFnQixFQUNoQixPQUE2QjtJQUU3QixNQUFNLFVBQVUsR0FBRztRQUNqQiw0QkFBNEI7UUFDNUIsdUNBQXVDO1FBQ3ZDLGdDQUFnQztLQUNqQyxDQUFDO0lBQ0YsS0FBSyxNQUFNLFFBQVEsSUFBSSxVQUFVLEVBQUU7UUFDakMsTUFBTSxNQUFNLEdBQUcsUUFBUSxDQUFDLFFBQVEsRUFBRSxPQUFPLENBQUMsQ0FBQztRQUMzQyxnQ0FBZ0M7UUFDaEMsSUFBSSxNQUFNLEVBQUU7WUFDVixJQUFJO2dCQUNGLE1BQU0sUUFBUSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQ3pCLElBQUEsaUJBQVksRUFBQyxNQUFNLEVBQUUsTUFBTSxDQUFDLENBQ1YsQ0FBQztnQkFDckIscUNBQXFDO2dCQUNyQyxJQUFJLFFBQVEsQ0FBQyxJQUFJLEtBQUssUUFBUSxFQUFFO29CQUM5QixPQUFPLFFBQVEsQ0FBQztpQkFDakI7YUFDRjtZQUFDLE1BQU07Z0JBQ04sNkJBQTZCO2FBQzlCO1NBQ0Y7S0FDRjtJQUNELE9BQU8sU0FBUyxDQUFDO0FBQ25CLENBQUM7QUEzQkQsNERBMkJDO0FBRUQ7Ozs7R0FJRztBQUNILFNBQWdCLDJCQUEyQixDQUN6QyxjQUFzQixFQUN0QixPQUE2QjtJQUU3QixNQUFNLFFBQVEsR0FBRyx3QkFBd0IsQ0FBQyxjQUFjLEVBQUUsT0FBTyxDQUFDLENBQUM7SUFDbkUsSUFBSSxDQUFDLFFBQVEsRUFBRTtRQUNiLE9BQU8sU0FBUyxDQUFDO0tBQ2xCO0lBQ0QsT0FBTyxRQUFRLEVBQUUsT0FBTyxDQUFDO0FBQzNCLENBQUM7QUFURCxrRUFTQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGV4aXN0c1N5bmMsIHJlYWRGaWxlU3luYyB9IGZyb20gXCJmc1wiO1xuaW1wb3J0IHsgYmFzZW5hbWUsIGRpcm5hbWUsIGV4dG5hbWUsIGpvaW4sIHNlcCwgcmVzb2x2ZSB9IGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgKiBhcyBzZW12ZXIgZnJvbSBcInNlbXZlclwiO1xuaW1wb3J0IHsgZmluZFVwIH0gZnJvbSBcIi4uL3V0aWxcIjtcblxuLyoqXG4gKiBCYXNpYyBpbnRlcmZhY2UgZm9yIGBwYWNrYWdlLmpzb25gLlxuICovXG5pbnRlcmZhY2UgUGFja2FnZU1hbmlmZXN0IHtcbiAgW2tleTogc3RyaW5nXTogYW55O1xuXG4gIC8qKlxuICAgKiBQYWNrYWdlIG5hbWUuXG4gICAqL1xuICBuYW1lOiBzdHJpbmc7XG4gIC8qKlxuICAgKiBQYWNrYWdlIHZlcnNpb24uXG4gICAqL1xuICB2ZXJzaW9uOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiByZW5kZXJCdW5kbGVOYW1lKGVudHJ5cG9pbnQ6IHN0cmluZykge1xuICBjb25zdCBwYXJ0cyA9IGpvaW4oZW50cnlwb2ludCkuc3BsaXQoc2VwKTtcbiAgaWYgKHBhcnRzWzBdID09PSBcInNyY1wiKSB7XG4gICAgcGFydHMuc2hpZnQoKTsgLy8ganVzdCByZW1vdmUgJ3NyYycgaWYgaXRzIHRoZSBmaXJzdCBlbGVtZW50IGZvciBlcmdvbm9taWNzXG4gIH1cblxuICBjb25zdCBwID0gcGFydHMuam9pbihzZXApO1xuICBjb25zdCBkaXIgPSBkaXJuYW1lKHApO1xuICBjb25zdCBiYXNlID0gYmFzZW5hbWUocCwgZXh0bmFtZShwKSk7XG4gIHJldHVybiBqb2luKGRpciwgYmFzZSk7XG59XG5cbi8qKlxuICogUmVnZXggZm9yIEFXUyBDb2RlQXJ0aWZhY3QgcmVnaXN0cnlcbiAqL1xuZXhwb3J0IGNvbnN0IGNvZGVBcnRpZmFjdFJlZ2V4ID1cbiAgL15odHRwczpcXC9cXC8oPzxyZWdpc3RyeT4oPzxkb21haW4+W15cXC5dKyktKD88YWNjb3VudElkPlxcZHsxMn0pXFwuZFxcLmNvZGVhcnRpZmFjdFxcLig/PHJlZ2lvbj5bXlxcLl0rKS4qXFwuYW1hem9uYXdzXFwuY29tXFwvLipcXC8oPzxyZXBvc2l0b3J5PlteXFwvLl0rKVxcLykvO1xuXG4vKipcbiAqIGdldHMgQVdTIGRldGFpbHMgZnJvbSB0aGUgQ29kZSBBcnRpZmFjdCByZWdpc3RyeSBVUkxcbiAqIHRocm93cyBleGNlcHRpb24gaWYgbm90IG1hdGNoaW5nIGV4cGVjdGVkIHBhdHRlcm5cbiAqIEBwYXJhbSByZWdpc3RyeVVybCBDb2RlIEFydGlmYWN0IHJlZ2lzdHJ5IFVSTFxuICogQHJldHVybnMgb2JqZWN0IGNvbnRhaW5pbmcgdGhlIChkb21haW4sIGFjY291bnRJZCwgcmVnaW9uLCByZXBvc2l0b3J5KVxuICovXG5leHBvcnQgZnVuY3Rpb24gZXh0cmFjdENvZGVBcnRpZmFjdERldGFpbHMocmVnaXN0cnlVcmw6IHN0cmluZykge1xuICBjb25zdCBtYXRjaCA9IHJlZ2lzdHJ5VXJsLm1hdGNoKGNvZGVBcnRpZmFjdFJlZ2V4KTtcbiAgaWYgKG1hdGNoPy5ncm91cHMpIHtcbiAgICBjb25zdCB7IGRvbWFpbiwgYWNjb3VudElkLCByZWdpb24sIHJlcG9zaXRvcnksIHJlZ2lzdHJ5IH0gPSBtYXRjaC5ncm91cHM7XG4gICAgcmV0dXJuIHsgZG9tYWluLCBhY2NvdW50SWQsIHJlZ2lvbiwgcmVwb3NpdG9yeSwgcmVnaXN0cnkgfTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgZ2V0IENvZGVBcnRpZmFjdCBkZXRhaWxzIGZyb20gbnBtIFJlZ2lzdHJ5XCIpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWluVmVyc2lvbih2ZXJzaW9uOiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoc2VtdmVyLnZhbGlkUmFuZ2UodmVyc2lvbikpIHtcbiAgICByZXR1cm4gc2VtdmVyLm1pblZlcnNpb24odmVyc2lvbik/LnZlcnNpb247XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHZlcnNpb247XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIHJlc29sdmUgbG9jYXRpb24gb2YgdGhlIGdpdmVuIGBtb2R1bGVJZGAuXG4gKiBAcGFyYW0gbW9kdWxlSWQgTW9kdWxlIElEIHRvIGxvb2t1cC5cbiAqIEBwYXJhbSBvcHRpb25zIFBhc3NlZCB0aHJvdWdoIHRvIGByZXF1aXJlLnJlc29sdmVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJ5UmVzb2x2ZU1vZHVsZShcbiAgbW9kdWxlSWQ6IHN0cmluZyxcbiAgb3B0aW9ucz86IHsgcGF0aHM6IHN0cmluZ1tdIH1cbik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIHJlcXVpcmUucmVzb2x2ZShtb2R1bGVJZCwgb3B0aW9ucyk7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIHJlc29sdmUgYSBtb2R1bGUncyBtYW5pZmVzdCAocGFja2FnZS5qc29uKSBwYXRoIHZpYSBgcmVxdWlyZS5yZXNvbHZlYCBsb29rdXAuXG4gKlxuICogQHJlbWFya3NcbiAqIElmIHRoZSB0YXJnZXQgcGFja2FnZSBoYXMgYGV4cG9ydHNgIHRoYXQgZGlmZmVyIGZyb20gdGhlIGRlZmF1bHRcbiAqIChpLmUsIGl0IGRlZmluZXMgdGhlIGBleHBvcnRzYCBmaWVsZCBpbiBpdHMgbWFuaWZlc3QpIGFuZCBkb2VzIG5vdFxuICogZXhwbGljaXRseSBpbmNsdWRlIGFuIGVudHJ5IGZvciBgcGFja2FnZS5qc29uYCwgdGhpcyBzdHJhdGVneSB3aWxsIGZhaWwuXG4gKiBTZWUge0BsaW5rIHRyeVJlc29sdmVNYW5pZmVzdFBhdGhGcm9tRGVmYXVsdEV4cG9ydH0gYXMgYW4gYWx0ZXJuYXRpdmUuXG4gKlxuICogQHBhcmFtIG1vZHVsZUlkIE1vZHVsZSBJRCB0byBsb29rdXAuXG4gKiBAcGFyYW0gb3B0aW9ucyBQYXNzZWQgdGhyb3VnaCB0byBgcmVxdWlyZS5yZXNvbHZlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRyeVJlc29sdmVNb2R1bGVNYW5pZmVzdFBhdGgoXG4gIG1vZHVsZUlkOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiB7IHBhdGhzOiBzdHJpbmdbXSB9XG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAvLyBjYW5ub3QganVzdCBgcmVxdWlyZSgnZGVwZW5kZW5jeS9wYWNrYWdlLmpzb24nKWAgaGVyZSBiZWNhdXNlXG4gIC8vIGBvcHRpb25zLnBhdGhzYCBtYXkgbm90IG92ZXJsYXAgd2l0aCB0aGlzIG5vZGUgcHJvYydzIHJlc29sdXRpb24gcGF0aHMuXG4gIGNvbnN0IG1hbmlmZXN0SWQgPSBgJHttb2R1bGVJZH0vcGFja2FnZS5qc29uYDtcbiAgcmV0dXJuIHRyeVJlc29sdmVNb2R1bGUobWFuaWZlc3RJZCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byByZXNvbHZlIGEgbW9kdWxlJ3MgbWFuaWZlc3QgKHBhY2thZ2UuanNvbikgcGF0aCBieSBsb29raW5nIGZvciB0aGUgbmVhcmVzdFxuICogYHBhY2thZ2UuanNvbmAgZmlsZSB0aGF0IGlzIGFuIGFuY2VzdG9yIHRvIHRoZSBtb2R1bGUncyBkZWZhdWx0IGV4cG9ydCBsb2NhdGlvbi5cbiAqXG4gKiBAcGFyYW0gbW9kdWxlSWQgTW9kdWxlIElEIHRvIGxvb2t1cC5cbiAqIEBwYXJhbSBvcHRpb25zIFBhc3NlZCB0aHJvdWdoIHRvIGByZXF1aXJlLnJlc29sdmVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJ5UmVzb2x2ZU1hbmlmZXN0UGF0aEZyb21EZWZhdWx0RXhwb3J0KFxuICBtb2R1bGVJZDogc3RyaW5nLFxuICBvcHRpb25zPzogeyBwYXRoczogc3RyaW5nW10gfVxuKTogc3RyaW5nIHwgdW5kZWZpbmVkIHtcbiAgY29uc3QgZGVmYXVsdEV4cG9ydFBhdGggPSB0cnlSZXNvbHZlTW9kdWxlKG1vZHVsZUlkLCBvcHRpb25zKTtcbiAgaWYgKCFkZWZhdWx0RXhwb3J0UGF0aCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgY29uc3QgbW9kdWxlRGlyID0gZmluZFVwKFwicGFja2FnZS5qc29uXCIsIGRlZmF1bHRFeHBvcnRQYXRoKTtcbiAgaWYgKCFtb2R1bGVEaXIpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBqb2luKG1vZHVsZURpciwgXCJwYWNrYWdlLmpzb25cIik7XG59XG5cbi8qKlxuICogQXR0ZW1wdCB0byByZXNvbHZlIGEgbW9kdWxlJ3MgbWFuaWZlc3QgKHBhY2thZ2UuanNvbikgcGF0aCBieSBjaGVja2luZyBmb3IgaXRzIGV4aXN0ZW5jZSB1bmRlciBgbm9kZV9tb2R1bGVzYCByZWxhdGl2ZSB0byBgYmFzZVBhdGhgLlxuICpcbiAqIEByZW1hcmtzXG4gKiBUaGlzIHN0cmF0ZWd5IGNhbiBiZSBoZWxwZnVsIGluIHRoZSBzY2VuYXJpbyB0aGF0IGEgbW9kdWxlIGRlZmluZXNcbiAqIGN1c3RvbSBleHBvcnRzIHdpdGhvdXQgYHBhY2thZ2UuanNvbmAgYW5kIG5vIGRlZmF1bHQgZXhwb3J0IChpLmUsIHNvbWUgdHlwZSBkZWZpbml0aW9uIHBhY2thZ2VzKS5cbiAqXG4gKiBAcGFyYW0gbW9kdWxlSWQgTW9kdWxlIElEIHRvIGxvb2t1cC5cbiAqIEBwYXJhbSBiYXNlUGF0aCBSb290IHBhdGggdG8gc2VhcmNoIGZyb20uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnlSZXNvbHZlTWFuaWZlc3RQYXRoRnJvbVBhdGgoXG4gIG1vZHVsZUlkOiBzdHJpbmcsXG4gIGJhc2VQYXRoOiBzdHJpbmdcbikge1xuICBjb25zdCBiYXNlID0gYmFzZVBhdGguaW5jbHVkZXMoXCJub2RlX21vZHVsZXNcIilcbiAgICA/IGJhc2VQYXRoXG4gICAgOiBqb2luKGJhc2VQYXRoLCBcIm5vZGVfbW9kdWxlc1wiKTtcbiAgY29uc3QgZmlsZVBhdGggPSByZXNvbHZlKGJhc2UsIC4uLm1vZHVsZUlkLnNwbGl0KFwiL1wiKSwgXCJwYWNrYWdlLmpzb25cIik7XG4gIGlmIChleGlzdHNTeW5jKGZpbGVQYXRoKSkge1xuICAgIHJldHVybiBmaWxlUGF0aDtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gcmVzb2x2ZSBhIG1vZHVsZSdzIG1hbmlmZXN0IChwYWNrYWdlLmpzb24pIHBhdGggYnkgc2VhcmNoaW5nIGZvciBpdCBpbiB0aGUgb3B0aW9uYWxseSBwcm92aWRlZCBwYXRocyBhcnJheVxuICogYXMgd2VsbCBhcyB0aGUgY3VycmVudCBub2RlIHByb2Nlc3NlcycgZGVmYXVsdCByZXNvbHV0aW9uIHBhdGhzLlxuICogQHBhcmFtIG1vZHVsZUlkIE1vZHVsZSBJRCB0byBzZWFyY2ggZm9yLlxuICogQHBhcmFtIG9wdGlvbnMgU2VhcmNoIG9wdGlvbnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnlSZXNvbHZlTWFuaWZlc3RQYXRoRnJvbVNlYXJjaChcbiAgbW9kdWxlSWQ6IHN0cmluZyxcbiAgb3B0aW9ucz86IHsgcGF0aHM6IHN0cmluZ1tdIH1cbik6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IHNlYXJjaFBhdGhzID0gW1xuICAgIC4uLihvcHRpb25zPy5wYXRocyA/PyBbXSksXG4gICAgLi4uKHJlcXVpcmUucmVzb2x2ZS5wYXRocyhtb2R1bGVJZCkgPz8gW10pLFxuICBdO1xuICBmb3IgKGNvbnN0IHBhdGggb2Ygc2VhcmNoUGF0aHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0cnlSZXNvbHZlTWFuaWZlc3RQYXRoRnJvbVBhdGgobW9kdWxlSWQsIHBhdGgpO1xuICAgIC8vIGVhcmx5IHJldHVybiBvbiBmaXJzdCByZXN1bHQuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIHJlc29sdmUgYSBtb2R1bGUncyBtYW5pZmVzdCAocGFja2FnZS5qc29uKSB1c2luZyBtdWx0aXBsZSBzdHJhdGVnaWVzLlxuICogQHBhcmFtIG1vZHVsZUlkIE1vZHVsZSB0byByZXNvbHZlIG1hbmlmZXN0IHBhdGggZm9yLlxuICogQHBhcmFtIG9wdGlvbnMgUmVzb2x1dGlvbiBvcHRpb25zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdHJ5UmVzb2x2ZU1vZHVsZU1hbmlmZXN0KFxuICBtb2R1bGVJZDogc3RyaW5nLFxuICBvcHRpb25zPzogeyBwYXRoczogc3RyaW5nW10gfVxuKTogUGFja2FnZU1hbmlmZXN0IHwgdW5kZWZpbmVkIHtcbiAgY29uc3Qgc3RyYXRlZ2llcyA9IFtcbiAgICB0cnlSZXNvbHZlTW9kdWxlTWFuaWZlc3RQYXRoLFxuICAgIHRyeVJlc29sdmVNYW5pZmVzdFBhdGhGcm9tRGVmYXVsdEV4cG9ydCxcbiAgICB0cnlSZXNvbHZlTWFuaWZlc3RQYXRoRnJvbVNlYXJjaCxcbiAgXTtcbiAgZm9yIChjb25zdCBzdHJhdGVneSBvZiBzdHJhdGVnaWVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gc3RyYXRlZ3kobW9kdWxlSWQsIG9wdGlvbnMpO1xuICAgIC8vIGVhcmx5IHJldHVybiBvbiBmaXJzdCByZXN1bHQuXG4gICAgaWYgKHJlc3VsdCkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWFuaWZlc3QgPSBKU09OLnBhcnNlKFxuICAgICAgICAgIHJlYWRGaWxlU3luYyhyZXN1bHQsIFwidXRmOFwiKVxuICAgICAgICApIGFzIFBhY2thZ2VNYW5pZmVzdDtcbiAgICAgICAgLy8gdmVyaWZ5IG5hbWUgbWF0Y2hlcyB0YXJnZXQgbW9kdWxlLlxuICAgICAgICBpZiAobWFuaWZlc3QubmFtZSA9PT0gbW9kdWxlSWQpIHtcbiAgICAgICAgICByZXR1cm4gbWFuaWZlc3Q7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2gge1xuICAgICAgICAvLyBjb250aW51ZSB0byBuZXh0IHN0cmF0ZWd5LlxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG4vKipcbiAqIEF0dGVtcHQgdG8gcmVzb2x2ZSB0aGUgaW5zdGFsbGVkIHZlcnNpb24gb2YgYSBnaXZlbiBkZXBlbmRlbmN5LlxuICogQHBhcmFtIGRlcGVuZGVuY3lOYW1lIE5hbWUgb2YgZGVwZW5kZW5jeS5cbiAqIEBwYXJhbSBvcHRpb25zIE9wdGlvbmFsIG9wdGlvbnMgcGFzc2VkIHRocm91Z2ggdG8gYHJlcXVpcmUucmVzb2x2ZWAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0cnlSZXNvbHZlRGVwZW5kZW5jeVZlcnNpb24oXG4gIGRlcGVuZGVuY3lOYW1lOiBzdHJpbmcsXG4gIG9wdGlvbnM/OiB7IHBhdGhzOiBzdHJpbmdbXSB9XG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBjb25zdCBtYW5pZmVzdCA9IHRyeVJlc29sdmVNb2R1bGVNYW5pZmVzdChkZXBlbmRlbmN5TmFtZSwgb3B0aW9ucyk7XG4gIGlmICghbWFuaWZlc3QpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBtYW5pZmVzdD8udmVyc2lvbjtcbn1cbiJdfQ==