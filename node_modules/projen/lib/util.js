"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.findUp = exports.isRoot = exports.multipleSelected = exports.anySelected = exports.getNodeMajorVersion = exports.isExecutable = exports.isWritable = exports.tryReadFileSync = exports.tryReadFile = exports.snakeCaseKeys = exports.kebabCaseKeys = exports.getGitVersion = exports.formatAsPythonModule = exports.sorted = exports.dedupArray = exports.deepMerge = exports.isObject = exports.isTruthy = exports.decamelizeKeysRecursively = exports.writeFile = exports.getFilePermissions = exports.execOrUndefined = exports.execCapture = exports.exec = void 0;
const child_process = require("child_process");
const fs_1 = require("fs");
const path = require("path");
const Case = require("case");
const logging = require("./logging");
const MAX_BUFFER = 10 * 1024 * 1024;
/**
 * Executes a command with STDOUT > STDERR.
 */
function exec(command, options) {
    logging.debug(command);
    child_process.execSync(command, {
        stdio: ["inherit", 2, "pipe"],
        maxBuffer: MAX_BUFFER,
        cwd: options.cwd,
    });
}
exports.exec = exec;
/**
 * Executes command and returns STDOUT. If the command fails (non-zero), throws an error.
 */
function execCapture(command, options) {
    logging.debug(command);
    return child_process.execSync(command, {
        stdio: ["inherit", "pipe", "pipe"],
        maxBuffer: MAX_BUFFER,
        cwd: options.cwd,
    });
}
exports.execCapture = execCapture;
/**
 * Executes `command` and returns its value or undefined if the command failed.
 */
function execOrUndefined(command, options) {
    try {
        const value = child_process
            .execSync(command, {
            stdio: ["inherit", "pipe", "pipe"],
            maxBuffer: MAX_BUFFER,
            cwd: options.cwd,
        })
            .toString("utf-8")
            .trim();
        if (!value) {
            return undefined;
        } // an empty string is the same as undefined
        return value;
    }
    catch {
        return undefined;
    }
}
exports.execOrUndefined = execOrUndefined;
function getFilePermissions(options) {
    const readonly = options.readonly ?? false;
    const executable = options.executable ?? false;
    if (readonly && executable) {
        return "544";
    }
    else if (readonly) {
        return "444";
    }
    else if (executable) {
        return "755";
    }
    else {
        return "644";
    }
}
exports.getFilePermissions = getFilePermissions;
function writeFile(filePath, data, options = {}) {
    if ((0, fs_1.existsSync)(filePath)) {
        (0, fs_1.chmodSync)(filePath, "600");
    }
    (0, fs_1.mkdirSync)(path.dirname(filePath), { recursive: true });
    (0, fs_1.writeFileSync)(filePath, data);
    (0, fs_1.chmodSync)(filePath, getFilePermissions(options));
}
exports.writeFile = writeFile;
function decamelizeKeysRecursively(input, opt) {
    const shouldAlwaysDecamelize = () => true;
    const shouldDecamelize = opt?.shouldDecamelize ?? shouldAlwaysDecamelize;
    const separator = opt?.separator ?? "_";
    const path_ = opt?.path ?? [];
    const maxDepth = opt?.maxDepth ?? 10;
    if (path_.length > maxDepth) {
        throw new Error("Decamelled too deeply - check that the input has no circular references");
    }
    if (Array.isArray(input)) {
        return input.map((k, i) => decamelizeKeysRecursively(k, {
            ...opt,
            path: [...path_, i.toString()],
        }));
    }
    if (typeof input === "object" && input !== null) {
        const mappedObject = {};
        for (const [key, value] of Object.entries(input)) {
            const transformedKey = shouldDecamelize([...path_, key], value)
                ? decamelize(key, separator)
                : key;
            mappedObject[transformedKey] = decamelizeKeysRecursively(value, {
                ...opt,
                path: [...path_, key],
            });
        }
        return mappedObject;
    }
    return input;
}
exports.decamelizeKeysRecursively = decamelizeKeysRecursively;
/**
 * Returns false if value is unset or a falsey value, and true otherwise.
 * @param value an environment variable
 */
function isTruthy(value) {
    return !(value === undefined ||
        ["null", "undefined", "0", "false", ""].includes(value.toLocaleLowerCase()));
}
exports.isTruthy = isTruthy;
/**
 * Return whether the given value is an object
 *
 * Even though arrays and instances of classes technically are objects, we
 * usually want to treat them differently, so we return false in those cases.
 */
function isObject(x) {
    return (x !== null &&
        typeof x === "object" &&
        !Array.isArray(x) &&
        x.constructor.name === "Object");
}
exports.isObject = isObject;
/**
 * Recursively merge objects together
 *
 * The leftmost object is mutated and returned. Arrays are not merged
 * but overwritten just like scalars.
 *
 * If an object is merged into a non-object, the non-object is lost.
 *
 * `undefined`s will cause a value to be deleted if destructive is enabled.
 */
function deepMerge(objects, destructive = false) {
    function mergeOne(target, source) {
        for (const key of Object.keys(source)) {
            const value = source[key];
            if (isObject(value)) {
                // if the value at the target is not an object, override it with an
                // object so we can continue the recursion
                if (typeof target[key] !== "object") {
                    target[key] = value;
                }
                if ("__$APPEND" in value && Array.isArray(value.__$APPEND)) {
                    if (Array.isArray(target[key])) {
                        target[key].push(...value.__$APPEND);
                    }
                    else {
                        target[key] = value.__$APPEND;
                    }
                }
                mergeOne(target[key], value);
                // if the result of the merge is an empty object, it's because the
                // eventual value we assigned is `undefined`, and there are no
                // sibling concrete values alongside, so we can delete this tree.
                const output = target[key];
                if (typeof output === "object" &&
                    Object.keys(output).length === 0 &&
                    destructive) {
                    delete target[key];
                }
            }
            else if (value === undefined && destructive) {
                delete target[key];
            }
            else if (typeof value !== "undefined") {
                target[key] = value;
            }
        }
    }
    const others = objects.filter((x) => x != null);
    if (others.length === 0) {
        return {};
    }
    const into = others.splice(0, 1)[0];
    others.forEach((other) => mergeOne(into, other));
    return into;
}
exports.deepMerge = deepMerge;
/*
 * Deduplicate values in a list, returning a new array.
 * @param array list of values
 */
function dedupArray(array) {
    return array.filter((val, idx) => array.indexOf(val) === idx);
}
exports.dedupArray = dedupArray;
/**
 * Returns a sorted version of `x` or `undefined` if it is an empty array or object.
 */
function sorted(x) {
    if (x == null) {
        return undefined;
    }
    if (Array.isArray(x)) {
        if (x.length === 0) {
            return undefined;
        }
        return x.sort();
    }
    else if (typeof x === "object") {
        if (Object.keys(x).length === 0) {
            return undefined;
        }
        const result = {};
        for (const [key, value] of Object.entries(x).sort(([l], [r]) => l.localeCompare(r))) {
            result[key] = value;
        }
        return result;
    }
    else {
        return x;
    }
}
exports.sorted = sorted;
function formatAsPythonModule(name) {
    return name.replace(/-/g, "_").replace(/\./g, "_");
}
exports.formatAsPythonModule = formatAsPythonModule;
/**
 * Extract git version number from command line
 *
 * @param gitVersionOutput the output from `git version` CLI
 * @returns the version of git
 */
function getGitVersion(gitVersionOutput) {
    const match = gitVersionOutput.match(/\d+.\d+.\d+/);
    if (!match) {
        throw new Error("Unable to retrieve git version");
    }
    return match[0];
}
exports.getGitVersion = getGitVersion;
function kebabCaseKeys(obj, recursive = true) {
    if (typeof obj !== "object" || obj == null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        if (recursive) {
            obj = obj.map((v) => kebabCaseKeys(v, recursive));
        }
        return obj;
    }
    const result = {};
    for (let [k, v] of Object.entries(obj)) {
        if (recursive) {
            v = kebabCaseKeys(v, recursive);
        }
        result[decamelize(k).replace(/_/gm, "-")] = v;
    }
    return result;
}
exports.kebabCaseKeys = kebabCaseKeys;
function snakeCaseKeys(obj, recursive = true, exclusiveForRecordKeys = []) {
    if (typeof obj !== "object" || obj == null) {
        return obj;
    }
    if (Array.isArray(obj)) {
        if (recursive) {
            obj = obj.map((v) => snakeCaseKeys(v, recursive, exclusiveForRecordKeys));
        }
        return obj;
    }
    const result = {};
    for (let [k, v] of Object.entries(obj)) {
        if (recursive) {
            v = snakeCaseKeys(v, recursive, exclusiveForRecordKeys);
        }
        const modifiedKey = exclusiveForRecordKeys.length == 0 || exclusiveForRecordKeys.includes(k)
            ? Case.snake(k)
            : k;
        result[modifiedKey] = v;
    }
    return result;
}
exports.snakeCaseKeys = snakeCaseKeys;
async function tryReadFile(file) {
    if (!(0, fs_1.existsSync)(file)) {
        return "";
    }
    return fs_1.promises.readFile(file, "utf-8");
}
exports.tryReadFile = tryReadFile;
function tryReadFileSync(file) {
    if (!(0, fs_1.existsSync)(file)) {
        return undefined;
    }
    return (0, fs_1.readFileSync)(file, "utf-8");
}
exports.tryReadFileSync = tryReadFileSync;
function isWritable(file) {
    try {
        (0, fs_1.accessSync)(file, fs_1.constants.W_OK);
        return true;
    }
    catch {
        return false;
    }
}
exports.isWritable = isWritable;
function isExecutable(file) {
    try {
        (0, fs_1.accessSync)(file, fs_1.constants.X_OK);
        return true;
    }
    catch (e) {
        return false;
    }
}
exports.isExecutable = isExecutable;
function decamelize(s, sep = "_") {
    if (Case.of(s) === "camel") {
        return Case.lower(s, sep);
    }
    else {
        return s;
    }
}
function getNodeMajorVersion() {
    const match = process.version.match(/(\d+)\.(\d+)\.(\d+)/);
    if (match) {
        const [major] = match.slice(1).map((x) => parseInt(x));
        return major;
    }
    return undefined;
}
exports.getNodeMajorVersion = getNodeMajorVersion;
function anySelected(options) {
    return options.some((opt) => opt);
}
exports.anySelected = anySelected;
function multipleSelected(options) {
    return options.filter((opt) => opt).length > 1;
}
exports.multipleSelected = multipleSelected;
/**
 * Checks if a path is a FS root
 *
 * Optional uses a provided OS specific path implementation,
 * defaults to use the implementation for the current OS.
 *
 * @internal
 */
function isRoot(dir, osPathLib = path) {
    const parent = osPathLib.dirname(dir);
    return parent === dir;
}
exports.isRoot = isRoot;
/**
 * Run up project tree to find a file or directory
 *
 * @param lookFor the file or directory to look for
 * @param cwd current working directory, must be an absolute path
 * @returns path to the file or directory we are looking for, undefined if not found
 */
function findUp(lookFor, cwd = process.cwd()) {
    if ((0, fs_1.existsSync)(path.join(cwd, lookFor))) {
        return cwd;
    }
    if (isRoot(cwd)) {
        // This is a root
        return undefined;
    }
    return findUp(lookFor, path.dirname(cwd));
}
exports.findUp = findUp;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXRpbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy91dGlsLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtDQUErQztBQUMvQywyQkFTWTtBQUNaLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IscUNBQXFDO0FBRXJDLE1BQU0sVUFBVSxHQUFHLEVBQUUsR0FBRyxJQUFJLEdBQUcsSUFBSSxDQUFDO0FBRXBDOztHQUVHO0FBQ0gsU0FBZ0IsSUFBSSxDQUFDLE9BQWUsRUFBRSxPQUF3QjtJQUM1RCxPQUFPLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO0lBQ3ZCLGFBQWEsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFO1FBQzlCLEtBQUssRUFBRSxDQUFDLFNBQVMsRUFBRSxDQUFDLEVBQUUsTUFBTSxDQUFDO1FBQzdCLFNBQVMsRUFBRSxVQUFVO1FBQ3JCLEdBQUcsRUFBRSxPQUFPLENBQUMsR0FBRztLQUNqQixDQUFDLENBQUM7QUFDTCxDQUFDO0FBUEQsb0JBT0M7QUFFRDs7R0FFRztBQUNILFNBQWdCLFdBQVcsQ0FBQyxPQUFlLEVBQUUsT0FBd0I7SUFDbkUsT0FBTyxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUN2QixPQUFPLGFBQWEsQ0FBQyxRQUFRLENBQUMsT0FBTyxFQUFFO1FBQ3JDLEtBQUssRUFBRSxDQUFDLFNBQVMsRUFBRSxNQUFNLEVBQUUsTUFBTSxDQUFDO1FBQ2xDLFNBQVMsRUFBRSxVQUFVO1FBQ3JCLEdBQUcsRUFBRSxPQUFPLENBQUMsR0FBRztLQUNqQixDQUFDLENBQUM7QUFDTCxDQUFDO0FBUEQsa0NBT0M7QUFFRDs7R0FFRztBQUNILFNBQWdCLGVBQWUsQ0FDN0IsT0FBZSxFQUNmLE9BQXdCO0lBRXhCLElBQUk7UUFDRixNQUFNLEtBQUssR0FBRyxhQUFhO2FBQ3hCLFFBQVEsQ0FBQyxPQUFPLEVBQUU7WUFDakIsS0FBSyxFQUFFLENBQUMsU0FBUyxFQUFFLE1BQU0sRUFB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QztBQUZELGtDQUVDO0FBRUQsU0FBZ0IsZ0JBQWdCLENBQUMsT0FBZ0M7SUFDL0QsT0FBTyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0FBQ2pELENBQUM7QUFGRCw0Q0FFQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQixNQUFNLENBQUMsR0FBVyxFQUFFLFlBQXlCLElBQUk7SUFDL0QsTUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQztJQUN0QyxPQUFPLE1BQU0sS0FBSyxHQUFHLENBQUM7QUFDeEIsQ0FBQztBQUhELHdCQUdDO0FBRUQ7Ozs7OztHQU1HO0FBQ0gsU0FBZ0IsTUFBTSxDQUNwQixPQUFlLEVBQ2YsTUFBYyxPQUFPLENBQUMsR0FBRyxFQUFFO0lBRTNCLElBQUksSUFBQSxlQUFVLEVBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUN2QyxPQUFPLEdBQUcsQ0FBQztLQUNaO0lBRUQsSUFBSSxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDZixpQkFBaUI7UUFDakIsT0FBTyxTQUFTLENBQUM7S0FDbEI7SUFDRCxPQUFPLE1BQU0sQ0FBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBQzVDLENBQUM7QUFiRCx3QkFhQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNoaWxkX3Byb2Nlc3MgZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcbmltcG9ydCB7XG4gIGFjY2Vzc1N5bmMsXG4gIGNobW9kU3luYyxcbiAgY29uc3RhbnRzIGFzIGZzX2NvbnN0YW50cyxcbiAgZXhpc3RzU3luYyxcbiAgbWtkaXJTeW5jLFxuICBwcm9taXNlcyBhcyBmcyxcbiAgcmVhZEZpbGVTeW5jLFxuICB3cml0ZUZpbGVTeW5jLFxufSBmcm9tIFwiZnNcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIENhc2UgZnJvbSBcImNhc2VcIjtcbmltcG9ydCAqIGFzIGxvZ2dpbmcgZnJvbSBcIi4vbG9nZ2luZ1wiO1xuXG5jb25zdCBNQVhfQlVGRkVSID0gMTAgKiAxMDI0ICogMTAyNDtcblxuLyoqXG4gKiBFeGVjdXRlcyBhIGNvbW1hbmQgd2l0aCBTVERPVVQgPiBTVERFUlIuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjKGNvbW1hbmQ6IHN0cmluZywgb3B0aW9uczogeyBjd2Q6IHN0cmluZyB9KTogdm9pZCB7XG4gIGxvZ2dpbmcuZGVidWcoY29tbWFuZCk7XG4gIGNoaWxkX3Byb2Nlc3MuZXhlY1N5bmMoY29tbWFuZCwge1xuICAgIHN0ZGlvOiBbXCJpbmhlcml0XCIsIDIsIFwicGlwZVwiXSwgLy8gXCJwaXBlXCIgZm9yIFNUREVSUiBtZWFucyBpdCBhcHBlYXJzIGluIGV4Y2VwdGlvbnNcbiAgICBtYXhCdWZmZXI6IE1BWF9CVUZGRVIsXG4gICAgY3dkOiBvcHRpb25zLmN3ZCxcbiAgfSk7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgY29tbWFuZCBhbmQgcmV0dXJucyBTVERPVVQuIElmIHRoZSBjb21tYW5kIGZhaWxzIChub24temVybyksIHRocm93cyBhbiBlcnJvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGV4ZWNDYXB0dXJlKGNvbW1hbmQ6IHN0cmluZywgb3B0aW9uczogeyBjd2Q6IHN0cmluZyB9KSB7XG4gIGxvZ2dpbmcuZGVidWcoY29tbWFuZCk7XG4gIHJldHVybiBjaGlsZF9wcm9jZXNzLmV4ZWNTeW5jKGNvbW1hbmQsIHtcbiAgICBzdGRpbzogW1wiaW5oZXJpdFwiLCBcInBpcGVcIiwgXCJwaXBlXCJdLCAvLyBcInBpcGVcIiBmb3IgU1RERVJSIG1lYW5zIGl0IGFwcGVhcnMgaW4gZXhjZXB0aW9uc1xuICAgIG1heEJ1ZmZlcjogTUFYX0JVRkZFUixcbiAgICBjd2Q6IG9wdGlvbnMuY3dkLFxuICB9KTtcbn1cblxuLyoqXG4gKiBFeGVjdXRlcyBgY29tbWFuZGAgYW5kIHJldHVybnMgaXRzIHZhbHVlIG9yIHVuZGVmaW5lZCBpZiB0aGUgY29tbWFuZCBmYWlsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjT3JVbmRlZmluZWQoXG4gIGNvbW1hbmQ6IHN0cmluZyxcbiAgb3B0aW9uczogeyBjd2Q6IHN0cmluZyB9XG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICB0cnkge1xuICAgIGNvbnN0IHZhbHVlID0gY2hpbGRfcHJvY2Vzc1xuICAgICAgLmV4ZWNTeW5jKGNvbW1hbmQsIHtcbiAgICAgICAgc3RkaW86IFtcImluaGVyaXRcIiwgXCJwaXBlXCIsIFwicGlwZVwiXSwgLy8gXCJwaXBlXCIgZm9yIFNUREVSUiBtZWFucyBpdCBhcHBlYXJzIGluIGV4Y2VwdGlvbnNcbiAgICAgICAgbWF4QnVmZmVyOiBNQVhfQlVGRkVSLFxuICAgICAgICBjd2Q6IG9wdGlvbnMuY3dkLFxuICAgICAgfSlcbiAgICAgIC50b1N0cmluZyhcInV0Zi04XCIpXG4gICAgICAudHJpbSgpO1xuXG4gICAgaWYgKCF2YWx1ZSkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9IC8vIGFuIGVtcHR5IHN0cmluZyBpcyB0aGUgc2FtZSBhcyB1bmRlZmluZWRcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBXcml0ZUZpbGVPcHRpb25zIHtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGdlbmVyYXRlZCBmaWxlIHNob3VsZCBiZSBtYXJrZWQgYXMgZXhlY3V0YWJsZS5cbiAgICpcbiAgICogQGRlZmF1bHQgZmFsc2VcbiAgICovXG4gIGV4ZWN1dGFibGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBnZW5lcmF0ZWQgZmlsZSBzaG91bGQgYmUgcmVhZG9ubHkuXG4gICAqXG4gICAqIEBkZWZhdWx0IGZhbHNlXG4gICAqL1xuICByZWFkb25seT86IGJvb2xlYW47XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGaWxlUGVybWlzc2lvbnMob3B0aW9uczogV3JpdGVGaWxlT3B0aW9ucyk6IHN0cmluZyB7XG4gIGNvbnN0IHJlYWRvbmx5ID0gb3B0aW9ucy5yZWFkb25seSA/PyBmYWxzZTtcbiAgY29uc3QgZXhlY3V0YWJsZSA9IG9wdGlvbnMuZXhlY3V0YWJsZSA/PyBmYWxzZTtcbiAgaWYgKHJlYWRvbmx5ICYmIGV4ZWN1dGFibGUpIHtcbiAgICByZXR1cm4gXCI1NDRcIjtcbiAgfSBlbHNlIGlmIChyZWFkb25seSkge1xuICAgIHJldHVybiBcIjQ0NFwiO1xuICB9IGVsc2UgaWYgKGV4ZWN1dGFibGUpIHtcbiAgICByZXR1cm4gXCI3NTVcIjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCI2NDRcIjtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gd3JpdGVGaWxlKFxuICBmaWxlUGF0aDogc3RyaW5nLFxuICBkYXRhOiBhbnksXG4gIG9wdGlvbnM6IFdyaXRlRmlsZU9wdGlvbnMgPSB7fVxuKSB7XG4gIGlmIChleGlzdHNTeW5jKGZpbGVQYXRoKSkge1xuICAgIGNobW9kU3luYyhmaWxlUGF0aCwgXCI2MDBcIik7XG4gIH1cblxuICBta2RpclN5bmMocGF0aC5kaXJuYW1lKGZpbGVQYXRoKSwgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gIHdyaXRlRmlsZVN5bmMoZmlsZVBhdGgsIGRhdGEpO1xuXG4gIGNobW9kU3luYyhmaWxlUGF0aCwgZ2V0RmlsZVBlcm1pc3Npb25zKG9wdGlvbnMpKTtcbn1cblxuLyoqXG4gKiBEZWNhbWVsaXplcyB0aGUga2V5cyBvZiBhbiBvYmplY3Qgc3RydWN0dXJlLCByZWN1cnNpbmcgdGhyb3VnaCBjaGlsZCBvYmplY3RzIGFuZCBhcnJheXMuXG4gKiBAZXhwZXJpbWVudGFsXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGVjYW1lbGl6ZVJlY3Vyc2l2ZWx5T3B0aW9ucyB7XG4gIC8qKlxuICAgKiBNYXggZGVwdGggdG8gcmVjdXJzZSBiZWZvcmUgZXJyb3JpbmcuXG4gICAqIEBkZWZhdWx0IDEwXG4gICAqL1xuICBtYXhEZXB0aD86IG51bWJlcjtcblxuICAvKipcbiAgICogUmV0dXJucyB0cnVlIHdoZW4gYSBrZXkgc2hvdWxkIGJlIGRlY2FtZWxpemVkXG4gICAqIEBkZWZhdWx0IC0gYWxsIGtleXMgYXJlIGRlY2FtZWxpemVkXG4gICAqL1xuICBzaG91bGREZWNhbWVsaXplPzogKHBhdGg6IHN0cmluZ1tdLCB2YWx1ZTogYW55KSA9PiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBTZXBhcmF0b3IgZm9yIGRlY2FtZWxpemluZy5cbiAgICogQGRlZmF1bHQgXCJfXCJcbiAgICovXG4gIHNlcGFyYXRvcj86IHN0cmluZztcblxuICAvKipcbiAgICogQ3VycmVudCBwYXRoLlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG4gIHBhdGg/OiBzdHJpbmdbXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlY2FtZWxpemVLZXlzUmVjdXJzaXZlbHkoXG4gIGlucHV0OiBhbnksXG4gIG9wdD86IERlY2FtZWxpemVSZWN1cnNpdmVseU9wdGlvbnNcbik6IGFueSB7XG4gIGNvbnN0IHNob3VsZEFsd2F5c0RlY2FtZWxpemUgPSAoKSA9PiB0cnVlO1xuICBjb25zdCBzaG91bGREZWNhbWVsaXplID0gb3B0Py5zaG91bGREZWNhbWVsaXplID8/IHNob3VsZEFsd2F5c0RlY2FtZWxpemU7XG4gIGNvbnN0IHNlcGFyYXRvciA9IG9wdD8uc2VwYXJhdG9yID8/IFwiX1wiO1xuICBjb25zdCBwYXRoXyA9IG9wdD8ucGF0aCA/PyBbXTtcbiAgY29uc3QgbWF4RGVwdGggPSBvcHQ/Lm1heERlcHRoID8/IDEwO1xuXG4gIGlmIChwYXRoXy5sZW5ndGggPiBtYXhEZXB0aCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIFwiRGVjYW1lbGxlZCB0b28gZGVlcGx5IC0gY2hlY2sgdGhhdCB0aGUgaW5wdXQgaGFzIG5vIGNpcmN1bGFyIHJlZmVyZW5jZXNcIlxuICAgICk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dCkpIHtcbiAgICByZXR1cm4gaW5wdXQubWFwKChrLCBpKSA9PlxuICAgICAgZGVjYW1lbGl6ZUtleXNSZWN1cnNpdmVseShrLCB7XG4gICAgICAgIC4uLm9wdCxcbiAgICAgICAgcGF0aDogWy4uLnBhdGhfLCBpLnRvU3RyaW5nKCldLFxuICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJvYmplY3RcIiAmJiBpbnB1dCAhPT0gbnVsbCkge1xuICAgIGNvbnN0IG1hcHBlZE9iamVjdDogUmVjb3JkPHN0cmluZywgYW55PiA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGlucHV0KSkge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRLZXkgPSBzaG91bGREZWNhbWVsaXplKFsuLi5wYXRoXywga2V5XSwgdmFsdWUpXG4gICAgICAgID8gZGVjYW1lbGl6ZShrZXksIHNlcGFyYXRvcilcbiAgICAgICAgOiBrZXk7XG5cbiAgICAgIG1hcHBlZE9iamVjdFt0cmFuc2Zvcm1lZEtleV0gPSBkZWNhbWVsaXplS2V5c1JlY3Vyc2l2ZWx5KHZhbHVlLCB7XG4gICAgICAgIC4uLm9wdCxcbiAgICAgICAgcGF0aDogWy4uLnBhdGhfLCBrZXldLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1hcHBlZE9iamVjdDtcbiAgfVxuXG4gIHJldHVybiBpbnB1dDtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGZhbHNlIGlmIHZhbHVlIGlzIHVuc2V0IG9yIGEgZmFsc2V5IHZhbHVlLCBhbmQgdHJ1ZSBvdGhlcndpc2UuXG4gKiBAcGFyYW0gdmFsdWUgYW4gZW52aXJvbm1lbnQgdmFyaWFibGVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzVHJ1dGh5KHZhbHVlOiBzdHJpbmcgfCB1bmRlZmluZWQpOiBib29sZWFuIHtcbiAgcmV0dXJuICEoXG4gICAgdmFsdWUgPT09IHVuZGVmaW5lZCB8fFxuICAgIFtcIm51bGxcIiwgXCJ1bmRlZmluZWRcIiwgXCIwXCIsIFwiZmFsc2VcIiwgXCJcIl0uaW5jbHVkZXModmFsdWUudG9Mb2NhbGVMb3dlckNhc2UoKSlcbiAgKTtcbn1cblxuLyoqXG4gKiBUeXBlIG9mIGEgbWFwIG1hcHBpbmcgc3RyaW5ncyB0byBzb21lIGFyYml0cmFyeSB0eXBlXG4gKi9cbmV4cG9ydCB0eXBlIE9iajxUPiA9IHsgW2tleTogc3RyaW5nXTogVCB9O1xuXG4vKipcbiAqIFJldHVybiB3aGV0aGVyIHRoZSBnaXZlbiB2YWx1ZSBpcyBhbiBvYmplY3RcbiAqXG4gKiBFdmVuIHRob3VnaCBhcnJheXMgYW5kIGluc3RhbmNlcyBvZiBjbGFzc2VzIHRlY2huaWNhbGx5IGFyZSBvYmplY3RzLCB3ZVxuICogdXN1YWxseSB3YW50IHRvIHRyZWF0IHRoZW0gZGlmZmVyZW50bHksIHNvIHdlIHJldHVybiBmYWxzZSBpbiB0aG9zZSBjYXNlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KHg6IGFueSk6IHggaXMgT2JqPGFueT4ge1xuICByZXR1cm4gKFxuICAgIHggIT09IG51bGwgJiZcbiAgICB0eXBlb2YgeCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICFBcnJheS5pc0FycmF5KHgpICYmXG4gICAgeC5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk9iamVjdFwiXG4gICk7XG59XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyB0b2dldGhlclxuICpcbiAqIFRoZSBsZWZ0bW9zdCBvYmplY3QgaXMgbXV0YXRlZCBhbmQgcmV0dXJuZWQuIEFycmF5cyBhcmUgbm90IG1lcmdlZFxuICogYnV0IG92ZXJ3cml0dGVuIGp1c3QgbGlrZSBzY2FsYXJzLlxuICpcbiAqIElmIGFuIG9iamVjdCBpcyBtZXJnZWQgaW50byBhIG5vbi1vYmplY3QsIHRoZSBub24tb2JqZWN0IGlzIGxvc3QuXG4gKlxuICogYHVuZGVmaW5lZGBzIHdpbGwgY2F1c2UgYSB2YWx1ZSB0byBiZSBkZWxldGVkIGlmIGRlc3RydWN0aXZlIGlzIGVuYWJsZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZWVwTWVyZ2UoXG4gIG9iamVjdHM6IEFycmF5PE9iajxhbnk+IHwgdW5kZWZpbmVkPixcbiAgZGVzdHJ1Y3RpdmU6IGJvb2xlYW4gPSBmYWxzZVxuKSB7XG4gIGZ1bmN0aW9uIG1lcmdlT25lKHRhcmdldDogT2JqPGFueT4sIHNvdXJjZTogT2JqPGFueT4pIHtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhzb3VyY2UpKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IHNvdXJjZVtrZXldO1xuXG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIC8vIGlmIHRoZSB2YWx1ZSBhdCB0aGUgdGFyZ2V0IGlzIG5vdCBhbiBvYmplY3QsIG92ZXJyaWRlIGl0IHdpdGggYW5cbiAgICAgICAgLy8gb2JqZWN0IHNvIHdlIGNhbiBjb250aW51ZSB0aGUgcmVjdXJzaW9uXG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0W2tleV0gIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICB0YXJnZXRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFwiX18kQVBQRU5EXCIgaW4gdmFsdWUgJiYgQXJyYXkuaXNBcnJheSh2YWx1ZS5fXyRBUFBFTkQpKSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0W2tleV0pKSB7XG4gICAgICAgICAgICB0YXJnZXRba2V5XS5wdXNoKC4uLnZhbHVlLl9fJEFQUEVORCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gdmFsdWUuX18kQVBQRU5EO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIG1lcmdlT25lKHRhcmdldFtrZXldLCB2YWx1ZSk7XG5cbiAgICAgICAgLy8gaWYgdGhlIHJlc3VsdCBvZiB0aGUgbWVyZ2UgaXMgYW4gZW1wdHkgb2JqZWN0LCBpdCdzIGJlY2F1c2UgdGhlXG4gICAgICAgIC8vIGV2ZW50dWFsIHZhbHVlIHdlIGFzc2lnbmVkIGlzIGB1bmRlZmluZWRgLCBhbmQgdGhlcmUgYXJlIG5vXG4gICAgICAgIC8vIHNpYmxpbmcgY29uY3JldGUgdmFsdWVzIGFsb25nc2lkZSwgc28gd2UgY2FuIGRlbGV0ZSB0aGlzIHRyZWUuXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IHRhcmdldFtrZXldO1xuICAgICAgICBpZiAoXG4gICAgICAgICAgdHlwZW9mIG91dHB1dCA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgIE9iamVjdC5rZXlzKG91dHB1dCkubGVuZ3RoID09PSAwICYmXG4gICAgICAgICAgZGVzdHJ1Y3RpdmVcbiAgICAgICAgKSB7XG4gICAgICAgICAgZGVsZXRlIHRhcmdldFtrZXldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgZGVzdHJ1Y3RpdmUpIHtcbiAgICAgICAgZGVsZXRlIHRhcmdldFtrZXldO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBjb25zdCBvdGhlcnMgPSBvYmplY3RzLmZpbHRlcigoeCkgPT4geCAhPSBudWxsKSBhcyBBcnJheTxPYmo8YW55Pj47XG5cbiAgaWYgKG90aGVycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4ge307XG4gIH1cbiAgY29uc3QgaW50byA9IG90aGVycy5zcGxpY2UoMCwgMSlbMF07XG5cbiAgb3RoZXJzLmZvckVhY2goKG90aGVyKSA9PiBtZXJnZU9uZShpbnRvLCBvdGhlcikpO1xuICByZXR1cm4gaW50bztcbn1cblxuLypcbiAqIERlZHVwbGljYXRlIHZhbHVlcyBpbiBhIGxpc3QsIHJldHVybmluZyBhIG5ldyBhcnJheS5cbiAqIEBwYXJhbSBhcnJheSBsaXN0IG9mIHZhbHVlc1xuICovXG5leHBvcnQgZnVuY3Rpb24gZGVkdXBBcnJheTxUPihhcnJheTogVFtdKTogVFtdIHtcbiAgcmV0dXJuIGFycmF5LmZpbHRlcigodmFsLCBpZHgpID0+IGFycmF5LmluZGV4T2YodmFsKSA9PT0gaWR4KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgc29ydGVkIHZlcnNpb24gb2YgYHhgIG9yIGB1bmRlZmluZWRgIGlmIGl0IGlzIGFuIGVtcHR5IGFycmF5IG9yIG9iamVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvcnRlZDxUPih4OiBUKSB7XG4gIGlmICh4ID09IG51bGwpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgaWYgKHgubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gKHggYXMgdW5rbm93bltdKS5zb3J0KCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHggPT09IFwib2JqZWN0XCIpIHtcbiAgICBpZiAoT2JqZWN0LmtleXMoeCkubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoeCkuc29ydCgoW2xdLCBbcl0pID0+XG4gICAgICBsLmxvY2FsZUNvbXBhcmUocilcbiAgICApKSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0IGFzIFQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHg7XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdEFzUHl0aG9uTW9kdWxlKG5hbWU6IHN0cmluZykge1xuICByZXR1cm4gbmFtZS5yZXBsYWNlKC8tL2csIFwiX1wiKS5yZXBsYWNlKC9cXC4vZywgXCJfXCIpO1xufVxuXG4vKipcbiAqIEV4dHJhY3QgZ2l0IHZlcnNpb24gbnVtYmVyIGZyb20gY29tbWFuZCBsaW5lXG4gKlxuICogQHBhcmFtIGdpdFZlcnNpb25PdXRwdXQgdGhlIG91dHB1dCBmcm9tIGBnaXQgdmVyc2lvbmAgQ0xJXG4gKiBAcmV0dXJucyB0aGUgdmVyc2lvbiBvZiBnaXRcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEdpdFZlcnNpb24oZ2l0VmVyc2lvbk91dHB1dDogc3RyaW5nKSB7XG4gIGNvbnN0IG1hdGNoID0gZ2l0VmVyc2lvbk91dHB1dC5tYXRjaCgvXFxkKy5cXGQrLlxcZCsvKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXRyaWV2ZSBnaXQgdmVyc2lvblwiKTtcbiAgfVxuXG4gIHJldHVybiBtYXRjaFswXTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGtlYmFiQ2FzZUtleXM8VCA9IHVua25vd24+KG9iajogVCwgcmVjdXJzaXZlID0gdHJ1ZSk6IFQge1xuICBpZiAodHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIiB8fCBvYmogPT0gbnVsbCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgb2JqID0gb2JqLm1hcCgodikgPT4ga2ViYWJDYXNlS2V5cyh2LCByZWN1cnNpdmUpKSBhcyBhbnk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG4gIGZvciAobGV0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgdiA9IGtlYmFiQ2FzZUtleXModiwgcmVjdXJzaXZlKTtcbiAgICB9XG4gICAgcmVzdWx0W2RlY2FtZWxpemUoaykucmVwbGFjZSgvXy9nbSwgXCItXCIpXSA9IHY7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdCBhcyBhbnk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzbmFrZUNhc2VLZXlzPFQgPSB1bmtub3duPihcbiAgb2JqOiBULFxuICByZWN1cnNpdmUgPSB0cnVlLFxuICBleGNsdXNpdmVGb3JSZWNvcmRLZXlzOiBzdHJpbmdbXSA9IFtdXG4pOiBUIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09IG51bGwpIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuICAgIGlmIChyZWN1cnNpdmUpIHtcbiAgICAgIG9iaiA9IG9iai5tYXAoKHYpID0+XG4gICAgICAgIHNuYWtlQ2FzZUtleXModiwgcmVjdXJzaXZlLCBleGNsdXNpdmVGb3JSZWNvcmRLZXlzKVxuICAgICAgKSBhcyBhbnk7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBjb25zdCByZXN1bHQ6IFJlY29yZDxzdHJpbmcsIHVua25vd24+ID0ge307XG4gIGZvciAobGV0IFtrLCB2XSBvZiBPYmplY3QuZW50cmllcyhvYmopKSB7XG4gICAgaWYgKHJlY3Vyc2l2ZSkge1xuICAgICAgdiA9IHNuYWtlQ2FzZUtleXModiwgcmVjdXJzaXZlLCBleGNsdXNpdmVGb3JSZWNvcmRLZXlzKTtcbiAgICB9XG4gICAgY29uc3QgbW9kaWZpZWRLZXkgPVxuICAgICAgZXhjbHVzaXZlRm9yUmVjb3JkS2V5cy5sZW5ndGggPT0gMCB8fCBleGNsdXNpdmVGb3JSZWNvcmRLZXlzLmluY2x1ZGVzKGspXG4gICAgICAgID8gQ2FzZS5zbmFrZShrKVxuICAgICAgICA6IGs7XG4gICAgcmVzdWx0W21vZGlmaWVkS2V5XSA9IHY7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdCBhcyBhbnk7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiB0cnlSZWFkRmlsZShmaWxlOiBzdHJpbmcpIHtcbiAgaWYgKCFleGlzdHNTeW5jKGZpbGUpKSB7XG4gICAgcmV0dXJuIFwiXCI7XG4gIH1cblxuICByZXR1cm4gZnMucmVhZEZpbGUoZmlsZSwgXCJ1dGYtOFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHRyeVJlYWRGaWxlU3luYyhmaWxlOiBzdHJpbmcpIHtcbiAgaWYgKCFleGlzdHNTeW5jKGZpbGUpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuXG4gIHJldHVybiByZWFkRmlsZVN5bmMoZmlsZSwgXCJ1dGYtOFwiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzV3JpdGFibGUoZmlsZTogc3RyaW5nKSB7XG4gIHRyeSB7XG4gICAgYWNjZXNzU3luYyhmaWxlLCBmc19jb25zdGFudHMuV19PSyk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNFeGVjdXRhYmxlKGZpbGU6IHN0cmluZykge1xuICB0cnkge1xuICAgIGFjY2Vzc1N5bmMoZmlsZSwgZnNfY29uc3RhbnRzLlhfT0spO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlY2FtZWxpemUoczogc3RyaW5nLCBzZXA6IHN0cmluZyA9IFwiX1wiKSB7XG4gIGlmIChDYXNlLm9mKHMpID09PSBcImNhbWVsXCIpIHtcbiAgICByZXR1cm4gQ2FzZS5sb3dlcihzLCBzZXApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXROb2RlTWFqb3JWZXJzaW9uKCk6IG51bWJlciB8IHVuZGVmaW5lZCB7XG4gIGNvbnN0IG1hdGNoID0gcHJvY2Vzcy52ZXJzaW9uLm1hdGNoKC8oXFxkKylcXC4oXFxkKylcXC4oXFxkKykvKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgY29uc3QgW21ham9yXSA9IG1hdGNoLnNsaWNlKDEpLm1hcCgoeCkgPT4gcGFyc2VJbnQoeCkpO1xuICAgIHJldHVybiBtYWpvcjtcbiAgfVxuICByZXR1cm4gdW5kZWZpbmVkO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYW55U2VsZWN0ZWQob3B0aW9uczogKGJvb2xlYW4gfCB1bmRlZmluZWQpW10pOiBib29sZWFuIHtcbiAgcmV0dXJuIG9wdGlvbnMuc29tZSgob3B0KSA9PiBvcHQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbXVsdGlwbGVTZWxlY3RlZChvcHRpb25zOiAoYm9vbGVhbiB8IHVuZGVmaW5lZClbXSk6IGJvb2xlYW4ge1xuICByZXR1cm4gb3B0aW9ucy5maWx0ZXIoKG9wdCkgPT4gb3B0KS5sZW5ndGggPiAxO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIHBhdGggaXMgYSBGUyByb290XG4gKlxuICogT3B0aW9uYWwgdXNlcyBhIHByb3ZpZGVkIE9TIHNwZWNpZmljIHBhdGggaW1wbGVtZW50YXRpb24sXG4gKiBkZWZhdWx0cyB0byB1c2UgdGhlIGltcGxlbWVudGF0aW9uIGZvciB0aGUgY3VycmVudCBPUy5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzUm9vdChkaXI6IHN0cmluZywgb3NQYXRoTGliOiB0eXBlb2YgcGF0aCA9IHBhdGgpOiBib29sZWFuIHtcbiAgY29uc3QgcGFyZW50ID0gb3NQYXRoTGliLmRpcm5hbWUoZGlyKTtcbiAgcmV0dXJuIHBhcmVudCA9PT0gZGlyO1xufVxuXG4vKipcbiAqIFJ1biB1cCBwcm9qZWN0IHRyZWUgdG8gZmluZCBhIGZpbGUgb3IgZGlyZWN0b3J5XG4gKlxuICogQHBhcmFtIGxvb2tGb3IgdGhlIGZpbGUgb3IgZGlyZWN0b3J5IHRvIGxvb2sgZm9yXG4gKiBAcGFyYW0gY3dkIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnksIG11c3QgYmUgYW4gYWJzb2x1dGUgcGF0aFxuICogQHJldHVybnMgcGF0aCB0byB0aGUgZmlsZSBvciBkaXJlY3Rvcnkgd2UgYXJlIGxvb2tpbmcgZm9yLCB1bmRlZmluZWQgaWYgbm90IGZvdW5kXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmaW5kVXAoXG4gIGxvb2tGb3I6IHN0cmluZyxcbiAgY3dkOiBzdHJpbmcgPSBwcm9jZXNzLmN3ZCgpXG4pOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICBpZiAoZXhpc3RzU3luYyhwYXRoLmpvaW4oY3dkLCBsb29rRm9yKSkpIHtcbiAgICByZXR1cm4gY3dkO1xuICB9XG5cbiAgaWYgKGlzUm9vdChjd2QpKSB7XG4gICAgLy8gVGhpcyBpcyBhIHJvb3RcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBmaW5kVXAobG9va0ZvciwgcGF0aC5kaXJuYW1lKGN3ZCkpO1xufVxuIl19