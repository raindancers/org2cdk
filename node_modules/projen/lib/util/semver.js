"use strict";
// stolen from: https://github.com/aws/jsii/blob/main/packages/jsii-pacmak/lib/targets/version-utils.ts
Object.defineProperty(exports, "__esModule", { value: true });
exports.toReleaseVersion = exports.toPythonVersionRange = exports.toNuGetVersionRange = exports.toMavenVersionRange = exports.TargetName = void 0;
const util_1 = require("util");
const semver_1 = require("semver");
var TargetName;
(function (TargetName) {
    TargetName[TargetName["JAVA"] = 0] = "JAVA";
    TargetName[TargetName["DOTNET"] = 1] = "DOTNET";
    TargetName[TargetName["PYTHON"] = 2] = "PYTHON";
    TargetName[TargetName["GO"] = 3] = "GO";
    TargetName[TargetName["JAVASCRIPT"] = 4] = "JAVASCRIPT";
})(TargetName = exports.TargetName || (exports.TargetName = {}));
/**
 * Converts a SemVer range expression to a Maven version range expression.
 *
 * @param semverRange the SemVer range expression to convert.
 * @param suffix      the suffix to add to versions in the range.
 *
 * @see https://cwiki.apache.org/confluence/display/MAVENOLD/Dependency+Mediation+and+Conflict+Resolution
 */
function toMavenVersionRange(semverRange, suffix) {
    return toBracketNotation(semverRange, suffix, {
        semver: false,
        target: TargetName.JAVA,
    });
}
exports.toMavenVersionRange = toMavenVersionRange;
/**
 * Converts a SemVer range expression to a NuGet version range expression.
 *
 * @param semverRange the SemVer range expression to convert.
 *
 * @see https://docs.microsoft.com/en-us/nuget/concepts/package-versioning#version-ranges-and-wildcards
 */
function toNuGetVersionRange(semverRange) {
    return toBracketNotation(semverRange, undefined, {
        semver: false,
        target: TargetName.DOTNET,
    });
}
exports.toNuGetVersionRange = toNuGetVersionRange;
/**
 * Converts a SemVer range expression to a Python setuptools compatible version
 * constraint expression.
 *
 * @param semverRange the SemVer range expression to convert.
 */
function toPythonVersionRange(semverRange) {
    const range = new semver_1.Range(semverRange);
    return range.set
        .map((set) => set
        .map((comp) => {
        const versionId = toReleaseVersion(comp.semver.raw?.replace(/-0$/, "") ?? "0.0.0", TargetName.PYTHON);
        switch (comp.operator) {
            case "":
                // With ^0.0.0, somehow we get a left entry with an empty operator and value, we'll fix this up
                return comp.value === "" ? ">=0.0.0" : `==${versionId}`;
            case "=":
                return `==${versionId}`;
            default:
                // >, >=, <, <= are all valid expressions
                return `${comp.operator}${versionId}`;
        }
    })
        .join(", "))
        .join(", ");
}
exports.toPythonVersionRange = toPythonVersionRange;
/**
 * Converts an original version number from the NPM convention to the target
 * language's convention for expressing the same. For versions that do not
 * include a prerelease identifier, this always returns the assembly version
 * unmodified.
 *
 * @param assemblyVersion the assembly version being released
 * @param target          the target language for which the version is destined
 *
 * @returns the version that should be serialized
 */
function toReleaseVersion(assemblyVersion, target) {
    const version = (0, semver_1.parse)(assemblyVersion);
    if (version == null) {
        throw new Error(`Unable to parse the provided assembly version: "${assemblyVersion}"`);
    }
    if (version.prerelease.length === 0) {
        return assemblyVersion;
    }
    switch (target) {
        case TargetName.PYTHON:
            // Python supports a limited set of identifiers... And we have a mapping table...
            // https://packaging.python.org/guides/distributing-packages-using-setuptools/#pre-release-versioning
            const [label, sequence, ...rest] = version.prerelease;
            if (rest.filter((elt) => elt !== 0).length > 0 || sequence == null) {
                throw new Error(`Unable to map prerelease identifier (in: ${assemblyVersion}) components to python: ${(0, util_1.inspect)(version.prerelease)}. The format should be 'X.Y.Z-label.sequence', where sequence is a positive integer, and label is "dev", "pre", "alpha", beta", or "rc"`);
            }
            if (!Number.isInteger(sequence)) {
                throw new Error(`Unable to map prerelease identifier (in: ${assemblyVersion}) to python, as sequence ${(0, util_1.inspect)(sequence)} is not an integer`);
            }
            const baseVersion = `${version.major}.${version.minor}.${version.patch}`;
            // See PEP 440: https://www.python.org/dev/peps/pep-0440/#pre-releases
            switch (label) {
                case "dev":
                case "pre":
                    return `${baseVersion}.dev${sequence}`; // PEP 404 see developmental release as X.Y.devN
                case "alpha":
                    return `${baseVersion}a${sequence}`; // PEP 404 see alpha release as X.YaN
                case "beta":
                    return `${baseVersion}b${sequence}`; // PEP 404 see beta release as X.YbN
                case "rc":
                    return `${baseVersion}rc${sequence}`; // PEP 404 see release candidate as X.YrcN
                default:
                    throw new Error(`Unable to map prerelease identifier (in: ${assemblyVersion}) to python, as label ${(0, util_1.inspect)(label)} is not mapped (only "dev", "pre", "alpha", "beta" and "rc" are)`);
            }
        case TargetName.DOTNET:
        case TargetName.GO:
        case TargetName.JAVA:
        case TargetName.JAVASCRIPT:
            // Not touching - the NPM version number should be usable as-is
            break;
    }
    return assemblyVersion;
}
exports.toReleaseVersion = toReleaseVersion;
/**
 * Converts a semantic version range to the kind of bracket notation used by
 * Maven and NuGet. For example, this turns `^1.2.3` into `[1.2.3,2.0.0)`.
 *
 * @param semverRange The semantic version range to be converted.
 * @param suffix A version suffix to apply to versions in the resulting expression.
 * @param semver Whether the target supports full semantic versioning (including
 *               `-0` as the lowest possible prerelease identifier)
 *
 * @returns a bracket-notation version range.
 */
function toBracketNotation(semverRange, suffix, { semver = true, target = TargetName.JAVASCRIPT, } = {}) {
    if (semverRange === "*") {
        semverRange = ">=0.0.0";
    }
    const range = new semver_1.Range(semverRange);
    if (semverRange === range.range) {
        return semverRange;
    }
    return range.set
        .map((set) => {
        if (set.length === 1) {
            const version = set[0].semver.raw;
            if (!version && range.raw === ">=0.0.0") {
                // Case where version is '*'
                return "[0.0.0,)";
            }
            switch (set[0].operator || "=") {
                // "[version]" => means exactly version
                case "=":
                    return `[${addSuffix(version)}]`;
                // "(version,]" => means greater than version
                case ">":
                    return `(${addSuffix(version)},)`;
                // "[version,]" => means greater than or equal to that version
                case ">=":
                    return `[${addSuffix(version)},)`;
                // "[,version)" => means less than version
                case "<":
                    return `(,${addSuffix(version, !semver)})`;
                // "[,version]" => means less than or equal to version
                case "<=":
                    return `(,${addSuffix(version)}]`;
            }
        }
        else if (set.length === 2) {
            const nugetRange = toBracketRange(set[0], set[1]);
            if (nugetRange) {
                return nugetRange;
            }
        }
        throw new Error(`Unsupported SemVer range set in ${semverRange}: ${set
            .map((comp) => comp.value)
            .join(", ")}`);
    })
        .join(", ");
    function toBracketRange(left, right) {
        if (left.operator.startsWith("<") && right.operator.startsWith(">")) {
            // Order isn't ideal, swap around..
            [left, right] = [right, left];
        }
        // With ^0.0.0, somehow we get a left entry with an empty operator and value, we'll fix this up
        if (left.operator === "" && left.value === "") {
            left = new semver_1.Comparator(">=0.0.0", left.options);
        }
        if (!left.operator.startsWith(">") || !right.operator.startsWith("<")) {
            // We only support ranges defined like "> (or >=) left, < (or <=) right"
            return undefined;
        }
        const leftBrace = left.operator.endsWith("=") ? "[" : "(";
        const rightBrace = right.operator.endsWith("=") ? "]" : ")";
        return `${leftBrace}${addSuffix(left.semver.raw)},${addSuffix(right.semver.raw, right.operator === "<" && !semver)}${rightBrace}`;
    }
    function addSuffix(str, trimDashZero = false) {
        if (!str) {
            return "";
        }
        if (trimDashZero) {
            str = str.replace(/-0$/, "");
        }
        return suffix ? `${str}${suffix}` : toReleaseVersion(str, target);
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VtdmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL3V0aWwvc2VtdmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSx1R0FBdUc7OztBQUV2RywrQkFBK0I7QUFDL0IsbUNBQWtEO0FBRWxELElBQVksVUFNWDtBQU5ELFdBQVksVUFBVTtJQUNwQiwyQ0FBSSxDQUFBO0lBQ0osK0NBQU0sQ0FBQTtJQUNOLCtDQUFNLENBQUE7SUFDTix1Q0FBRSxDQUFBO0lBQ0YsdURBQVUsQ0FBQTtBQUNaLENBQUMsRUFOVyxVQUFVLEdBQVYsa0JBQVUsS0FBVixrQkFBVSxRQU1yQjtBQUVEOzs7Ozs7O0dBT0c7QUFDSCxTQUFnQixtQkFBbUIsQ0FDakMsV0FBbUIsRUFDbkIsTUFBZTtJQUVmLE9BQU8saUJBQWlCLENBQUMsV0FBVyxFQUFFLE1BQU0sRUFBRTtRQUM1QyxNQUFNLEVBQUUsS0FBSztRQUNiLE1BQU0sRUFBRSxVQUFVLENBQUMsSUFBSTtLQUN4QixDQUFDLENBQUM7QUFDTCxDQUFDO0FBUkQsa0RBUUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxTQUFnQixtQkFBbUIsQ0FBQyxXQUFtQjtJQUNyRCxPQUFPLGlCQUFpQixDQUFDLFdBQVcsRUFBRSxTQUFTLEVBQUU7UUFDL0MsTUFBTSxFQUFFLEtBQUs7UUFDYixNQUFNLEVBQUUsVUFBVSxDQUFDLE1BQU07S0FDMUIsQ0FBQyxDQUFDO0FBQ0wsQ0FBQztBQUxELGtEQUtDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxTQUFnQixvQkFBb0IsQ0FBQyxXQUFtQjtJQUN0RCxNQUFNLEtBQUssR0FBRyxJQUFJLGNBQUssQ0FBQyxXQUFXLENBQUMsQ0FBQztJQUNyQyxPQUFPLEtBQUssQ0FBQyxHQUFHO1NBQ2IsR0FBRyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FDWCxHQUFHO1NBQ0EsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEVBQUU7UUFDWixNQUFNLFNBQVMsR0FBRyxnQkFBZ0Is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RUFBRSxDQUFDLENBQUM7U0FDOUI7UUFDRCxPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsR0FBRyxHQUFHLEdBQUcsTUFBTSxFQUFFLENBQUMsQ0FBQyxDQUFDLGdCQUFnQixDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUNwRSxDQUFDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIHN0b2xlbiBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vYXdzL2pzaWkvYmxvYi9tYWluL3BhY2thZ2VzL2pzaWktcGFjbWFrL2xpYi90YXJnZXRzL3ZlcnNpb24tdXRpbHMudHNcblxuaW1wb3J0IHsgaW5zcGVjdCB9IGZyb20gXCJ1dGlsXCI7XG5pbXBvcnQgeyBDb21wYXJhdG9yLCBSYW5nZSwgcGFyc2UgfSBmcm9tIFwic2VtdmVyXCI7XG5cbmV4cG9ydCBlbnVtIFRhcmdldE5hbWUge1xuICBKQVZBLFxuICBET1RORVQsXG4gIFBZVEhPTixcbiAgR08sXG4gIEpBVkFTQ1JJUFQsXG59XG5cbi8qKlxuICogQ29udmVydHMgYSBTZW1WZXIgcmFuZ2UgZXhwcmVzc2lvbiB0byBhIE1hdmVuIHZlcnNpb24gcmFuZ2UgZXhwcmVzc2lvbi5cbiAqXG4gKiBAcGFyYW0gc2VtdmVyUmFuZ2UgdGhlIFNlbVZlciByYW5nZSBleHByZXNzaW9uIHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0gc3VmZml4ICAgICAgdGhlIHN1ZmZpeCB0byBhZGQgdG8gdmVyc2lvbnMgaW4gdGhlIHJhbmdlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9jd2lraS5hcGFjaGUub3JnL2NvbmZsdWVuY2UvZGlzcGxheS9NQVZFTk9MRC9EZXBlbmRlbmN5K01lZGlhdGlvbithbmQrQ29uZmxpY3QrUmVzb2x1dGlvblxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9NYXZlblZlcnNpb25SYW5nZShcbiAgc2VtdmVyUmFuZ2U6IHN0cmluZyxcbiAgc3VmZml4Pzogc3RyaW5nXG4pOiBzdHJpbmcge1xuICByZXR1cm4gdG9CcmFja2V0Tm90YXRpb24oc2VtdmVyUmFuZ2UsIHN1ZmZpeCwge1xuICAgIHNlbXZlcjogZmFsc2UsXG4gICAgdGFyZ2V0OiBUYXJnZXROYW1lLkpBVkEsXG4gIH0pO1xufVxuXG4vKipcbiAqIENvbnZlcnRzIGEgU2VtVmVyIHJhbmdlIGV4cHJlc3Npb24gdG8gYSBOdUdldCB2ZXJzaW9uIHJhbmdlIGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHNlbXZlclJhbmdlIHRoZSBTZW1WZXIgcmFuZ2UgZXhwcmVzc2lvbiB0byBjb252ZXJ0LlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvbnVnZXQvY29uY2VwdHMvcGFja2FnZS12ZXJzaW9uaW5nI3ZlcnNpb24tcmFuZ2VzLWFuZC13aWxkY2FyZHNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRvTnVHZXRWZXJzaW9uUmFuZ2Uoc2VtdmVyUmFuZ2U6IHN0cmluZyk6IHN0cmluZyB7XG4gIHJldHVybiB0b0JyYWNrZXROb3RhdGlvbihzZW12ZXJSYW5nZSwgdW5kZWZpbmVkLCB7XG4gICAgc2VtdmVyOiBmYWxzZSxcbiAgICB0YXJnZXQ6IFRhcmdldE5hbWUuRE9UTkVULFxuICB9KTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIFNlbVZlciByYW5nZSBleHByZXNzaW9uIHRvIGEgUHl0aG9uIHNldHVwdG9vbHMgY29tcGF0aWJsZSB2ZXJzaW9uXG4gKiBjb25zdHJhaW50IGV4cHJlc3Npb24uXG4gKlxuICogQHBhcmFtIHNlbXZlclJhbmdlIHRoZSBTZW1WZXIgcmFuZ2UgZXhwcmVzc2lvbiB0byBjb252ZXJ0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9QeXRob25WZXJzaW9uUmFuZ2Uoc2VtdmVyUmFuZ2U6IHN0cmluZyk6IHN0cmluZyB7XG4gIGNvbnN0IHJhbmdlID0gbmV3IFJhbmdlKHNlbXZlclJhbmdlKTtcbiAgcmV0dXJuIHJhbmdlLnNldFxuICAgIC5tYXAoKHNldCkgPT5cbiAgICAgIHNldFxuICAgICAgICAubWFwKChjb21wKSA9PiB7XG4gICAgICAgICAgY29uc3QgdmVyc2lvbklkID0gdG9SZWxlYXNlVmVyc2lvbihcbiAgICAgICAgICAgIGNvbXAuc2VtdmVyLnJhdz8ucmVwbGFjZSgvLTAkLywgXCJcIikgPz8gXCIwLjAuMFwiLFxuICAgICAgICAgICAgVGFyZ2V0TmFtZS5QWVRIT05cbiAgICAgICAgICApO1xuICAgICAgICAgIHN3aXRjaCAoY29tcC5vcGVyYXRvcikge1xuICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAvLyBXaXRoIF4wLjAuMCwgc29tZWhvdyB3ZSBnZXQgYSBsZWZ0IGVudHJ5IHdpdGggYW4gZW1wdHkgb3BlcmF0b3IgYW5kIHZhbHVlLCB3ZSdsbCBmaXggdGhpcyB1cFxuICAgICAgICAgICAgICByZXR1cm4gY29tcC52YWx1ZSA9PT0gXCJcIiA/IFwiPj0wLjAuMFwiIDogYD09JHt2ZXJzaW9uSWR9YDtcbiAgICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICAgIHJldHVybiBgPT0ke3ZlcnNpb25JZH1gO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgLy8gPiwgPj0sIDwsIDw9IGFyZSBhbGwgdmFsaWQgZXhwcmVzc2lvbnNcbiAgICAgICAgICAgICAgcmV0dXJuIGAke2NvbXAub3BlcmF0b3J9JHt2ZXJzaW9uSWR9YDtcbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKFwiLCBcIilcbiAgICApXG4gICAgLmpvaW4oXCIsIFwiKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhbiBvcmlnaW5hbCB2ZXJzaW9uIG51bWJlciBmcm9tIHRoZSBOUE0gY29udmVudGlvbiB0byB0aGUgdGFyZ2V0XG4gKiBsYW5ndWFnZSdzIGNvbnZlbnRpb24gZm9yIGV4cHJlc3NpbmcgdGhlIHNhbWUuIEZvciB2ZXJzaW9ucyB0aGF0IGRvIG5vdFxuICogaW5jbHVkZSBhIHByZXJlbGVhc2UgaWRlbnRpZmllciwgdGhpcyBhbHdheXMgcmV0dXJucyB0aGUgYXNzZW1ibHkgdmVyc2lvblxuICogdW5tb2RpZmllZC5cbiAqXG4gKiBAcGFyYW0gYXNzZW1ibHlWZXJzaW9uIHRoZSBhc3NlbWJseSB2ZXJzaW9uIGJlaW5nIHJlbGVhc2VkXG4gKiBAcGFyYW0gdGFyZ2V0ICAgICAgICAgIHRoZSB0YXJnZXQgbGFuZ3VhZ2UgZm9yIHdoaWNoIHRoZSB2ZXJzaW9uIGlzIGRlc3RpbmVkXG4gKlxuICogQHJldHVybnMgdGhlIHZlcnNpb24gdGhhdCBzaG91bGQgYmUgc2VyaWFsaXplZFxuICovXG5leHBvcnQgZnVuY3Rpb24gdG9SZWxlYXNlVmVyc2lvbihcbiAgYXNzZW1ibHlWZXJzaW9uOiBzdHJpbmcsXG4gIHRhcmdldDogVGFyZ2V0TmFtZVxuKTogc3RyaW5nIHtcbiAgY29uc3QgdmVyc2lvbiA9IHBhcnNlKGFzc2VtYmx5VmVyc2lvbik7XG4gIGlmICh2ZXJzaW9uID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVW5hYmxlIHRvIHBhcnNlIHRoZSBwcm92aWRlZCBhc3NlbWJseSB2ZXJzaW9uOiBcIiR7YXNzZW1ibHlWZXJzaW9ufVwiYFxuICAgICk7XG4gIH1cbiAgaWYgKHZlcnNpb24ucHJlcmVsZWFzZS5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gYXNzZW1ibHlWZXJzaW9uO1xuICB9XG4gIHN3aXRjaCAodGFyZ2V0KSB7XG4gICAgY2FzZSBUYXJnZXROYW1lLlBZVEhPTjpcbiAgICAgIC8vIFB5dGhvbiBzdXBwb3J0cyBhIGxpbWl0ZWQgc2V0IG9mIGlkZW50aWZpZXJzLi4uIEFuZCB3ZSBoYXZlIGEgbWFwcGluZyB0YWJsZS4uLlxuICAgICAgLy8gaHR0cHM6Ly9wYWNrYWdpbmcucHl0aG9uLm9yZy9ndWlkZXMvZGlzdHJpYnV0aW5nLXBhY2thZ2VzLXVzaW5nLXNldHVwdG9vbHMvI3ByZS1yZWxlYXNlLXZlcnNpb25pbmdcbiAgICAgIGNvbnN0IFtsYWJlbCwgc2VxdWVuY2UsIC4uLnJlc3RdID0gdmVyc2lvbi5wcmVyZWxlYXNlO1xuICAgICAgaWYgKHJlc3QuZmlsdGVyKChlbHQpID0+IGVsdCAhPT0gMCkubGVuZ3RoID4gMCB8fCBzZXF1ZW5jZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgVW5hYmxlIHRvIG1hcCBwcmVyZWxlYXNlIGlkZW50aWZpZXIgKGluOiAke2Fzc2VtYmx5VmVyc2lvbn0pIGNvbXBvbmVudHMgdG8gcHl0aG9uOiAke2luc3BlY3QoXG4gICAgICAgICAgICB2ZXJzaW9uLnByZXJlbGVhc2VcbiAgICAgICAgICApfS4gVGhlIGZvcm1hdCBzaG91bGQgYmUgJ1guWS5aLWxhYmVsLnNlcXVlbmNlJywgd2hlcmUgc2VxdWVuY2UgaXMgYSBwb3NpdGl2ZSBpbnRlZ2VyLCBhbmQgbGFiZWwgaXMgXCJkZXZcIiwgXCJwcmVcIiwgXCJhbHBoYVwiLCBiZXRhXCIsIG9yIFwicmNcImBcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZXF1ZW5jZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBVbmFibGUgdG8gbWFwIHByZXJlbGVhc2UgaWRlbnRpZmllciAoaW46ICR7YXNzZW1ibHlWZXJzaW9ufSkgdG8gcHl0aG9uLCBhcyBzZXF1ZW5jZSAke2luc3BlY3QoXG4gICAgICAgICAgICBzZXF1ZW5jZVxuICAgICAgICAgICl9IGlzIG5vdCBhbiBpbnRlZ2VyYFxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY29uc3QgYmFzZVZlcnNpb24gPSBgJHt2ZXJzaW9uLm1ham9yfS4ke3ZlcnNpb24ubWlub3J9LiR7dmVyc2lvbi5wYXRjaH1gO1xuICAgICAgLy8gU2VlIFBFUCA0NDA6IGh0dHBzOi8vd3d3LnB5dGhvbi5vcmcvZGV2L3BlcHMvcGVwLTA0NDAvI3ByZS1yZWxlYXNlc1xuICAgICAgc3dpdGNoIChsYWJlbCkge1xuICAgICAgICBjYXNlIFwiZGV2XCI6XG4gICAgICAgIGNhc2UgXCJwcmVcIjpcbiAgICAgICAgICByZXR1cm4gYCR7YmFzZVZlcnNpb259LmRldiR7c2VxdWVuY2V9YDsgLy8gUEVQIDQwNCBzZWUgZGV2ZWxvcG1lbnRhbCByZWxlYXNlIGFzIFguWS5kZXZOXG4gICAgICAgIGNhc2UgXCJhbHBoYVwiOlxuICAgICAgICAgIHJldHVybiBgJHtiYXNlVmVyc2lvbn1hJHtzZXF1ZW5jZX1gOyAvLyBQRVAgNDA0IHNlZSBhbHBoYSByZWxlYXNlIGFzIFguWWFOXG4gICAgICAgIGNhc2UgXCJiZXRhXCI6XG4gICAgICAgICAgcmV0dXJuIGAke2Jhc2VWZXJzaW9ufWIke3NlcXVlbmNlfWA7IC8vIFBFUCA0MDQgc2VlIGJldGEgcmVsZWFzZSBhcyBYLlliTlxuICAgICAgICBjYXNlIFwicmNcIjpcbiAgICAgICAgICByZXR1cm4gYCR7YmFzZVZlcnNpb259cmMke3NlcXVlbmNlfWA7IC8vIFBFUCA0MDQgc2VlIHJlbGVhc2UgY2FuZGlkYXRlIGFzIFguWXJjTlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgIGBVbmFibGUgdG8gbWFwIHByZXJlbGVhc2UgaWRlbnRpZmllciAoaW46ICR7YXNzZW1ibHlWZXJzaW9ufSkgdG8gcHl0aG9uLCBhcyBsYWJlbCAke2luc3BlY3QoXG4gICAgICAgICAgICAgIGxhYmVsXG4gICAgICAgICAgICApfSBpcyBub3QgbWFwcGVkIChvbmx5IFwiZGV2XCIsIFwicHJlXCIsIFwiYWxwaGFcIiwgXCJiZXRhXCIgYW5kIFwicmNcIiBhcmUpYFxuICAgICAgICAgICk7XG4gICAgICB9XG4gICAgY2FzZSBUYXJnZXROYW1lLkRPVE5FVDpcbiAgICBjYXNlIFRhcmdldE5hbWUuR086XG4gICAgY2FzZSBUYXJnZXROYW1lLkpBVkE6XG4gICAgY2FzZSBUYXJnZXROYW1lLkpBVkFTQ1JJUFQ6XG4gICAgICAvLyBOb3QgdG91Y2hpbmcgLSB0aGUgTlBNIHZlcnNpb24gbnVtYmVyIHNob3VsZCBiZSB1c2FibGUgYXMtaXNcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBhc3NlbWJseVZlcnNpb247XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzZW1hbnRpYyB2ZXJzaW9uIHJhbmdlIHRvIHRoZSBraW5kIG9mIGJyYWNrZXQgbm90YXRpb24gdXNlZCBieVxuICogTWF2ZW4gYW5kIE51R2V0LiBGb3IgZXhhbXBsZSwgdGhpcyB0dXJucyBgXjEuMi4zYCBpbnRvIGBbMS4yLjMsMi4wLjApYC5cbiAqXG4gKiBAcGFyYW0gc2VtdmVyUmFuZ2UgVGhlIHNlbWFudGljIHZlcnNpb24gcmFuZ2UgdG8gYmUgY29udmVydGVkLlxuICogQHBhcmFtIHN1ZmZpeCBBIHZlcnNpb24gc3VmZml4IHRvIGFwcGx5IHRvIHZlcnNpb25zIGluIHRoZSByZXN1bHRpbmcgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSBzZW12ZXIgV2hldGhlciB0aGUgdGFyZ2V0IHN1cHBvcnRzIGZ1bGwgc2VtYW50aWMgdmVyc2lvbmluZyAoaW5jbHVkaW5nXG4gKiAgICAgICAgICAgICAgIGAtMGAgYXMgdGhlIGxvd2VzdCBwb3NzaWJsZSBwcmVyZWxlYXNlIGlkZW50aWZpZXIpXG4gKlxuICogQHJldHVybnMgYSBicmFja2V0LW5vdGF0aW9uIHZlcnNpb24gcmFuZ2UuXG4gKi9cbmZ1bmN0aW9uIHRvQnJhY2tldE5vdGF0aW9uKFxuICBzZW12ZXJSYW5nZTogc3RyaW5nLFxuICBzdWZmaXg/OiBzdHJpbmcsXG4gIHtcbiAgICBzZW12ZXIgPSB0cnVlLFxuICAgIHRhcmdldCA9IFRhcmdldE5hbWUuSkFWQVNDUklQVCxcbiAgfTogeyBzZW12ZXI/OiBib29sZWFuOyB0YXJnZXQ/OiBUYXJnZXROYW1lIH0gPSB7fVxuKTogc3RyaW5nIHtcbiAgaWYgKHNlbXZlclJhbmdlID09PSBcIipcIikge1xuICAgIHNlbXZlclJhbmdlID0gXCI+PTAuMC4wXCI7XG4gIH1cblxuICBjb25zdCByYW5nZSA9IG5ldyBSYW5nZShzZW12ZXJSYW5nZSk7XG4gIGlmIChzZW12ZXJSYW5nZSA9PT0gcmFuZ2UucmFuZ2UpIHtcbiAgICByZXR1cm4gc2VtdmVyUmFuZ2U7XG4gIH1cblxuICByZXR1cm4gcmFuZ2Uuc2V0XG4gICAgLm1hcCgoc2V0KSA9PiB7XG4gICAgICBpZiAoc2V0Lmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBjb25zdCB2ZXJzaW9uID0gc2V0WzBdLnNlbXZlci5yYXc7XG4gICAgICAgIGlmICghdmVyc2lvbiAmJiByYW5nZS5yYXcgPT09IFwiPj0wLjAuMFwiKSB7XG4gICAgICAgICAgLy8gQ2FzZSB3aGVyZSB2ZXJzaW9uIGlzICcqJ1xuICAgICAgICAgIHJldHVybiBcIlswLjAuMCwpXCI7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChzZXRbMF0ub3BlcmF0b3IgfHwgXCI9XCIpIHtcbiAgICAgICAgICAvLyBcIlt2ZXJzaW9uXVwiID0+IG1lYW5zIGV4YWN0bHkgdmVyc2lvblxuICAgICAgICAgIGNhc2UgXCI9XCI6XG4gICAgICAgICAgICByZXR1cm4gYFske2FkZFN1ZmZpeCh2ZXJzaW9uKX1dYDtcbiAgICAgICAgICAvLyBcIih2ZXJzaW9uLF1cIiA9PiBtZWFucyBncmVhdGVyIHRoYW4gdmVyc2lvblxuICAgICAgICAgIGNhc2UgXCI+XCI6XG4gICAgICAgICAgICByZXR1cm4gYCgke2FkZFN1ZmZpeCh2ZXJzaW9uKX0sKWA7XG4gICAgICAgICAgLy8gXCJbdmVyc2lvbixdXCIgPT4gbWVhbnMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoYXQgdmVyc2lvblxuICAgICAgICAgIGNhc2UgXCI+PVwiOlxuICAgICAgICAgICAgcmV0dXJuIGBbJHthZGRTdWZmaXgodmVyc2lvbil9LClgO1xuICAgICAgICAgIC8vIFwiWyx2ZXJzaW9uKVwiID0+IG1lYW5zIGxlc3MgdGhhbiB2ZXJzaW9uXG4gICAgICAgICAgY2FzZSBcIjxcIjpcbiAgICAgICAgICAgIHJldHVybiBgKCwke2FkZFN1ZmZpeCh2ZXJzaW9uLCAhc2VtdmVyKX0pYDtcbiAgICAgICAgICAvLyBcIlssdmVyc2lvbl1cIiA9PiBtZWFucyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdmVyc2lvblxuICAgICAgICAgIGNhc2UgXCI8PVwiOlxuICAgICAgICAgICAgcmV0dXJuIGAoLCR7YWRkU3VmZml4KHZlcnNpb24pfV1gO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNldC5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgY29uc3QgbnVnZXRSYW5nZSA9IHRvQnJhY2tldFJhbmdlKHNldFswXSwgc2V0WzFdKTtcbiAgICAgICAgaWYgKG51Z2V0UmFuZ2UpIHtcbiAgICAgICAgICByZXR1cm4gbnVnZXRSYW5nZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgVW5zdXBwb3J0ZWQgU2VtVmVyIHJhbmdlIHNldCBpbiAke3NlbXZlclJhbmdlfTogJHtzZXRcbiAgICAgICAgICAubWFwKChjb21wKSA9PiBjb21wLnZhbHVlKVxuICAgICAgICAgIC5qb2luKFwiLCBcIil9YFxuICAgICAgKTtcbiAgICB9KVxuICAgIC5qb2luKFwiLCBcIik7XG5cbiAgZnVuY3Rpb24gdG9CcmFja2V0UmFuZ2UoXG4gICAgbGVmdDogQ29tcGFyYXRvcixcbiAgICByaWdodDogQ29tcGFyYXRvclxuICApOiBzdHJpbmcgfCB1bmRlZmluZWQge1xuICAgIGlmIChsZWZ0Lm9wZXJhdG9yLnN0YXJ0c1dpdGgoXCI8XCIpICYmIHJpZ2h0Lm9wZXJhdG9yLnN0YXJ0c1dpdGgoXCI+XCIpKSB7XG4gICAgICAvLyBPcmRlciBpc24ndCBpZGVhbCwgc3dhcCBhcm91bmQuLlxuICAgICAgW2xlZnQsIHJpZ2h0XSA9IFtyaWdodCwgbGVmdF07XG4gICAgfVxuXG4gICAgLy8gV2l0aCBeMC4wLjAsIHNvbWVob3cgd2UgZ2V0IGEgbGVmdCBlbnRyeSB3aXRoIGFuIGVtcHR5IG9wZXJhdG9yIGFuZCB2YWx1ZSwgd2UnbGwgZml4IHRoaXMgdXBcbiAgICBpZiAobGVmdC5vcGVyYXRvciA9PT0gXCJcIiAmJiBsZWZ0LnZhbHVlID09PSBcIlwiKSB7XG4gICAgICBsZWZ0ID0gbmV3IENvbXBhcmF0b3IoXCI+PTAuMC4wXCIsIGxlZnQub3B0aW9ucyk7XG4gICAgfVxuXG4gICAgaWYgKCFsZWZ0Lm9wZXJhdG9yLnN0YXJ0c1dpdGgoXCI+XCIpIHx8ICFyaWdodC5vcGVyYXRvci5zdGFydHNXaXRoKFwiPFwiKSkge1xuICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHJhbmdlcyBkZWZpbmVkIGxpa2UgXCI+IChvciA+PSkgbGVmdCwgPCAob3IgPD0pIHJpZ2h0XCJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgY29uc3QgbGVmdEJyYWNlID0gbGVmdC5vcGVyYXRvci5lbmRzV2l0aChcIj1cIikgPyBcIltcIiA6IFwiKFwiO1xuICAgIGNvbnN0IHJpZ2h0QnJhY2UgPSByaWdodC5vcGVyYXRvci5lbmRzV2l0aChcIj1cIikgPyBcIl1cIiA6IFwiKVwiO1xuICAgIHJldHVybiBgJHtsZWZ0QnJhY2V9JHthZGRTdWZmaXgobGVmdC5zZW12ZXIucmF3KX0sJHthZGRTdWZmaXgoXG4gICAgICByaWdodC5zZW12ZXIucmF3LFxuICAgICAgcmlnaHQub3BlcmF0b3IgPT09IFwiPFwiICYmICFzZW12ZXJcbiAgICApfSR7cmlnaHRCcmFjZX1gO1xuICB9XG5cbiAgZnVuY3Rpb24gYWRkU3VmZml4KHN0cjogc3RyaW5nIHwgdW5kZWZpbmVkLCB0cmltRGFzaFplcm8gPSBmYWxzZSkge1xuICAgIGlmICghc3RyKSB7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgaWYgKHRyaW1EYXNoWmVybykge1xuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLy0wJC8sIFwiXCIpO1xuICAgIH1cbiAgICByZXR1cm4gc3VmZml4ID8gYCR7c3RyfSR7c3VmZml4fWAgOiB0b1JlbGVhc2VWZXJzaW9uKHN0ciwgdGFyZ2V0KTtcbiAgfVxufVxuIl19