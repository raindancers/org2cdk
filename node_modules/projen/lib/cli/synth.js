"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.synth = void 0;
const child_process_1 = require("child_process");
const fs = require("fs");
const os = require("os");
const path = require("path");
const common_1 = require("../common");
const logging = require("../logging");
const project_1 = require("../project");
const projenModule = path.dirname(require.resolve("../../package.json"));
async function synth(runtime, options) {
    const workdir = runtime.workdir;
    const rcfile = path.resolve(workdir, options.rcfile ?? common_1.PROJEN_RC); // TODO: support non javascript projenrc (e.g. java projects)
    // if --rc points to .projenrc.js, then behave as if it wasn't specified.
    if (rcfile === path.resolve(workdir, common_1.PROJEN_RC)) {
        delete options.rcfile;
    }
    // if there are no tasks, we assume this is not a projen project (modern
    // projects must at least have the "default" task).
    if (runtime.tasks.length === 0 && !fs.existsSync(rcfile)) {
        logging.error('Unable to find projen project. Use "projen new" to create a new project.');
        process.exit(1);
    }
    // run synth once
    const success = await trySynth();
    if (options.watch) {
        // if we are in watch mode, start the watch loop
        watchLoop();
    }
    else if (!success) {
        // make sure exit code is non-zero if we are not in watch mode
        process.exit(1);
    }
    async function trySynth() {
        // determine if post synthesis tasks should be executed (e.g. "yarn install").
        process.env.PROJEN_DISABLE_POST = (!options.post).toString();
        try {
            const defaultTask = runtime.tasks.find((t) => t.name === project_1.Project.DEFAULT_TASK);
            // if "--rc" is specified, ignore the default task
            if (defaultTask) {
                if (!options.rcfile) {
                    runtime.runTask(defaultTask.name);
                    return true;
                }
                else {
                    logging.warn("Default task skipped. Trying legacy synthesis since --rc is specified");
                }
            }
            // for backwards compatibility, if there is a .projenrc.js file, default to "node .projenrc.js"
            if (tryLegacySynth()) {
                return true;
            }
            throw new Error('Unable to find a task named "default"');
        }
        catch (e) {
            logging.error(`Synthesis failed: ${e.message}`);
            return false;
        }
    }
    function watchLoop() {
        logging.info(`Watching for changes in ${workdir}...`);
        const watch = fs.watch(workdir, { recursive: true });
        watch.on("change", (event) => {
            // we only care about "change" events
            if (event !== "change") {
                return;
            }
            process.stdout.write("\x1Bc"); // clear screen
            watch.close();
            trySynth()
                .then(() => watchLoop())
                .catch(() => watchLoop());
        });
    }
    function tryLegacySynth() {
        const rcdir = path.dirname(rcfile);
        if (!fs.existsSync(rcfile)) {
            return false;
        }
        // if node_modules/projen is not a directory or does not exist, create a
        // temporary symlink to the projen that we are currently running in order to
        // allow .projenrc.js to `require()` it.
        const nodeModules = path.resolve(rcdir, "node_modules");
        const projenModulePath = path.resolve(nodeModules, "projen");
        if (!fs.existsSync(path.join(projenModulePath, "package.json")) ||
            !fs.statSync(projenModulePath).isDirectory()) {
            fs.rmSync(projenModulePath, { force: true, recursive: true });
            fs.mkdirSync(nodeModules, { recursive: true });
            fs.symlinkSync(projenModule, projenModulePath, os.platform() === "win32" ? "junction" : null);
        }
        const ret = (0, child_process_1.spawnSync)(process.execPath, [rcfile], {
            stdio: ["inherit", "inherit", "pipe"],
        });
        if (ret.error) {
            throw new Error(`Synthesis failed: ${ret.error}`);
        }
        else if (ret.status !== 0) {
            logging.error(ret.stderr.toString());
            throw new Error(`Synthesis failed: calling "${process.execPath} ${rcfile}" exited with status=${ret.status}`);
        }
        return true;
    }
}
exports.synth = synth;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3ludGguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi9zcmMvY2xpL3N5bnRoLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLGlEQUEwQztBQUMxQyx5QkFBeUI7QUFDekIseUJBQXlCO0FBQ3pCLDZCQUE2QjtBQUM3QixzQ0FBc0M7QUFDdEMsc0NBQXNDO0FBQ3RDLHdDQUFxQztBQUdyQyxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsb0JBQW9CLENBQUMsQ0FBQyxDQUFDO0FBc0JsRSxLQUFLLFVBQVUsS0FBSyxDQUFDLE9BQW9CLEVBQUUsT0FBcUI7SUFDckUsTUFBTSxPQUFPLEdBQUcsT0FBTyxDQUFDLE9BQU8sQ0FBQztJQUNoQyxNQUFNLE1BQU0sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUMsTUFBTSxJQUFJLGtCQUFTLENBQUMsQ0FBQyxDQUFDLDZEQUE2RDtJQUVoSSx5RUFBeUU7SUFDekUsSUFBSSxNQUFNLEtBQUssSUFBSSxDQUFDLE9BQU8sQ0FBQyxPQUFPLEVBQUUsa0JBQVMsQ0FBQyxFQUFFO1FBQy9DLE9BQVEsT0FBZSxDQUFDLE1BQU0sQ0FBQztLQUNoQztJQUVELHdFQUF3RTtJQUN4RSxtREFBbUQ7SUFDbkQsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsVUFBVSxDQUFDLE1BQU0sQ0FBQyxFQUFFO1FBQ3hELE9BQU8sQ0FBQyxLQUFLLENBQ1gsMEVBQTBFLENBQzNFLENBQUM7UUFDRixPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2pCO0lBRUQsaUJBQWlCO0lBQ2pCLE1BQU0sT0FBTyxHQUFHLE1BQU0sUUFBUSxFQUFFLENBQUM7SUFFakMsSUFBSSxPQUFPLENBQUMsS0FBSyxFQUFFO1FBQ2pCLGdEQUFnRDtRQUNoRCxTQUFTLEVBQUUsQ0FBQztLQUNiO1NBQU0sSUFBSSxDQUFDLE9BQU8sRUFBRTtRQUNuQiw4REFBOEQ7UUFDOUQsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNqQjtJQUVELEtBQUssVUFBVSxRQUFRO1FBQ3JCLDhFQUE4RTtRQUM5RSxPQUFPLENBQUMsR0FBRyxDQUFDLG1CQUFtQixHQUFHLENBQUMsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDN0QsSUFBSTtZQUNGLE1BQU0sV0FBVyxHQUFHLE9BQU8sQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUNwQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLElBQUksS0FBSyxpQkFBTyxDQUFDLFlBQVksQ0FDdkMsQ0FBQztZQUVGLGtEQUFrRDtZQUNsRCxJQUFJLFdBQVcsRUFBRTtnQkFDZixJQUFJLENBQUMsT0FBTyxDQUFDLE1BQU0sRUFBRTtvQkFDbkIsT0FBTyxDQUFDLE9BQU8sQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLENBQUM7b0JBQ2xDLE9BQU8sSUFBSSxDQUFDO2lCQUNiO3FCQUFNO29CQUNMLE9BQU8sQ0FBQyxJQUFJLENBQ1YsdUVBQXVFLENBQ3hFLENBQUM7aUJBQ0g7YUFDRjtZQUVELCtGQUErRjtZQUMvRixJQUFJLGNBQWMsRUFBRSxFQUFFO2dCQUNwQixPQUFPLElBQUksQ0FBQzthQUNiO1lBRUQsTUFBTSxJQUFJLEtBQUssQ0FBQyx1Q0FBdUMsQ0FBQyxDQUFDO1NBQzFEO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixPQUFPLENBQUMsS0FBSyxDQUFDLHFCQUFzQixDQUFTLENBQUMsT0FBTyxFQUFFLENBQUMsQ0FBQztZQUN6RCxPQUFPLEtBQUssQ0FBQztTQUNkO0lBQ0gsQ0FBQztJQUVELFNBQVMsU0FBUztRQUNoQixPQUFPLENBQUMsSUFBSSxDQUFDLDJCQUEyQixPQUFPLEtBQUssQ0FBQyxDQUFDO1FBQ3RELE1BQU0sS0FBSyxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxFQUFFLEVBQUUsU0FBUyxFQUFFLElBQUksRUFBRSxDQUFDLENBQUM7UUFDckQsS0FBSyxDQUFDLEVBQUUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxLQUFLLEVBQUUsRUFBRTtZQUMzQixxQ0FBcUM7WUFDckMsSUFBSSxLQUFLLEtBQUssUUFBUSxFQUFFO2dCQUN0QixPQUFPO2FBQ1I7WUFFRCxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLGVBQWU7WUFDOUMsS0FBSyxDQUFDLEtBQUssRUFBRSxDQUFDO1lBQ2QsUUFBUSxFQUFFO2lCQUNQLElBQUksQ0FBQyxHQUFHLEVBQUUsQ0FBQyxTQUFTLEVBQUUsQ0FBQztpQkFDdkIsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDLFNBQVMsRUFBRSxDQUFDLENBQUM7UUFDOUIsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQsU0FBUyxjQUFjO1FBQ3JCLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUM7UUFFbkMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDMUIsT0FBTyxLQUFLLENBQUM7U0FDZDtRQUVELHdFQUF3RTtRQUN4RSw0RUFBNEU7UUFDNUUsd0NBQXdDO1FBQ3hDLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxFQUFFLGNBQWMsQ0FBQyxDQUFDO1FBQ3hELE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7UUFDN0QsSUFDRSxDQUFDLEVBQUUsQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxnQkFBZ0IsRUFBRSxjQUFjLENBQUMsQ0FBQztZQUMzRCxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsZ0JBQWdCLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFDNUM7WUFDQSxFQUFFLENBQUMsTUFBTSxDQUFDLGdCQUFnQixFQUFFLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFFLENBQUMsQ0FBQztZQUM5RCxFQUFFLENBQUMsU0FBUyxDQUFDLFdBQVcsRUFBRSxFQUFFLFNBQVMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1lBQy9DLEVBQUUsQ0FBQyxXQUFXLENBQ1osWUFBWSxFQUNaLGdCQUFnQixFQUNoQixFQUFFLENBQUMsUUFBUSxFQUFFLEtBQUssT0FBTyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FDOUMsQ0FBQztTQUNIO1FBRUQsTUFBTSxHQUFHLEdBQUcsSUFBQSx5QkFBUyxFQUFDLE9BQU8sQ0FBQyxRQUFRLEVBQUUsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUNoRCxLQUFLLEVBQUUsQ0FBQyxTQUFTLEVBQUUsU0FBUyxFQUFFLE1BQU0sQ0FBQztTQUN0QyxDQUFDLENBQUM7UUFDSCxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUU7WUFDYixNQUFNLElBQUksS0FBSyxDQUFDLHFCQUFxQixHQUFHLENBQUMsS0FBSyxFQUFFLENBQUMsQ0FBQztTQUNuRDthQUFNLElBQUksR0FBRyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDM0IsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsRUFBRSxDQUFDLENBQUM7WUFDckMsTUFBTSxJQUFJLEtBQUssQ0FDYiw4QkFBOEIsT0FBTyxDQUFDLFFBQVEsSUFBSSxNQUFNLHdCQUF3QixHQUFHLENBQUMsTUFBTSxFQUFFLENBQzdGLENBQUM7U0FDSDtRQUVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQztBQUNILENBQUM7QUFySEQsc0JBcUhDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc3Bhd25TeW5jIH0gZnJvbSBcImNoaWxkX3Byb2Nlc3NcIjtcbmltcG9ydCAqIGFzIGZzIGZyb20gXCJmc1wiO1xuaW1wb3J0ICogYXMgb3MgZnJvbSBcIm9zXCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyBQUk9KRU5fUkMgfSBmcm9tIFwiLi4vY29tbW9uXCI7XG5pbXBvcnQgKiBhcyBsb2dnaW5nIGZyb20gXCIuLi9sb2dnaW5nXCI7XG5pbXBvcnQgeyBQcm9qZWN0IH0gZnJvbSBcIi4uL3Byb2plY3RcIjtcbmltcG9ydCB7IFRhc2tSdW50aW1lIH0gZnJvbSBcIi4uL3Rhc2stcnVudGltZVwiO1xuXG5jb25zdCBwcm9qZW5Nb2R1bGUgPSBwYXRoLmRpcm5hbWUocmVxdWlyZS5yZXNvbHZlKFwiLi4vLi4vcGFja2FnZS5qc29uXCIpKTtcblxuZXhwb3J0IGludGVyZmFjZSBTeW50aE9wdGlvbnMge1xuICAvKipcbiAgICogRXhlY3V0ZSBwb3N0IHN5bnRoZXNpcyBjb21tYW5kcy5cbiAgICogQGRlZmF1bHQgdHJ1ZVxuICAgKi9cbiAgcmVhZG9ubHkgcG9zdD86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFN0YXJ0IHdhdGNoaW5nIC5wcm9qZW5yYy5qcyBhbmQgcmUtc3ludGggd2hlbiBjaGFuZ2VkLlxuICAgKiBAZGVmYXVsdCBmYWxzZVxuICAgKi9cbiAgcmVhZG9ubHkgd2F0Y2g/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBUaGUgbmFtZSBvZiB0aGUgLnByb2plbnJjLmpzIGZpbGUgIHRvIHVzZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0LlxuICAgKiBAZGVmYXVsdCBcIi5wcm9qZW5yYy5qc1wiXG4gICAqL1xuICByZWFkb25seSByY2ZpbGU/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzeW50aChydW50aW1lOiBUYXNrUnVudGltZSwgb3B0aW9uczogU3ludGhPcHRpb25zKSB7XG4gIGNvbnN0IHdvcmtkaXIgPSBydW50aW1lLndvcmtkaXI7XG4gIGNvbnN0IHJjZmlsZSA9IHBhdGgucmVzb2x2ZSh3b3JrZGlyLCBvcHRpb25zLnJjZmlsZSA/PyBQUk9KRU5fUkMpOyAvLyBUT0RPOiBzdXBwb3J0IG5vbiBqYXZhc2NyaXB0IHByb2plbnJjIChlLmcuIGphdmEgcHJvamVjdHMpXG5cbiAgLy8gaWYgLS1yYyBwb2ludHMgdG8gLnByb2plbnJjLmpzLCB0aGVuIGJlaGF2ZSBhcyBpZiBpdCB3YXNuJ3Qgc3BlY2lmaWVkLlxuICBpZiAocmNmaWxlID09PSBwYXRoLnJlc29sdmUod29ya2RpciwgUFJPSkVOX1JDKSkge1xuICAgIGRlbGV0ZSAob3B0aW9ucyBhcyBhbnkpLnJjZmlsZTtcbiAgfVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBubyB0YXNrcywgd2UgYXNzdW1lIHRoaXMgaXMgbm90IGEgcHJvamVuIHByb2plY3QgKG1vZGVyblxuICAvLyBwcm9qZWN0cyBtdXN0IGF0IGxlYXN0IGhhdmUgdGhlIFwiZGVmYXVsdFwiIHRhc2spLlxuICBpZiAocnVudGltZS50YXNrcy5sZW5ndGggPT09IDAgJiYgIWZzLmV4aXN0c1N5bmMocmNmaWxlKSkge1xuICAgIGxvZ2dpbmcuZXJyb3IoXG4gICAgICAnVW5hYmxlIHRvIGZpbmQgcHJvamVuIHByb2plY3QuIFVzZSBcInByb2plbiBuZXdcIiB0byBjcmVhdGUgYSBuZXcgcHJvamVjdC4nXG4gICAgKTtcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cblxuICAvLyBydW4gc3ludGggb25jZVxuICBjb25zdCBzdWNjZXNzID0gYXdhaXQgdHJ5U3ludGgoKTtcblxuICBpZiAob3B0aW9ucy53YXRjaCkge1xuICAgIC8vIGlmIHdlIGFyZSBpbiB3YXRjaCBtb2RlLCBzdGFydCB0aGUgd2F0Y2ggbG9vcFxuICAgIHdhdGNoTG9vcCgpO1xuICB9IGVsc2UgaWYgKCFzdWNjZXNzKSB7XG4gICAgLy8gbWFrZSBzdXJlIGV4aXQgY29kZSBpcyBub24temVybyBpZiB3ZSBhcmUgbm90IGluIHdhdGNoIG1vZGVcbiAgICBwcm9jZXNzLmV4aXQoMSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiB0cnlTeW50aCgpIHtcbiAgICAvLyBkZXRlcm1pbmUgaWYgcG9zdCBzeW50aGVzaXMgdGFza3Mgc2hvdWxkIGJlIGV4ZWN1dGVkIChlLmcuIFwieWFybiBpbnN0YWxsXCIpLlxuICAgIHByb2Nlc3MuZW52LlBST0pFTl9ESVNBQkxFX1BPU1QgPSAoIW9wdGlvbnMucG9zdCkudG9TdHJpbmcoKTtcbiAgICB0cnkge1xuICAgICAgY29uc3QgZGVmYXVsdFRhc2sgPSBydW50aW1lLnRhc2tzLmZpbmQoXG4gICAgICAgICh0KSA9PiB0Lm5hbWUgPT09IFByb2plY3QuREVGQVVMVF9UQVNLXG4gICAgICApO1xuXG4gICAgICAvLyBpZiBcIi0tcmNcIiBpcyBzcGVjaWZpZWQsIGlnbm9yZSB0aGUgZGVmYXVsdCB0YXNrXG4gICAgICBpZiAoZGVmYXVsdFRhc2spIHtcbiAgICAgICAgaWYgKCFvcHRpb25zLnJjZmlsZSkge1xuICAgICAgICAgIHJ1bnRpbWUucnVuVGFzayhkZWZhdWx0VGFzay5uYW1lKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsb2dnaW5nLndhcm4oXG4gICAgICAgICAgICBcIkRlZmF1bHQgdGFzayBza2lwcGVkLiBUcnlpbmcgbGVnYWN5IHN5bnRoZXNpcyBzaW5jZSAtLXJjIGlzIHNwZWNpZmllZFwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHksIGlmIHRoZXJlIGlzIGEgLnByb2plbnJjLmpzIGZpbGUsIGRlZmF1bHQgdG8gXCJub2RlIC5wcm9qZW5yYy5qc1wiXG4gICAgICBpZiAodHJ5TGVnYWN5U3ludGgoKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBhIHRhc2sgbmFtZWQgXCJkZWZhdWx0XCInKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dnaW5nLmVycm9yKGBTeW50aGVzaXMgZmFpbGVkOiAkeyhlIGFzIGFueSkubWVzc2FnZX1gKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB3YXRjaExvb3AoKSB7XG4gICAgbG9nZ2luZy5pbmZvKGBXYXRjaGluZyBmb3IgY2hhbmdlcyBpbiAke3dvcmtkaXJ9Li4uYCk7XG4gICAgY29uc3Qgd2F0Y2ggPSBmcy53YXRjaCh3b3JrZGlyLCB7IHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICB3YXRjaC5vbihcImNoYW5nZVwiLCAoZXZlbnQpID0+IHtcbiAgICAgIC8vIHdlIG9ubHkgY2FyZSBhYm91dCBcImNoYW5nZVwiIGV2ZW50c1xuICAgICAgaWYgKGV2ZW50ICE9PSBcImNoYW5nZVwiKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoXCJcXHgxQmNcIik7IC8vIGNsZWFyIHNjcmVlblxuICAgICAgd2F0Y2guY2xvc2UoKTtcbiAgICAgIHRyeVN5bnRoKClcbiAgICAgICAgLnRoZW4oKCkgPT4gd2F0Y2hMb29wKCkpXG4gICAgICAgIC5jYXRjaCgoKSA9PiB3YXRjaExvb3AoKSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiB0cnlMZWdhY3lTeW50aCgpIHtcbiAgICBjb25zdCByY2RpciA9IHBhdGguZGlybmFtZShyY2ZpbGUpO1xuXG4gICAgaWYgKCFmcy5leGlzdHNTeW5jKHJjZmlsZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBpZiBub2RlX21vZHVsZXMvcHJvamVuIGlzIG5vdCBhIGRpcmVjdG9yeSBvciBkb2VzIG5vdCBleGlzdCwgY3JlYXRlIGFcbiAgICAvLyB0ZW1wb3Jhcnkgc3ltbGluayB0byB0aGUgcHJvamVuIHRoYXQgd2UgYXJlIGN1cnJlbnRseSBydW5uaW5nIGluIG9yZGVyIHRvXG4gICAgLy8gYWxsb3cgLnByb2plbnJjLmpzIHRvIGByZXF1aXJlKClgIGl0LlxuICAgIGNvbnN0IG5vZGVNb2R1bGVzID0gcGF0aC5yZXNvbHZlKHJjZGlyLCBcIm5vZGVfbW9kdWxlc1wiKTtcbiAgICBjb25zdCBwcm9qZW5Nb2R1bGVQYXRoID0gcGF0aC5yZXNvbHZlKG5vZGVNb2R1bGVzLCBcInByb2plblwiKTtcbiAgICBpZiAoXG4gICAgICAhZnMuZXhpc3RzU3luYyhwYXRoLmpvaW4ocHJvamVuTW9kdWxlUGF0aCwgXCJwYWNrYWdlLmpzb25cIikpIHx8XG4gICAgICAhZnMuc3RhdFN5bmMocHJvamVuTW9kdWxlUGF0aCkuaXNEaXJlY3RvcnkoKVxuICAgICkge1xuICAgICAgZnMucm1TeW5jKHByb2plbk1vZHVsZVBhdGgsIHsgZm9yY2U6IHRydWUsIHJlY3Vyc2l2ZTogdHJ1ZSB9KTtcbiAgICAgIGZzLm1rZGlyU3luYyhub2RlTW9kdWxlcywgeyByZWN1cnNpdmU6IHRydWUgfSk7XG4gICAgICBmcy5zeW1saW5rU3luYyhcbiAgICAgICAgcHJvamVuTW9kdWxlLFxuICAgICAgICBwcm9qZW5Nb2R1bGVQYXRoLFxuICAgICAgICBvcy5wbGF0Zm9ybSgpID09PSBcIndpbjMyXCIgPyBcImp1bmN0aW9uXCIgOiBudWxsXG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJldCA9IHNwYXduU3luYyhwcm9jZXNzLmV4ZWNQYXRoLCBbcmNmaWxlXSwge1xuICAgICAgc3RkaW86IFtcImluaGVyaXRcIiwgXCJpbmhlcml0XCIsIFwicGlwZVwiXSxcbiAgICB9KTtcbiAgICBpZiAocmV0LmVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFN5bnRoZXNpcyBmYWlsZWQ6ICR7cmV0LmVycm9yfWApO1xuICAgIH0gZWxzZSBpZiAocmV0LnN0YXR1cyAhPT0gMCkge1xuICAgICAgbG9nZ2luZy5lcnJvcihyZXQuc3RkZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgU3ludGhlc2lzIGZhaWxlZDogY2FsbGluZyBcIiR7cHJvY2Vzcy5leGVjUGF0aH0gJHtyY2ZpbGV9XCIgZXhpdGVkIHdpdGggc3RhdHVzPSR7cmV0LnN0YXR1c31gXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG4iXX0=