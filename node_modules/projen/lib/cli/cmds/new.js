"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const semver = require("semver");
const yargs = require("yargs");
const inventory = require("../../inventory");
const logging = require("../../logging");
const option_hints_1 = require("../../option-hints");
const projects_1 = require("../../projects");
const util_1 = require("../../util");
const macros_1 = require("../macros");
const util_2 = require("../util");
class Command {
    constructor() {
        this.command = "new [PROJECT-TYPE-NAME] [OPTIONS]";
        this.describe = "Creates a new projen project";
    }
    builder(args) {
        args.positional("PROJECT-TYPE-NAME", {
            describe: "optional only when --from is used and there is a single project type in the external module",
            type: "string",
        });
        args.option("synth", {
            type: "boolean",
            default: true,
            desc: "Synthesize after creating .projenrc.js",
        });
        args.option("comments", {
            type: "boolean",
            default: true,
            desc: "Include commented out options in .projenrc.js (use --no-comments to disable)",
        });
        args.option("from", {
            type: "string",
            alias: "f",
            desc: 'External jsii npm module to create project from. Supports any package spec supported by npm (such as "my-pack@^2.0")',
        });
        args.option("git", {
            type: "boolean",
            default: true,
            desc: "Run `git init` and create an initial commit (use --no-git to disable)",
        });
        args.example("projen new awscdk-app-ts", 'Creates a new project of built-in type "awscdk-app-ts"');
        args.example("projen new --from projen-vue@^2", 'Creates a new project from an external module "projen-vue" with the specified version');
        for (const type of inventory.discover()) {
            args.command(type.pjid, type.docs ?? "", {
                builder: (cargs) => {
                    cargs.showHelpOnFail(false);
                    for (const option of type.options ?? []) {
                        // not all types can be represented in the cli
                        if (!argTypeSupported(option)) {
                            continue;
                        }
                        const defaultValue = argInitialValue(option);
                        cargs.option(option.switch, {
                            group: !option.optional ? "Required:" : "Optional:",
                            type: argType(option),
                            description: argDesc(option),
                            required: !option.optional,
                            // yargs behaves differently for arrays if the defaultValue property is present or not
                            ...(!option.optional && defaultValue
                                ? { default: defaultValue }
                                : {}),
                        });
                    }
                    return cargs;
                },
                handler: (argv) => initProject(process.cwd(), type, argv),
            });
        }
        // Disable strict mode, otherwise the catch-all doesn't work
        args.strictCommands(false);
        args
            .command({
            command: "*",
            describe: false,
            handler,
        })
            .middleware((argv) => {
            // manually set the matched command as the project type
            argv.projectTypeName = argv._[1];
        }, true);
        return args;
    }
    async handler(args) {
        return handler(args);
    }
}
async function handler(args) {
    try {
        // handle --from which means we want to first install a jsii module and then
        // create a project defined within this module.
        if (args.from) {
            return await initProjectFromModule(process.cwd(), args.from, args);
        }
        // project type is defined but was not matched by yargs, so print the list of supported types
        if (args.projectTypeName) {
            const types = inventory.discover();
            throw new util_2.CliError(`Project type "${args.projectTypeName}" not found. Available types:\n`, ...types.map((t) => `    ${t.pjid}`), "", `Please specify a project type.`, `Example: npx projen new ${types[0].pjid}`);
        }
        // Handles the use case that nothing was specified since PROJECT-TYPE is now an optional positional parameter
        yargs.showHelp();
    }
    catch (error) {
        if (error instanceof util_2.CliError) {
            logging.error(error.message);
            logging.empty();
            process.exitCode = 1;
            return;
        }
        // unknown error, likely a node runtime exception in project code
        // rethrow so the full stack trace is displayed
        throw error;
    }
}
/**
 * Returns the yargs option type for a given project option
 */
function argType(option) {
    if (option.kind === "enum") {
        return "string";
    }
    if (isPrimitiveArrayOption(option)) {
        return "array";
    }
    return option.simpleType;
}
/**
 * Returns the description for a given project option
 */
function argDesc(option) {
    let desc = [option.docs?.replace(/\ *\.$/, "") ?? ""];
    const helpDefault = option.initialValue ?? option.default;
    if (option.optional && helpDefault) {
        desc.push(`[default: ${helpDefault.replace(/^\ *-/, "").replace(/\.$/, "").trim()}]`);
    }
    return desc.join(" ");
}
/**
 * Compute the initial value for a given project option
 */
function argInitialValue(option, cwd = process.cwd()) {
    // if we have determined an initial value for the field
    // we can show that value in --help
    if (option.initialValue) {
        return renderDefault(cwd, option.initialValue);
    }
}
/**
 * Currently we only support these field types as command line options:
 * - primitives (string, number, boolean)
 * - lists of primitives
 * - enums
 */
function argTypeSupported(option) {
    return (option.simpleType === "string" ||
        option.simpleType === "number" ||
        option.simpleType === "boolean" ||
        option.kind === "enum" ||
        isPrimitiveArrayOption(option));
}
/**
 * Checks if the given option is a primitive array
 */
function isPrimitiveArrayOption(option) {
    return Boolean(option.jsonLike &&
        option.fullType.collection?.kind === "array" &&
        option.fullType.collection.elementtype.primitive &&
        ["string", "number"].includes(option.fullType.collection.elementtype.primitive));
}
/**
 * Given a value from "@default", processes macros and returns a stringified
 * (quoted) result.
 *
 * @returns a javascript primitive (could be a string, number or boolean)
 */
function renderDefault(cwd, value) {
    return (0, macros_1.tryProcessMacro)(cwd, value) ?? JSON.parse(value);
}
/**
 * Converts yargs command line switches to project type props.
 * @param type Project type
 * @param argv Command line switches
 */
function commandLineToProps(cwd, type, argv) {
    const props = {};
    // initialize props with default values
    for (const prop of type.options) {
        props[prop.name] = argInitialValue(prop, cwd);
    }
    for (const [arg, value] of Object.entries(argv)) {
        for (const prop of type.options) {
            if (prop.switch === arg) {
                let curr = props;
                const queue = [...prop.path];
                while (true) {
                    const p = queue.shift();
                    if (!p) {
                        break;
                    }
                    if (queue.length === 0) {
                        curr[p] = value;
                    }
                    else {
                        curr[p] = curr[p] ?? {};
                        curr = curr[p];
                    }
                }
            }
        }
    }
    return props;
}
/**
 * Generates a new project from an external module.
 *
 * @param spec The name of the external module to load
 * @param args Command line arguments (incl. project type)
 */
async function initProjectFromModule(baseDir, spec, args) {
    const projenVersion = args.projenVersion ?? "latest";
    const installCommand = (0, util_2.renderInstallCommand)(baseDir, `projen@${projenVersion}`);
    if (args.projenVersion) {
        (0, util_1.exec)(installCommand, { cwd: baseDir });
    }
    else {
        // do not overwrite existing installation
        (0, util_1.exec)(`npm ls --prefix="${baseDir}" --depth=0 --pattern projen || ${installCommand}`, { cwd: baseDir });
    }
    const moduleName = (0, util_2.installPackage)(baseDir, spec);
    logging.empty();
    // Find the just installed package and discover the rest recursively from this package folder
    const moduleDir = path.dirname(require.resolve(`${moduleName}/.jsii`, {
        paths: [baseDir],
    }));
    // Only leave projects from the main (requested) package
    const projects = inventory
        .discover(moduleDir)
        .filter((x) => x.moduleName === moduleName); // Only list project types from the requested 'from' module
    if (projects.length < 1) {
        throw new util_2.CliError(`No project types found after installing "${spec}". The module must export at least one class which extends "projen.Project".`);
    }
    const requested = args.projectTypeName;
    const types = projects.map((p) => p.pjid);
    // if user did not specify a project type but the module has more than one, we need them to tell us which one...
    if (!requested && projects.length > 1) {
        throw new util_2.CliError(`Multiple project types found after installing "${spec}":\n`, ...types.map((t) => `    ${t}`), "", `Please specify a project type.`, `Example: npx projen new --from ${spec} ${types[0]}`);
    }
    // if user did not specify a type (and we know we have only one), the select it. otherwise, search by pjid.
    const type = !requested
        ? projects[0]
        : projects.find((p) => p.pjid === requested);
    if (!type) {
        throw new util_2.CliError(`Project type "${requested}" not found in "${spec}". Found:\n`, ...types.map((t) => `    ${t}`), "", `Please specify a valid project type.`, `Example: npx projen new --from ${spec} ${types[0]}`);
    }
    const missingOptions = [];
    for (const option of type.options ?? []) {
        // not all types can be represented in the cli
        if (!argTypeSupported(option)) {
            continue;
        }
        // parse allowed types
        if (args[option.name] !== undefined) {
            args[option.name] = parseArg(args[option.name], argType(option), option);
            args[option.switch] = args[option.name];
            continue;
        }
        // Required option with a default
        if (!option.optional && option.default && option.default !== "undefined") {
            const defaultValue = renderDefault(baseDir, option.default);
            args[option.name] = defaultValue;
            args[option.switch] = defaultValue;
        }
        // Required option, but we could not find a value
        if (!option.optional && !args[option.name]) {
            missingOptions.push(`--${option.switch} [${argType(option)}] ${argDesc(option)}`);
        }
    }
    // We are missing some required options
    if (missingOptions.length) {
        throw new util_2.CliError(`Cannot create "${type.fqn}". Missing required option${missingOptions.length > 1 ? "s" : ""}:`, ...missingOptions.map((m) => `    ${m}`));
    }
    // include a dev dependency for the external module
    args.devDeps = [spec];
    args["dev-deps"] = [spec];
    await initProject(baseDir, type, args);
}
/**
 * Parse command line value as option type
 */
function parseArg(value, type, option) {
    switch (type) {
        case "number":
            return parseInt(value);
        case "boolean":
            return typeof value === "string" ? (0, util_1.isTruthy)(value) : value;
        case "array":
            if (!Array.isArray(value)) {
                value = [value];
            }
            return value.map((v) => parseArg(v, option?.fullType.collection?.elementtype.primitive || "string"));
        // return value unchanged
        case "string":
        default:
            // if we have an unexpected array, use the first element
            if (Array.isArray(value)) {
                return value[0];
            }
            return value;
    }
}
/**
 * Generates a new project.
 * @param type Project type
 * @param args Command line arguments
 * @param additionalProps Additional parameters to include in .projenrc.js
 */
async function initProject(baseDir, type, args) {
    // convert command line arguments to project props using type information
    const props = commandLineToProps(baseDir, type, args);
    projects_1.Projects.createProject({
        dir: props.outdir ?? baseDir,
        projectFqn: type.fqn,
        projectOptions: props,
        optionHints: args.comments
            ? option_hints_1.InitProjectOptionHints.FEATURED
            : option_hints_1.InitProjectOptionHints.NONE,
        synth: args.synth,
        post: args.post,
    });
    if (fs.existsSync(path.join(baseDir, "package.json")) && args.post) {
        (0, util_1.exec)("npm run eslint --if-present", { cwd: baseDir });
    }
    if (args.git) {
        const git = (cmd) => (0, util_1.exec)(`git ${cmd}`, { cwd: baseDir });
        const gitversion = (0, util_1.getGitVersion)((0, util_1.execCapture)("git --version", { cwd: baseDir }).toString());
        logging.debug("system using git version ", gitversion);
        if (gitversion && semver.gte(gitversion, "2.28.0")) {
            git("init -b main");
            git("add .");
            git('commit --allow-empty -m "chore: project created with projen"');
            logging.debug("default branch name set to main");
        }
        else {
            git("init");
            git("add .");
            git('commit --allow-empty -m "chore: project created with projen"');
            logging.debug("older version of git detected, changed default branch name to main");
            git("branch -M main");
        }
    }
}
exports.default = new Command();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmV3LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NsaS9jbWRzL25ldy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLHlCQUF5QjtBQUN6Qiw2QkFBNkI7QUFDN0IsaUNBQWlDO0FBQ2pDLCtCQUErQjtBQUMvQiw2Q0FBNkM7QUFDN0MseUNBQXlDO0FBQ3pDLHFEQUE0RDtBQUM1RCw2Q0FBMEM7QUFDMUMscUNBQXdFO0FBQ3hFLHNDQUE0QztBQUM1QyxrQ0FBeUU7QUFFekUsTUFBTSxPQUFPO0lBQWI7UUFDa0IsWUFBTyxHQUFHLG1DQUFtQyxDQUFDO1FBQzlDLGFBQVEsR0FBRyw4QkFBOEIsQ0FBQztJQXNGNUQsQ0FBQztJQXBGUSxPQUFPLENBQUMsSUFBZ0I7UUFDN0IsSUFBSSxDQUFDLFVBQVUsQ0FBQyxtQkFBbUIsRUFBRTtZQUNuQyxRQUFRLEVBQ04sNkZBQTZGO1lBQy9GLElBQUksRUFBRSxRQUFRO1NBQ2YsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUU7WUFDbkIsSUFBSSxFQUFFLFNBQVM7WUFDZixPQUFPLEVBQUUsSUFBSTtZQUNiLElBQUksRUFBRSx3Q0FBd0M7U0FDL0MsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLE1BQU0sQ0FBQyxVQUFVLEVBQUU7WUFDdEIsSUFBSSxFQUFFLFNBQVM7WUFDZixPQUFPLEVBQUUsSUFBSTtZQUNiLElBQUksRUFBRSw4RUFBOEU7U0FDckYsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUU7WUFDbEIsSUFBSSxFQUFFLFFBQVE7WUFDZCxLQUFLLEVBQUUsR0FBRztZQUNWLElBQUksRUFBRSxzSEFBc0g7U0FDN0gsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUFLLEVBQUU7WUFDakIsSUFBSSxFQUFFLFNBQVM7WUFDZixPQUFPLEVBQUUsSUFBSTtZQUNiLElBQUksRUFBRSx1RUFBdUU7U0FDOUUsQ0FBQyxDQUFDO1FBQ0gsSUFBSSxDQUFDLE9BQU8sQ0FDViwwQkFBMEIsRUFDMUIsd0RBQXdELENBQ3pELENBQUM7UUFDRixJQUFJLENBQUMsT0FBTyxDQUNWLGlDQUFpQyxFQUNqQyx1RkFBdUYsQ0FDeEYsQ0FBQztRQUVGLEtBQUssTUFBTSxJQUFJLElBQUksU0FBUyxDQUFDLFFBQVEsRUFBRSxFQUFFO1lBQ3ZDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsSUFBSSxJQUFJLEVBQUUsRUFBRTtnQkFDdkMsT0FBTyxFQUFFLENBQUMsS0FBSyxFQUFFLEVBQUU7b0JBQ2pCLEtBQUssQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBRTVCLEtBQUssTUFBTSxNQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxFQUFFLEVBQUU7d0JBQ3ZDLDhDQUE4Qzt3QkFDOUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxFQUFFOzRCQUM3QixTQUFTO3lCQUNWO3dCQUVELE1BQU0sWUFBWSxHQUFHLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQzt3QkFDN0MsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFOzRCQUMxQixLQUFLLEVBQUUsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLENBQUMsQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDLFdBQVc7NEJBQ25ELElBQUksRUFBRSxPQUFPLENBQUMsTUFBTSxDQUFDOzRCQUNyQixXQUFXLEVBQUUsT0FBTyxDQUFDLE1BQU0sQ0FBQzs0QkFDNUIsUUFBUSxFQUFFLENBQUMsTUFBTSxDQUFDLFFBQVE7NEJBQzFCLHNGQUFzRjs0QkFDdEYsR0FBRyxDQUFDLENBQUMsTUFBTSxDQUFDLFFBQVEsSUFBSSxZQUFZO2dDQUNsQyxDQUFDLENBQUMsRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFFO2dDQUMzQixDQUFDLENBQUMsRUFBRSxDQUFDO3lCQUNSLENBQUMsQ0FBQztxQkFDSjtvQkFFRCxPQUFPLEtBQUssQ0FBQztnQkFDZixDQUFDO2dCQUNELE9BQU8sRUFBRSxDQUFDLElBQUksRUFBRSxFQUFFLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxHQUFHLEVBQUUsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDO2FBQzFELENBQUMsQ0FBQztTQUNKO1FBRUQsNERBQTREO1FBQzVELElBQUksQ0FBQyxjQUFjLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDM0IsSUFBSTthQUNELE9BQU8sQ0FBQztZQUNQLE9BQU8sRUFBRSxHQUFHO1lBQ1osUUFBUSxFQUFFLEtBQUs7WUFDZixPQUFPO1NBQ1IsQ0FBQzthQUNELFVBQVUsQ0FBQyxDQUFDLElBQUksRUFBRSxFQUFFO1lBQ25CLHVEQUF1RDtZQUN2RCxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDbkMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRVgsT0FBTyxJQUFJLENBQUM7SUFDZCxDQUFDO0lBRU0sS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFTO1FBQzVCLE9BQU8sT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ3ZCLENBQUM7Q0FDRjtBQUVELEtBQUssVUFBVSxPQUFPLENBQUMsSUFBUztJQUM5QixJQUFJO1FBQ0YsNEVBQTRFO1FBQzVFLCtDQUErQztRQUMvQyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7WUFDYixPQUFPLE1BQU0scUJBQXFCLENBQUMsT0FBTyxDQUFDLEdBQUcsRUFBRSxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUM7U0FDcEU7UUFFRCw2RkFBNkY7UUFDN0YsSUFBSSxJQUFJLENBQUMsZUFBZSxFQUFFO1lBQ3hCLE1BQU0sS0FBSyxHQUFHLFNBQVMsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUNuQyxNQUFNLElBQUksZUFBUSxDQUNoQixpQkFBaUIsSUFBSSxDQUFDLGVBQWUsaUNBQWlDLEVBQ3RFLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsT0FBTyxDQUFDLENBQUMsSUFBSSxFQUFFLENBQUMsRUFDcEMsRUFBRSxFQUNGLGdDQUFnQyxFQUNoQywyQkFBMkIsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUMzQyxDQUFDO1NBQ0g7UUFFRCw2R0FBNkc7UUFDN0csS0FBSyxDQUFDLFFBQVEsRUFBRSxDQUFDO0tBQ2xCO0lBQUMsT0FBTyxLQUFjLEVBQUU7UUFDdkIsSUFBSSxLQUFLLFlBQVksZUFBUSxFQUFFO1lBQzdCLE9BQU8sQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1lBQzdCLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQztZQUNoQixPQUFPLENBQUMsUUFBUSxHQUFHLENBQUMsQ0FBQztZQUNyQixPQUFPO1NBQ1I7UUFFRCxpRUFBaUU7UUFDakUsK0NBQStDO1FBQy9DLE1BQU0sS0FBSyxDQUFDO0tBQ2I7QUFDSCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxTQUFTLE9BQU8sQ0FDZCxNQUErQjtJQUUvQixJQUFJLE1BQU0sQ0FBQyxJQUFJLEtBQUssTUFBTSxFQUFFO1FBQzFCLE9BQU8sUUFBUSxDQUFDO0tBQ2pCO0lBRUQsSUFBSSxzQkFBc0IsQ0FBQyxNQUFNLENBQUMsRUFBRTtRQUNsQyxPQUFPLE9BQU8sQ0FBQztLQUNoQjtJQUVELE9BQU8sTUFBTSxDQUFDLFVBQTZDLENBQUM7QUFDOUQsQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxPQUFPLENBQUMsTUFBK0I7SUFDOUMsSUFBSSxJQUFJLEdBQUcsQ0FBQyxNQUFNLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQyxRQUFRLEVBQUUsRUFBRSxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7SUFFdEQsTUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLFlBQVksSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDO0lBQzFELElBQUksTUFBTSxDQUFDLFFBQVEsSUFBSSxXQUFXLEVBQUU7UUFDbEMsSUFBSSxDQUFDLElBQUksQ0FDUCxhQUFhLFdBQVcsQ0FBQyxPQUFPLENBQUMsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDLE9BQU8sQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FDM0UsQ0FBQztLQUNIO0lBRUQsT0FBTyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBQ3hCLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsZUFBZSxDQUN0QixNQUErQixFQUMvQixHQUFHLEdBQUcsT0FBTyxDQUFDLEdBQUcsRUFBRTtJQUVuQix1REFBdUQ7SUFDdkQsbUNBQW1DO0lBQ25DLElBQUksTUFBTSxDQUFDLFlBQVksRUFBRTtRQUN2QixPQUFPLGFBQWEsQ0FBQyxHQUFHLEVBQUUsTUFBTSxDQUFDLFlBQVksQ0FBQyxDQUFDO0tBQ2hEO0FBQ0gsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBUyxnQkFBZ0IsQ0FBQyxNQUErQjtJQUN2RCxPQUFPLENBQ0wsTUFBTSxDQUFDLFVBQVUsS0FBSyxRQUFRO1FBQzlCLE1BQU0sQ0FBQyxVQUFVLEtBQUssUUFBUTtRQUM5QixNQUFNLENBQUMsVUFBVSxLQUFLLFNBQVM7UUFDL0IsTUFBTSxDQUFDLElBQUksS0FBSyxNQUFNO1FBQ3RCLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUMvQixDQUFDO0FBQ0osQ0FBQztBQUVEOztHQUVHO0FBQ0gsU0FBUyxzQkFBc0IsQ0FBQyxNQUErQjtJQUM3RCxPQUFPLE9BQU8sQ0FDWixNQUFNLENBQUMsUUFBUTtRQUNiLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSxFQUFFLElBQUksS0FBSyxPQUFPO1FBQzVDLE1BQU0sQ0FBQyxRQUFRLENBQUMsVUFBVSxDQUFDLFdBQVcsQ0FBQyxTQUFTO1FBQ2hELENBQUMsUUFBUSxFQUFFLFFBQVEsQ0FBQyxDQUFDLFFBQVEsQ0FDM0IsTUFBTSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FDakQsQ0FDSixDQUFDO0FBQ0osQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBUyxhQUFhLENBQUMsR0FBVyxFQUFFLEtBQWE7SUFDL0MsT0FBTyxJQUFBLHdCQUFlLEVBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDMUQsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxTQUFTLGtCQUFrQixDQUN6QixHQUFXLEVBQ1gsSUFBMkIsRUFDM0IsSUFBNkI7SUFFN0IsTUFBTSxLQUFLLEdBQXdCLEVBQUUsQ0FBQztJQUV0Qyx1Q0FBdUM7SUFDdkMsS0FBSyxNQUFNLElBQUksSUFBSSxJQUFJLENBQUMsT0FBTyxFQUFFO1FBQy9CLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsZUFBZSxDQUFDLElBQUksRUFBRSxHQUFHLENBQUMsQ0FBQztLQUMvQztJQUVELEtBQUssTUFBTSxDQUFDLEdBQUcsRUFBRSxLQUFLLENBQUMsSUFBSSxNQUFNLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxFQUFFO1FBQy9DLEtBQUssTUFBTSxJQUFJLElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUMvQixJQUFJLElBQUksQ0FBQyxNQUFNLEtBQUssR0FBRyxFQUFFO2dCQUN2QixJQUFJLElBQUksR0FBRyxLQUFLLENBQUM7Z0JBQ2pCLE1BQU0sS0FBSyxHQUFHLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7Z0JBQzdCLE9BQU8sSUFBSSxFQUFFO29CQUNYLE1BQU0sQ0FBQyxHQUFHLEtBQUssQ0FBQyxLQUFLLEVBQUUsQ0FBQztvQkFDeEIsSUFBSSxDQUFDLENBQUMsRUFBRTt3QkFDTixNQUFNO3FCQUNQO29CQUNELElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7d0JBQ3RCLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxLQUFLLENBQUM7cUJBQ2pCO3lCQUFNO3dCQUNMLElBQUksQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksRUFBRSxDQUFDO3dCQUN4QixJQUFJLEdBQUcsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO3FCQUNoQjtpQkFDRjthQUNGO1NBQ0Y7S0FDRjtJQUVELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsS0FBSyxVQUFVLHFCQUFxQixDQUFDLE9BQWUsRUFBRSxJQUFZLEVBQUUsSUFBUztJQUMzRSxNQUFNLGFBQWEsR0FBRyxJQUFJLENBQUMsYUFBYSxJQUFJLFFBQVEsQ0FBQztJQUNyRCxNQUFNLGNBQWMsR0FBRyxJQUFBLDJCQUFvQixFQUN6QyxPQUFPLEVBQ1AsVUFBVSxhQUFhLEVBQUUsQ0FDMUIsQ0FBQztJQUNGLElBQUksSUFBSSxDQUFDLGFBQWEsRUFBRTtRQUN0QixJQUFBLFdBQUksRUFBQyxjQUFjLEVBQUUsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUN4QztTQUFNO1FBQ0wseUNBQXlDO1FBQ3pDLElBQUEsV0FBSSxFQUNGLG9CQUFvQixPQUFPLG1DQUFtQyxjQUFjLEVBQUUsRUFDOUUsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQ2pCLENBQUM7S0FDSDtJQUVELE1BQU0sVUFBVSxHQUFHLElBQUEscUJBQWMsRUFBQyxPQUFPLEVBQUUsSUFBSSxDQUFDLENBQUM7SUFDakQsT0FBTyxDQUFDLEtBQUssRUFBRSxDQUFDO0lBRWhCLDZGQUE2RjtJQUM3RixNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUM1QixPQUFPLENBQUMsT0FBTyxDQUFDLEdBQUcsVUFBVSxRQUFRLEVBQUU7UUFDckMsS0FBSyxFQUFFLENBQUMsT0FBTyxDQUFDO0tBQ2pCLENBQUMsQ0FDSCxDQUFDO0lBRUYsd0RBQXdEO0lBQ3hELE1BQU0sUUFBUSxHQUFHLFNBQVM7U0FDdkIsUUFBUSxDQUFDLFNBQVMsQ0FBQztTQUNuQixNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxVQUFVLEtBQUssVUFBVSxDQUFDLENBQUMsQ0FBQywyREFBMkQ7SUFFMUcsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUN2QixNQUFNLElBQUksZUFBUSxDQUNoQiw0Q0FBNEMsSUFBSSw4RUFBOEUsQ0FDL0gsQ0FBQztLQUNIO0lBRUQsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLGVBQWUsQ0FBQztJQUN2QyxNQUFNLEtBQUssR0FBRyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUM7SUFFMUMsZ0hBQWdIO0lBQ2hILElBQUksQ0FBQyxTQUFTLElBQUksUUFBUSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDckMsTUFBTSxJQUFJLGVBQVEsQ0FDaEIsa0RBQWtELElBQUksTUFBTSxFQUM1RCxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFDL0IsRUFBRSxFQUNGLGdDQUFnQyxFQUNoQyxrQ0FBa0MsSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUNyRCxDQUFDO0tBQ0g7SUFFRCwyR0FBMkc7SUFDM0csTUFBTSxJQUFJLEdBQUcsQ0FBQyxTQUFTO1FBQ3JCLENBQUMsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDO1FBQ2IsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssU0FBUyxDQUFDLENBQUM7SUFDL0MsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNULE1BQU0sSUFBSSxlQUFRLENBQ2hCLGlCQUFpQixTQUFTLG1CQUFtQixJQUFJLGFBQWEsRUFDOUQsR0FBRyxLQUFLLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxPQUFPLENBQUMsRUFBRSxDQUFDLEVBQy9CLEVBQUUsRUFDRixzQ0FBc0MsRUFDdEMsa0NBQWtDLElBQUksSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FDckQsQ0FBQztLQUNIO0lBRUQsTUFBTSxjQUFjLEdBQUcsRUFBRSxDQUFDO0lBRTFCLEtBQUssTUFBTSxNQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxFQUFFLEVBQUU7UUFDdkMsOENBQThDO1FBQzlDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUM3QixTQUFTO1NBQ1Y7UUFFRCxzQkFBc0I7UUFDdEIsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLFNBQVMsRUFBRTtZQUNuQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxHQUFHLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLE9BQU8sQ0FBQyxNQUFNLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQztZQUN6RSxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLENBQUM7WUFDeEMsU0FBUztTQUNWO1FBRUQsaUNBQWlDO1FBQ2pDLElBQUksQ0FBQyxNQUFNLENBQUMsUUFBUSxJQUFJLE1BQU0sQ0FBQyxPQUFPLElBQUksTUFBTSxDQUFDLE9BQU8sS0FBSyxXQUFXLEVBQUU7WUFDeEUsTUFBTSxZQUFZLEdBQUcsYUFBYSxDQUFDLE9BQU8sRUFBRSxNQUFNLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDNUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsR0FBRyxZQUFZLENBQUM7WUFDakMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsR0FBRyxZQUFZLENBQUM7U0FDcEM7UUFFRCxpREFBaUQ7UUFDakQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxRQUFRLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFO1lBQzFDLGNBQWMsQ0FBQyxJQUFJLENBQ2pCLEtBQUssTUFBTSxDQUFDLE1BQU0sS0FBSyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQUssT0FBTyxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQzdELENBQUM7U0FDSDtLQUNGO0lBRUQsdUNBQXVDO0lBQ3ZDLElBQUksY0FBYyxDQUFDLE1BQU0sRUFBRTtRQUN6QixNQUFNLElBQUksZUFBUSxDQUNoQixrQkFBa0IsSUFBSSxDQUFDLEdBQUcsNkJBQ3hCLGNBQWMsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQ3BDLEdBQUcsRUFDSCxHQUFHLGNBQWMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsQ0FDekMsQ0FBQztLQUNIO0lBRUQsbURBQW1EO0lBQ25ELElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN0QixJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUUxQixNQUFNLFdBQVcsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ3pDLENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsUUFBUSxDQUNmLEtBQVUsRUFDVixJQUFZLEVBQ1osTUFBZ0M7SUFFaEMsUUFBUSxJQUFJLEVBQUU7UUFDWixLQUFLLFFBQVE7WUFDWCxPQUFPLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUN6QixLQUFLLFNBQVM7WUFDWixPQUFPLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQyxDQUFDLENBQUMsSUFBQSxlQUFRLEVBQUMsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUM3RCxLQUFLLE9BQU87WUFDVixJQUFJLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsRUFBRTtnQkFDekIsS0FBSyxHQUFHLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDakI7WUFDRCxPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFNLEVBQUUsRUFBRSxDQUMxQixRQUFRLENBQ04sQ0FBQyxFQUNELE1BQU0sRUFBRSxRQUFRLENBQUMsVUFBVSxFQUFFLFdBQVcsQ0FBQyxTQUFTLElBQUksUUFBUSxDQUMvRCxDQUNGLENBQUM7UUFDSix5QkFBeUI7UUFDekIsS0FBSyxRQUFRLENBQUM7UUFDZDtZQUNFLHdEQUF3RDtZQUN4RCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7Z0JBQ3hCLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQ2pCO1lBQ0QsT0FBTyxLQUFLLENBQUM7S0FDaEI7QUFDSCxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxLQUFLLFVBQVUsV0FBVyxDQUN4QixPQUFlLEVBQ2YsSUFBMkIsRUFDM0IsSUFBUztJQUVULHlFQUF5RTtJQUN6RSxNQUFNLEtBQUssR0FBRyxrQkFBa0IsQ0FBQyxPQUFPLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO0lBRXRELG1CQUFRLENBQUMsYUFBYSxDQUFDO1FBQ3JCLEdBQUcsRUFBRSxLQUFLLENBQUMsTUFBTSxJQUFJLE9BQU87UUFDNUIsVUFBVSxFQUFFLElBQUksQ0FBQyxHQUFHO1FBQ3BCLGNBQWMsRUFBRSxLQUFLO1FBQ3JCLFdBQVcsRUFBRSxJQUFJLENBQUMsUUFBUTtZQUN4QixDQUFDLENBQUMscUNBQXNCLENBQUMsUUFBUTtZQUNqQyxDQUFDLENBQUMscUNBQXNCLENBQUMsSUFBSTtRQUMvQixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7UUFDakIsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO0tBQ2hCLENBQUMsQ0FBQztJQUVILElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxjQUFjLENBQUMsQ0FBQyxJQUFJLElBQUksQ0FBQyxJQUFJLEVBQUU7UUFDbEUsSUFBQSxXQUFJLEVBQUMsNkJBQTZCLEVBQUUsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQztLQUN2RDtJQUVELElBQUksSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNaLE1BQU0sR0FBRyxHQUFHLENBQUMsR0FBVyxFQUFFLEVBQUUsQ0FBQyxJQUFBLFdBQUksRUFBQyxPQUFPLEdBQUcsRUFBRSxFQUFFLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUM7UUFDbEUsTUFBTSxVQUFVLEdBQVcsSUFBQSxvQkFBYSxFQUN0QyxJQUFBLGtCQUFXLEVBQUMsZUFBZSxFQUFFLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQzFELENBQUM7UUFDRixPQUFPLENBQUMsS0FBSyxDQUFDLDJCQUEyQixFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQ3ZELElBQUksVUFBVSxJQUFJLE1BQU0sQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLFFBQVEsQ0FBQyxFQUFFO1lBQ2xELEdBQUcsQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUNwQixHQUFHLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDYixHQUFHLENBQUMsOERBQThELENBQUMsQ0FBQztZQUNwRSxPQUFPLENBQUMsS0FBSyxDQUFDLGlDQUFpQyxDQUFDLENBQUM7U0FDbEQ7YUFBTTtZQUNMLEdBQUcsQ0FBQyxNQUFNLENBQUMsQ0FBQztZQUNaLEdBQUcsQ0FBQyxPQUFPLENBQUMsQ0FBQztZQUNiLEdBQUcsQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO1lBQ3BFLE9BQU8sQ0FBQyxLQUFLLENBQ1gsb0VBQW9FLENBQ3JFLENBQUM7WUFDRixHQUFHLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztTQUN2QjtLQUNGO0FBQ0gsQ0FBQztBQUVELGtCQUFlLElBQUksT0FBTyxFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBmcyBmcm9tIFwiZnNcIjtcbmltcG9ydCAqIGFzIHBhdGggZnJvbSBcInBhdGhcIjtcbmltcG9ydCAqIGFzIHNlbXZlciBmcm9tIFwic2VtdmVyXCI7XG5pbXBvcnQgKiBhcyB5YXJncyBmcm9tIFwieWFyZ3NcIjtcbmltcG9ydCAqIGFzIGludmVudG9yeSBmcm9tIFwiLi4vLi4vaW52ZW50b3J5XCI7XG5pbXBvcnQgKiBhcyBsb2dnaW5nIGZyb20gXCIuLi8uLi9sb2dnaW5nXCI7XG5pbXBvcnQgeyBJbml0UHJvamVjdE9wdGlvbkhpbnRzIH0gZnJvbSBcIi4uLy4uL29wdGlvbi1oaW50c1wiO1xuaW1wb3J0IHsgUHJvamVjdHMgfSBmcm9tIFwiLi4vLi4vcHJvamVjdHNcIjtcbmltcG9ydCB7IGV4ZWMsIGV4ZWNDYXB0dXJlLCBnZXRHaXRWZXJzaW9uLCBpc1RydXRoeSB9IGZyb20gXCIuLi8uLi91dGlsXCI7XG5pbXBvcnQgeyB0cnlQcm9jZXNzTWFjcm8gfSBmcm9tIFwiLi4vbWFjcm9zXCI7XG5pbXBvcnQgeyBDbGlFcnJvciwgaW5zdGFsbFBhY2thZ2UsIHJlbmRlckluc3RhbGxDb21tYW5kIH0gZnJvbSBcIi4uL3V0aWxcIjtcblxuY2xhc3MgQ29tbWFuZCBpbXBsZW1lbnRzIHlhcmdzLkNvbW1hbmRNb2R1bGUge1xuICBwdWJsaWMgcmVhZG9ubHkgY29tbWFuZCA9IFwibmV3IFtQUk9KRUNULVRZUEUtTkFNRV0gW09QVElPTlNdXCI7XG4gIHB1YmxpYyByZWFkb25seSBkZXNjcmliZSA9IFwiQ3JlYXRlcyBhIG5ldyBwcm9qZW4gcHJvamVjdFwiO1xuXG4gIHB1YmxpYyBidWlsZGVyKGFyZ3M6IHlhcmdzLkFyZ3YpIHtcbiAgICBhcmdzLnBvc2l0aW9uYWwoXCJQUk9KRUNULVRZUEUtTkFNRVwiLCB7XG4gICAgICBkZXNjcmliZTpcbiAgICAgICAgXCJvcHRpb25hbCBvbmx5IHdoZW4gLS1mcm9tIGlzIHVzZWQgYW5kIHRoZXJlIGlzIGEgc2luZ2xlIHByb2plY3QgdHlwZSBpbiB0aGUgZXh0ZXJuYWwgbW9kdWxlXCIsXG4gICAgICB0eXBlOiBcInN0cmluZ1wiLFxuICAgIH0pO1xuICAgIGFyZ3Mub3B0aW9uKFwic3ludGhcIiwge1xuICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzYzogXCJTeW50aGVzaXplIGFmdGVyIGNyZWF0aW5nIC5wcm9qZW5yYy5qc1wiLFxuICAgIH0pO1xuICAgIGFyZ3Mub3B0aW9uKFwiY29tbWVudHNcIiwge1xuICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzYzogXCJJbmNsdWRlIGNvbW1lbnRlZCBvdXQgb3B0aW9ucyBpbiAucHJvamVucmMuanMgKHVzZSAtLW5vLWNvbW1lbnRzIHRvIGRpc2FibGUpXCIsXG4gICAgfSk7XG4gICAgYXJncy5vcHRpb24oXCJmcm9tXCIsIHtcbiAgICAgIHR5cGU6IFwic3RyaW5nXCIsXG4gICAgICBhbGlhczogXCJmXCIsXG4gICAgICBkZXNjOiAnRXh0ZXJuYWwganNpaSBucG0gbW9kdWxlIHRvIGNyZWF0ZSBwcm9qZWN0IGZyb20uIFN1cHBvcnRzIGFueSBwYWNrYWdlIHNwZWMgc3VwcG9ydGVkIGJ5IG5wbSAoc3VjaCBhcyBcIm15LXBhY2tAXjIuMFwiKScsXG4gICAgfSk7XG4gICAgYXJncy5vcHRpb24oXCJnaXRcIiwge1xuICAgICAgdHlwZTogXCJib29sZWFuXCIsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzYzogXCJSdW4gYGdpdCBpbml0YCBhbmQgY3JlYXRlIGFuIGluaXRpYWwgY29tbWl0ICh1c2UgLS1uby1naXQgdG8gZGlzYWJsZSlcIixcbiAgICB9KTtcbiAgICBhcmdzLmV4YW1wbGUoXG4gICAgICBcInByb2plbiBuZXcgYXdzY2RrLWFwcC10c1wiLFxuICAgICAgJ0NyZWF0ZXMgYSBuZXcgcHJvamVjdCBvZiBidWlsdC1pbiB0eXBlIFwiYXdzY2RrLWFwcC10c1wiJ1xuICAgICk7XG4gICAgYXJncy5leGFtcGxlKFxuICAgICAgXCJwcm9qZW4gbmV3IC0tZnJvbSBwcm9qZW4tdnVlQF4yXCIsXG4gICAgICAnQ3JlYXRlcyBhIG5ldyBwcm9qZWN0IGZyb20gYW4gZXh0ZXJuYWwgbW9kdWxlIFwicHJvamVuLXZ1ZVwiIHdpdGggdGhlIHNwZWNpZmllZCB2ZXJzaW9uJ1xuICAgICk7XG5cbiAgICBmb3IgKGNvbnN0IHR5cGUgb2YgaW52ZW50b3J5LmRpc2NvdmVyKCkpIHtcbiAgICAgIGFyZ3MuY29tbWFuZCh0eXBlLnBqaWQsIHR5cGUuZG9jcyA/PyBcIlwiLCB7XG4gICAgICAgIGJ1aWxkZXI6IChjYXJncykgPT4ge1xuICAgICAgICAgIGNhcmdzLnNob3dIZWxwT25GYWlsKGZhbHNlKTtcblxuICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHR5cGUub3B0aW9ucyA/PyBbXSkge1xuICAgICAgICAgICAgLy8gbm90IGFsbCB0eXBlcyBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gdGhlIGNsaVxuICAgICAgICAgICAgaWYgKCFhcmdUeXBlU3VwcG9ydGVkKG9wdGlvbikpIHtcbiAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IGFyZ0luaXRpYWxWYWx1ZShvcHRpb24pO1xuICAgICAgICAgICAgY2FyZ3Mub3B0aW9uKG9wdGlvbi5zd2l0Y2gsIHtcbiAgICAgICAgICAgICAgZ3JvdXA6ICFvcHRpb24ub3B0aW9uYWwgPyBcIlJlcXVpcmVkOlwiIDogXCJPcHRpb25hbDpcIixcbiAgICAgICAgICAgICAgdHlwZTogYXJnVHlwZShvcHRpb24pLFxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYXJnRGVzYyhvcHRpb24pLFxuICAgICAgICAgICAgICByZXF1aXJlZDogIW9wdGlvbi5vcHRpb25hbCxcbiAgICAgICAgICAgICAgLy8geWFyZ3MgYmVoYXZlcyBkaWZmZXJlbnRseSBmb3IgYXJyYXlzIGlmIHRoZSBkZWZhdWx0VmFsdWUgcHJvcGVydHkgaXMgcHJlc2VudCBvciBub3RcbiAgICAgICAgICAgICAgLi4uKCFvcHRpb24ub3B0aW9uYWwgJiYgZGVmYXVsdFZhbHVlXG4gICAgICAgICAgICAgICAgPyB7IGRlZmF1bHQ6IGRlZmF1bHRWYWx1ZSB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gY2FyZ3M7XG4gICAgICAgIH0sXG4gICAgICAgIGhhbmRsZXI6IChhcmd2KSA9PiBpbml0UHJvamVjdChwcm9jZXNzLmN3ZCgpLCB0eXBlLCBhcmd2KSxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIERpc2FibGUgc3RyaWN0IG1vZGUsIG90aGVyd2lzZSB0aGUgY2F0Y2gtYWxsIGRvZXNuJ3Qgd29ya1xuICAgIGFyZ3Muc3RyaWN0Q29tbWFuZHMoZmFsc2UpO1xuICAgIGFyZ3NcbiAgICAgIC5jb21tYW5kKHtcbiAgICAgICAgY29tbWFuZDogXCIqXCIsXG4gICAgICAgIGRlc2NyaWJlOiBmYWxzZSxcbiAgICAgICAgaGFuZGxlcixcbiAgICAgIH0pXG4gICAgICAubWlkZGxld2FyZSgoYXJndikgPT4ge1xuICAgICAgICAvLyBtYW51YWxseSBzZXQgdGhlIG1hdGNoZWQgY29tbWFuZCBhcyB0aGUgcHJvamVjdCB0eXBlXG4gICAgICAgIGFyZ3YucHJvamVjdFR5cGVOYW1lID0gYXJndi5fWzFdO1xuICAgICAgfSwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gYXJncztcbiAgfVxuXG4gIHB1YmxpYyBhc3luYyBoYW5kbGVyKGFyZ3M6IGFueSkge1xuICAgIHJldHVybiBoYW5kbGVyKGFyZ3MpO1xuICB9XG59XG5cbmFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIoYXJnczogYW55KSB7XG4gIHRyeSB7XG4gICAgLy8gaGFuZGxlIC0tZnJvbSB3aGljaCBtZWFucyB3ZSB3YW50IHRvIGZpcnN0IGluc3RhbGwgYSBqc2lpIG1vZHVsZSBhbmQgdGhlblxuICAgIC8vIGNyZWF0ZSBhIHByb2plY3QgZGVmaW5lZCB3aXRoaW4gdGhpcyBtb2R1bGUuXG4gICAgaWYgKGFyZ3MuZnJvbSkge1xuICAgICAgcmV0dXJuIGF3YWl0IGluaXRQcm9qZWN0RnJvbU1vZHVsZShwcm9jZXNzLmN3ZCgpLCBhcmdzLmZyb20sIGFyZ3MpO1xuICAgIH1cblxuICAgIC8vIHByb2plY3QgdHlwZSBpcyBkZWZpbmVkIGJ1dCB3YXMgbm90IG1hdGNoZWQgYnkgeWFyZ3MsIHNvIHByaW50IHRoZSBsaXN0IG9mIHN1cHBvcnRlZCB0eXBlc1xuICAgIGlmIChhcmdzLnByb2plY3RUeXBlTmFtZSkge1xuICAgICAgY29uc3QgdHlwZXMgPSBpbnZlbnRvcnkuZGlzY292ZXIoKTtcbiAgICAgIHRocm93IG5ldyBDbGlFcnJvcihcbiAgICAgICAgYFByb2plY3QgdHlwZSBcIiR7YXJncy5wcm9qZWN0VHlwZU5hbWV9XCIgbm90IGZvdW5kLiBBdmFpbGFibGUgdHlwZXM6XFxuYCxcbiAgICAgICAgLi4udHlwZXMubWFwKCh0KSA9PiBgICAgICR7dC5wamlkfWApLFxuICAgICAgICBcIlwiLFxuICAgICAgICBgUGxlYXNlIHNwZWNpZnkgYSBwcm9qZWN0IHR5cGUuYCxcbiAgICAgICAgYEV4YW1wbGU6IG5weCBwcm9qZW4gbmV3ICR7dHlwZXNbMF0ucGppZH1gXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZXMgdGhlIHVzZSBjYXNlIHRoYXQgbm90aGluZyB3YXMgc3BlY2lmaWVkIHNpbmNlIFBST0pFQ1QtVFlQRSBpcyBub3cgYW4gb3B0aW9uYWwgcG9zaXRpb25hbCBwYXJhbWV0ZXJcbiAgICB5YXJncy5zaG93SGVscCgpO1xuICB9IGNhdGNoIChlcnJvcjogdW5rbm93bikge1xuICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIENsaUVycm9yKSB7XG4gICAgICBsb2dnaW5nLmVycm9yKGVycm9yLm1lc3NhZ2UpO1xuICAgICAgbG9nZ2luZy5lbXB0eSgpO1xuICAgICAgcHJvY2Vzcy5leGl0Q29kZSA9IDE7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gdW5rbm93biBlcnJvciwgbGlrZWx5IGEgbm9kZSBydW50aW1lIGV4Y2VwdGlvbiBpbiBwcm9qZWN0IGNvZGVcbiAgICAvLyByZXRocm93IHNvIHRoZSBmdWxsIHN0YWNrIHRyYWNlIGlzIGRpc3BsYXllZFxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgeWFyZ3Mgb3B0aW9uIHR5cGUgZm9yIGEgZ2l2ZW4gcHJvamVjdCBvcHRpb25cbiAqL1xuZnVuY3Rpb24gYXJnVHlwZShcbiAgb3B0aW9uOiBpbnZlbnRvcnkuUHJvamVjdE9wdGlvblxuKTogXCJzdHJpbmdcIiB8IFwiYm9vbGVhblwiIHwgXCJudW1iZXJcIiB8IFwiYXJyYXlcIiB7XG4gIGlmIChvcHRpb24ua2luZCA9PT0gXCJlbnVtXCIpIHtcbiAgICByZXR1cm4gXCJzdHJpbmdcIjtcbiAgfVxuXG4gIGlmIChpc1ByaW1pdGl2ZUFycmF5T3B0aW9uKG9wdGlvbikpIHtcbiAgICByZXR1cm4gXCJhcnJheVwiO1xuICB9XG5cbiAgcmV0dXJuIG9wdGlvbi5zaW1wbGVUeXBlIGFzIFwic3RyaW5nXCIgfCBcImJvb2xlYW5cIiB8IFwibnVtYmVyXCI7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVzY3JpcHRpb24gZm9yIGEgZ2l2ZW4gcHJvamVjdCBvcHRpb25cbiAqL1xuZnVuY3Rpb24gYXJnRGVzYyhvcHRpb246IGludmVudG9yeS5Qcm9qZWN0T3B0aW9uKTogc3RyaW5nIHtcbiAgbGV0IGRlc2MgPSBbb3B0aW9uLmRvY3M/LnJlcGxhY2UoL1xcICpcXC4kLywgXCJcIikgPz8gXCJcIl07XG5cbiAgY29uc3QgaGVscERlZmF1bHQgPSBvcHRpb24uaW5pdGlhbFZhbHVlID8/IG9wdGlvbi5kZWZhdWx0O1xuICBpZiAob3B0aW9uLm9wdGlvbmFsICYmIGhlbHBEZWZhdWx0KSB7XG4gICAgZGVzYy5wdXNoKFxuICAgICAgYFtkZWZhdWx0OiAke2hlbHBEZWZhdWx0LnJlcGxhY2UoL15cXCAqLS8sIFwiXCIpLnJlcGxhY2UoL1xcLiQvLCBcIlwiKS50cmltKCl9XWBcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIGRlc2Muam9pbihcIiBcIik7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB0aGUgaW5pdGlhbCB2YWx1ZSBmb3IgYSBnaXZlbiBwcm9qZWN0IG9wdGlvblxuICovXG5mdW5jdGlvbiBhcmdJbml0aWFsVmFsdWUoXG4gIG9wdGlvbjogaW52ZW50b3J5LlByb2plY3RPcHRpb24sXG4gIGN3ZCA9IHByb2Nlc3MuY3dkKClcbik6IGFueSB7XG4gIC8vIGlmIHdlIGhhdmUgZGV0ZXJtaW5lZCBhbiBpbml0aWFsIHZhbHVlIGZvciB0aGUgZmllbGRcbiAgLy8gd2UgY2FuIHNob3cgdGhhdCB2YWx1ZSBpbiAtLWhlbHBcbiAgaWYgKG9wdGlvbi5pbml0aWFsVmFsdWUpIHtcbiAgICByZXR1cm4gcmVuZGVyRGVmYXVsdChjd2QsIG9wdGlvbi5pbml0aWFsVmFsdWUpO1xuICB9XG59XG5cbi8qKlxuICogQ3VycmVudGx5IHdlIG9ubHkgc3VwcG9ydCB0aGVzZSBmaWVsZCB0eXBlcyBhcyBjb21tYW5kIGxpbmUgb3B0aW9uczpcbiAqIC0gcHJpbWl0aXZlcyAoc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4pXG4gKiAtIGxpc3RzIG9mIHByaW1pdGl2ZXNcbiAqIC0gZW51bXNcbiAqL1xuZnVuY3Rpb24gYXJnVHlwZVN1cHBvcnRlZChvcHRpb246IGludmVudG9yeS5Qcm9qZWN0T3B0aW9uKTogYm9vbGVhbiB7XG4gIHJldHVybiAoXG4gICAgb3B0aW9uLnNpbXBsZVR5cGUgPT09IFwic3RyaW5nXCIgfHxcbiAgICBvcHRpb24uc2ltcGxlVHlwZSA9PT0gXCJudW1iZXJcIiB8fFxuICAgIG9wdGlvbi5zaW1wbGVUeXBlID09PSBcImJvb2xlYW5cIiB8fFxuICAgIG9wdGlvbi5raW5kID09PSBcImVudW1cIiB8fFxuICAgIGlzUHJpbWl0aXZlQXJyYXlPcHRpb24ob3B0aW9uKVxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gb3B0aW9uIGlzIGEgcHJpbWl0aXZlIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGlzUHJpbWl0aXZlQXJyYXlPcHRpb24ob3B0aW9uOiBpbnZlbnRvcnkuUHJvamVjdE9wdGlvbik6IGJvb2xlYW4ge1xuICByZXR1cm4gQm9vbGVhbihcbiAgICBvcHRpb24uanNvbkxpa2UgJiZcbiAgICAgIG9wdGlvbi5mdWxsVHlwZS5jb2xsZWN0aW9uPy5raW5kID09PSBcImFycmF5XCIgJiZcbiAgICAgIG9wdGlvbi5mdWxsVHlwZS5jb2xsZWN0aW9uLmVsZW1lbnR0eXBlLnByaW1pdGl2ZSAmJlxuICAgICAgW1wic3RyaW5nXCIsIFwibnVtYmVyXCJdLmluY2x1ZGVzKFxuICAgICAgICBvcHRpb24uZnVsbFR5cGUuY29sbGVjdGlvbi5lbGVtZW50dHlwZS5wcmltaXRpdmVcbiAgICAgIClcbiAgKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIHZhbHVlIGZyb20gXCJAZGVmYXVsdFwiLCBwcm9jZXNzZXMgbWFjcm9zIGFuZCByZXR1cm5zIGEgc3RyaW5naWZpZWRcbiAqIChxdW90ZWQpIHJlc3VsdC5cbiAqXG4gKiBAcmV0dXJucyBhIGphdmFzY3JpcHQgcHJpbWl0aXZlIChjb3VsZCBiZSBhIHN0cmluZywgbnVtYmVyIG9yIGJvb2xlYW4pXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckRlZmF1bHQoY3dkOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgcmV0dXJuIHRyeVByb2Nlc3NNYWNybyhjd2QsIHZhbHVlKSA/PyBKU09OLnBhcnNlKHZhbHVlKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyB5YXJncyBjb21tYW5kIGxpbmUgc3dpdGNoZXMgdG8gcHJvamVjdCB0eXBlIHByb3BzLlxuICogQHBhcmFtIHR5cGUgUHJvamVjdCB0eXBlXG4gKiBAcGFyYW0gYXJndiBDb21tYW5kIGxpbmUgc3dpdGNoZXNcbiAqL1xuZnVuY3Rpb24gY29tbWFuZExpbmVUb1Byb3BzKFxuICBjd2Q6IHN0cmluZyxcbiAgdHlwZTogaW52ZW50b3J5LlByb2plY3RUeXBlLFxuICBhcmd2OiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPlxuKTogUmVjb3JkPHN0cmluZywgYW55PiB7XG4gIGNvbnN0IHByb3BzOiBSZWNvcmQ8c3RyaW5nLCBhbnk+ID0ge307XG5cbiAgLy8gaW5pdGlhbGl6ZSBwcm9wcyB3aXRoIGRlZmF1bHQgdmFsdWVzXG4gIGZvciAoY29uc3QgcHJvcCBvZiB0eXBlLm9wdGlvbnMpIHtcbiAgICBwcm9wc1twcm9wLm5hbWVdID0gYXJnSW5pdGlhbFZhbHVlKHByb3AsIGN3ZCk7XG4gIH1cblxuICBmb3IgKGNvbnN0IFthcmcsIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhhcmd2KSkge1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiB0eXBlLm9wdGlvbnMpIHtcbiAgICAgIGlmIChwcm9wLnN3aXRjaCA9PT0gYXJnKSB7XG4gICAgICAgIGxldCBjdXJyID0gcHJvcHM7XG4gICAgICAgIGNvbnN0IHF1ZXVlID0gWy4uLnByb3AucGF0aF07XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgY29uc3QgcCA9IHF1ZXVlLnNoaWZ0KCk7XG4gICAgICAgICAgaWYgKCFwKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgY3VycltwXSA9IHZhbHVlO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdXJyW3BdID0gY3VycltwXSA/PyB7fTtcbiAgICAgICAgICAgIGN1cnIgPSBjdXJyW3BdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcm9wcztcbn1cblxuLyoqXG4gKiBHZW5lcmF0ZXMgYSBuZXcgcHJvamVjdCBmcm9tIGFuIGV4dGVybmFsIG1vZHVsZS5cbiAqXG4gKiBAcGFyYW0gc3BlYyBUaGUgbmFtZSBvZiB0aGUgZXh0ZXJuYWwgbW9kdWxlIHRvIGxvYWRcbiAqIEBwYXJhbSBhcmdzIENvbW1hbmQgbGluZSBhcmd1bWVudHMgKGluY2wuIHByb2plY3QgdHlwZSlcbiAqL1xuYXN5bmMgZnVuY3Rpb24gaW5pdFByb2plY3RGcm9tTW9kdWxlKGJhc2VEaXI6IHN0cmluZywgc3BlYzogc3RyaW5nLCBhcmdzOiBhbnkpIHtcbiAgY29uc3QgcHJvamVuVmVyc2lvbiA9IGFyZ3MucHJvamVuVmVyc2lvbiA/PyBcImxhdGVzdFwiO1xuICBjb25zdCBpbnN0YWxsQ29tbWFuZCA9IHJlbmRlckluc3RhbGxDb21tYW5kKFxuICAgIGJhc2VEaXIsXG4gICAgYHByb2plbkAke3Byb2plblZlcnNpb259YFxuICApO1xuICBpZiAoYXJncy5wcm9qZW5WZXJzaW9uKSB7XG4gICAgZXhlYyhpbnN0YWxsQ29tbWFuZCwgeyBjd2Q6IGJhc2VEaXIgfSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZG8gbm90IG92ZXJ3cml0ZSBleGlzdGluZyBpbnN0YWxsYXRpb25cbiAgICBleGVjKFxuICAgICAgYG5wbSBscyAtLXByZWZpeD1cIiR7YmFzZURpcn1cIiAtLWRlcHRoPTAgLS1wYXR0ZXJuIHByb2plbiB8fCAke2luc3RhbGxDb21tYW5kfWAsXG4gICAgICB7IGN3ZDogYmFzZURpciB9XG4gICAgKTtcbiAgfVxuXG4gIGNvbnN0IG1vZHVsZU5hbWUgPSBpbnN0YWxsUGFja2FnZShiYXNlRGlyLCBzcGVjKTtcbiAgbG9nZ2luZy5lbXB0eSgpO1xuXG4gIC8vIEZpbmQgdGhlIGp1c3QgaW5zdGFsbGVkIHBhY2thZ2UgYW5kIGRpc2NvdmVyIHRoZSByZXN0IHJlY3Vyc2l2ZWx5IGZyb20gdGhpcyBwYWNrYWdlIGZvbGRlclxuICBjb25zdCBtb2R1bGVEaXIgPSBwYXRoLmRpcm5hbWUoXG4gICAgcmVxdWlyZS5yZXNvbHZlKGAke21vZHVsZU5hbWV9Ly5qc2lpYCwge1xuICAgICAgcGF0aHM6IFtiYXNlRGlyXSxcbiAgICB9KVxuICApO1xuXG4gIC8vIE9ubHkgbGVhdmUgcHJvamVjdHMgZnJvbSB0aGUgbWFpbiAocmVxdWVzdGVkKSBwYWNrYWdlXG4gIGNvbnN0IHByb2plY3RzID0gaW52ZW50b3J5XG4gICAgLmRpc2NvdmVyKG1vZHVsZURpcilcbiAgICAuZmlsdGVyKCh4KSA9PiB4Lm1vZHVsZU5hbWUgPT09IG1vZHVsZU5hbWUpOyAvLyBPbmx5IGxpc3QgcHJvamVjdCB0eXBlcyBmcm9tIHRoZSByZXF1ZXN0ZWQgJ2Zyb20nIG1vZHVsZVxuXG4gIGlmIChwcm9qZWN0cy5sZW5ndGggPCAxKSB7XG4gICAgdGhyb3cgbmV3IENsaUVycm9yKFxuICAgICAgYE5vIHByb2plY3QgdHlwZXMgZm91bmQgYWZ0ZXIgaW5zdGFsbGluZyBcIiR7c3BlY31cIi4gVGhlIG1vZHVsZSBtdXN0IGV4cG9ydCBhdCBsZWFzdCBvbmUgY2xhc3Mgd2hpY2ggZXh0ZW5kcyBcInByb2plbi5Qcm9qZWN0XCIuYFxuICAgICk7XG4gIH1cblxuICBjb25zdCByZXF1ZXN0ZWQgPSBhcmdzLnByb2plY3RUeXBlTmFtZTtcbiAgY29uc3QgdHlwZXMgPSBwcm9qZWN0cy5tYXAoKHApID0+IHAucGppZCk7XG5cbiAgLy8gaWYgdXNlciBkaWQgbm90IHNwZWNpZnkgYSBwcm9qZWN0IHR5cGUgYnV0IHRoZSBtb2R1bGUgaGFzIG1vcmUgdGhhbiBvbmUsIHdlIG5lZWQgdGhlbSB0byB0ZWxsIHVzIHdoaWNoIG9uZS4uLlxuICBpZiAoIXJlcXVlc3RlZCAmJiBwcm9qZWN0cy5sZW5ndGggPiAxKSB7XG4gICAgdGhyb3cgbmV3IENsaUVycm9yKFxuICAgICAgYE11bHRpcGxlIHByb2plY3QgdHlwZXMgZm91bmQgYWZ0ZXIgaW5zdGFsbGluZyBcIiR7c3BlY31cIjpcXG5gLFxuICAgICAgLi4udHlwZXMubWFwKCh0KSA9PiBgICAgICR7dH1gKSxcbiAgICAgIFwiXCIsXG4gICAgICBgUGxlYXNlIHNwZWNpZnkgYSBwcm9qZWN0IHR5cGUuYCxcbiAgICAgIGBFeGFtcGxlOiBucHggcHJvamVuIG5ldyAtLWZyb20gJHtzcGVjfSAke3R5cGVzWzBdfWBcbiAgICApO1xuICB9XG5cbiAgLy8gaWYgdXNlciBkaWQgbm90IHNwZWNpZnkgYSB0eXBlIChhbmQgd2Uga25vdyB3ZSBoYXZlIG9ubHkgb25lKSwgdGhlIHNlbGVjdCBpdC4gb3RoZXJ3aXNlLCBzZWFyY2ggYnkgcGppZC5cbiAgY29uc3QgdHlwZSA9ICFyZXF1ZXN0ZWRcbiAgICA/IHByb2plY3RzWzBdXG4gICAgOiBwcm9qZWN0cy5maW5kKChwKSA9PiBwLnBqaWQgPT09IHJlcXVlc3RlZCk7XG4gIGlmICghdHlwZSkge1xuICAgIHRocm93IG5ldyBDbGlFcnJvcihcbiAgICAgIGBQcm9qZWN0IHR5cGUgXCIke3JlcXVlc3RlZH1cIiBub3QgZm91bmQgaW4gXCIke3NwZWN9XCIuIEZvdW5kOlxcbmAsXG4gICAgICAuLi50eXBlcy5tYXAoKHQpID0+IGAgICAgJHt0fWApLFxuICAgICAgXCJcIixcbiAgICAgIGBQbGVhc2Ugc3BlY2lmeSBhIHZhbGlkIHByb2plY3QgdHlwZS5gLFxuICAgICAgYEV4YW1wbGU6IG5weCBwcm9qZW4gbmV3IC0tZnJvbSAke3NwZWN9ICR7dHlwZXNbMF19YFxuICAgICk7XG4gIH1cblxuICBjb25zdCBtaXNzaW5nT3B0aW9ucyA9IFtdO1xuXG4gIGZvciAoY29uc3Qgb3B0aW9uIG9mIHR5cGUub3B0aW9ucyA/PyBbXSkge1xuICAgIC8vIG5vdCBhbGwgdHlwZXMgY2FuIGJlIHJlcHJlc2VudGVkIGluIHRoZSBjbGlcbiAgICBpZiAoIWFyZ1R5cGVTdXBwb3J0ZWQob3B0aW9uKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgLy8gcGFyc2UgYWxsb3dlZCB0eXBlc1xuICAgIGlmIChhcmdzW29wdGlvbi5uYW1lXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBhcmdzW29wdGlvbi5uYW1lXSA9IHBhcnNlQXJnKGFyZ3Nbb3B0aW9uLm5hbWVdLCBhcmdUeXBlKG9wdGlvbiksIG9wdGlvbik7XG4gICAgICBhcmdzW29wdGlvbi5zd2l0Y2hdID0gYXJnc1tvcHRpb24ubmFtZV07XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICAvLyBSZXF1aXJlZCBvcHRpb24gd2l0aCBhIGRlZmF1bHRcbiAgICBpZiAoIW9wdGlvbi5vcHRpb25hbCAmJiBvcHRpb24uZGVmYXVsdCAmJiBvcHRpb24uZGVmYXVsdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gcmVuZGVyRGVmYXVsdChiYXNlRGlyLCBvcHRpb24uZGVmYXVsdCk7XG4gICAgICBhcmdzW29wdGlvbi5uYW1lXSA9IGRlZmF1bHRWYWx1ZTtcbiAgICAgIGFyZ3Nbb3B0aW9uLnN3aXRjaF0gPSBkZWZhdWx0VmFsdWU7XG4gICAgfVxuXG4gICAgLy8gUmVxdWlyZWQgb3B0aW9uLCBidXQgd2UgY291bGQgbm90IGZpbmQgYSB2YWx1ZVxuICAgIGlmICghb3B0aW9uLm9wdGlvbmFsICYmICFhcmdzW29wdGlvbi5uYW1lXSkge1xuICAgICAgbWlzc2luZ09wdGlvbnMucHVzaChcbiAgICAgICAgYC0tJHtvcHRpb24uc3dpdGNofSBbJHthcmdUeXBlKG9wdGlvbil9XSAke2FyZ0Rlc2Mob3B0aW9uKX1gXG4gICAgICApO1xuICAgIH1cbiAgfVxuXG4gIC8vIFdlIGFyZSBtaXNzaW5nIHNvbWUgcmVxdWlyZWQgb3B0aW9uc1xuICBpZiAobWlzc2luZ09wdGlvbnMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IENsaUVycm9yKFxuICAgICAgYENhbm5vdCBjcmVhdGUgXCIke3R5cGUuZnFufVwiLiBNaXNzaW5nIHJlcXVpcmVkIG9wdGlvbiR7XG4gICAgICAgIG1pc3NpbmdPcHRpb25zLmxlbmd0aCA+IDEgPyBcInNcIiA6IFwiXCJcbiAgICAgIH06YCxcbiAgICAgIC4uLm1pc3NpbmdPcHRpb25zLm1hcCgobSkgPT4gYCAgICAke219YClcbiAgICApO1xuICB9XG5cbiAgLy8gaW5jbHVkZSBhIGRldiBkZXBlbmRlbmN5IGZvciB0aGUgZXh0ZXJuYWwgbW9kdWxlXG4gIGFyZ3MuZGV2RGVwcyA9IFtzcGVjXTtcbiAgYXJnc1tcImRldi1kZXBzXCJdID0gW3NwZWNdO1xuXG4gIGF3YWl0IGluaXRQcm9qZWN0KGJhc2VEaXIsIHR5cGUsIGFyZ3MpO1xufVxuXG4vKipcbiAqIFBhcnNlIGNvbW1hbmQgbGluZSB2YWx1ZSBhcyBvcHRpb24gdHlwZVxuICovXG5mdW5jdGlvbiBwYXJzZUFyZyhcbiAgdmFsdWU6IGFueSxcbiAgdHlwZTogc3RyaW5nLFxuICBvcHRpb24/OiBpbnZlbnRvcnkuUHJvamVjdE9wdGlvblxuKTogYW55IHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlKTtcbiAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IGlzVHJ1dGh5KHZhbHVlKSA6IHZhbHVlO1xuICAgIGNhc2UgXCJhcnJheVwiOlxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IFt2YWx1ZV07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWUubWFwKCh2OiBhbnkpID0+XG4gICAgICAgIHBhcnNlQXJnKFxuICAgICAgICAgIHYsXG4gICAgICAgICAgb3B0aW9uPy5mdWxsVHlwZS5jb2xsZWN0aW9uPy5lbGVtZW50dHlwZS5wcmltaXRpdmUgfHwgXCJzdHJpbmdcIlxuICAgICAgICApXG4gICAgICApO1xuICAgIC8vIHJldHVybiB2YWx1ZSB1bmNoYW5nZWRcbiAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgZGVmYXVsdDpcbiAgICAgIC8vIGlmIHdlIGhhdmUgYW4gdW5leHBlY3RlZCBhcnJheSwgdXNlIHRoZSBmaXJzdCBlbGVtZW50XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlWzBdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICB9XG59XG5cbi8qKlxuICogR2VuZXJhdGVzIGEgbmV3IHByb2plY3QuXG4gKiBAcGFyYW0gdHlwZSBQcm9qZWN0IHR5cGVcbiAqIEBwYXJhbSBhcmdzIENvbW1hbmQgbGluZSBhcmd1bWVudHNcbiAqIEBwYXJhbSBhZGRpdGlvbmFsUHJvcHMgQWRkaXRpb25hbCBwYXJhbWV0ZXJzIHRvIGluY2x1ZGUgaW4gLnByb2plbnJjLmpzXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGluaXRQcm9qZWN0KFxuICBiYXNlRGlyOiBzdHJpbmcsXG4gIHR5cGU6IGludmVudG9yeS5Qcm9qZWN0VHlwZSxcbiAgYXJnczogYW55XG4pIHtcbiAgLy8gY29udmVydCBjb21tYW5kIGxpbmUgYXJndW1lbnRzIHRvIHByb2plY3QgcHJvcHMgdXNpbmcgdHlwZSBpbmZvcm1hdGlvblxuICBjb25zdCBwcm9wcyA9IGNvbW1hbmRMaW5lVG9Qcm9wcyhiYXNlRGlyLCB0eXBlLCBhcmdzKTtcblxuICBQcm9qZWN0cy5jcmVhdGVQcm9qZWN0KHtcbiAgICBkaXI6IHByb3BzLm91dGRpciA/PyBiYXNlRGlyLFxuICAgIHByb2plY3RGcW46IHR5cGUuZnFuLFxuICAgIHByb2plY3RPcHRpb25zOiBwcm9wcyxcbiAgICBvcHRpb25IaW50czogYXJncy5jb21tZW50c1xuICAgICAgPyBJbml0UHJvamVjdE9wdGlvbkhpbnRzLkZFQVRVUkVEXG4gICAgICA6IEluaXRQcm9qZWN0T3B0aW9uSGludHMuTk9ORSxcbiAgICBzeW50aDogYXJncy5zeW50aCxcbiAgICBwb3N0OiBhcmdzLnBvc3QsXG4gIH0pO1xuXG4gIGlmIChmcy5leGlzdHNTeW5jKHBhdGguam9pbihiYXNlRGlyLCBcInBhY2thZ2UuanNvblwiKSkgJiYgYXJncy5wb3N0KSB7XG4gICAgZXhlYyhcIm5wbSBydW4gZXNsaW50IC0taWYtcHJlc2VudFwiLCB7IGN3ZDogYmFzZURpciB9KTtcbiAgfVxuXG4gIGlmIChhcmdzLmdpdCkge1xuICAgIGNvbnN0IGdpdCA9IChjbWQ6IHN0cmluZykgPT4gZXhlYyhgZ2l0ICR7Y21kfWAsIHsgY3dkOiBiYXNlRGlyIH0pO1xuICAgIGNvbnN0IGdpdHZlcnNpb246IHN0cmluZyA9IGdldEdpdFZlcnNpb24oXG4gICAgICBleGVjQ2FwdHVyZShcImdpdCAtLXZlcnNpb25cIiwgeyBjd2Q6IGJhc2VEaXIgfSkudG9TdHJpbmcoKVxuICAgICk7XG4gICAgbG9nZ2luZy5kZWJ1ZyhcInN5c3RlbSB1c2luZyBnaXQgdmVyc2lvbiBcIiwgZ2l0dmVyc2lvbik7XG4gICAgaWYgKGdpdHZlcnNpb24gJiYgc2VtdmVyLmd0ZShnaXR2ZXJzaW9uLCBcIjIuMjguMFwiKSkge1xuICAgICAgZ2l0KFwiaW5pdCAtYiBtYWluXCIpO1xuICAgICAgZ2l0KFwiYWRkIC5cIik7XG4gICAgICBnaXQoJ2NvbW1pdCAtLWFsbG93LWVtcHR5IC1tIFwiY2hvcmU6IHByb2plY3QgY3JlYXRlZCB3aXRoIHByb2plblwiJyk7XG4gICAgICBsb2dnaW5nLmRlYnVnKFwiZGVmYXVsdCBicmFuY2ggbmFtZSBzZXQgdG8gbWFpblwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZ2l0KFwiaW5pdFwiKTtcbiAgICAgIGdpdChcImFkZCAuXCIpO1xuICAgICAgZ2l0KCdjb21taXQgLS1hbGxvdy1lbXB0eSAtbSBcImNob3JlOiBwcm9qZWN0IGNyZWF0ZWQgd2l0aCBwcm9qZW5cIicpO1xuICAgICAgbG9nZ2luZy5kZWJ1ZyhcbiAgICAgICAgXCJvbGRlciB2ZXJzaW9uIG9mIGdpdCBkZXRlY3RlZCwgY2hhbmdlZCBkZWZhdWx0IGJyYW5jaCBuYW1lIHRvIG1haW5cIlxuICAgICAgKTtcbiAgICAgIGdpdChcImJyYW5jaCAtTSBtYWluXCIpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBuZXcgQ29tbWFuZCgpO1xuIl19